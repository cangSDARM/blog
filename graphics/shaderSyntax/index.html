<!DOCTYPE html><html lang="cn"><head><meta charSet="UTF-8"/><title>Graphics Programming(一) —— 渲染流水线 | Graphics</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Graphics Programming(一) —— 渲染流水线 | Graphics"/><meta name="description" content="Personal Blog"/><meta property="og:description" content="Personal Blog"/><meta property="og:type" content="website"/><meta property="twitter:card" content="summary_large_image"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="9"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/b8491e953adc923d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/b8491e953adc923d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-6965b024cefed38b.js" defer=""></script><script src="/blog/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/blog/_next/static/chunks/main-aa6243415bc34dcf.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-ae897f29056b30d9.js" defer=""></script><script src="/blog/_next/static/chunks/29107295-2a9ca7f07685bf37.js" defer=""></script><script src="/blog/_next/static/chunks/117b9d7f-c05aadfcc1af22be.js" defer=""></script><script src="/blog/_next/static/chunks/664-d254d21a6fe56bff.js" defer=""></script><script src="/blog/_next/static/chunks/547-b11266f3fff918ea.js" defer=""></script><script src="/blog/_next/static/chunks/110-81615c5eece2025a.js" defer=""></script><script src="/blog/_next/static/chunks/675-d64d4792f164bc88.js" defer=""></script><script src="/blog/_next/static/chunks/454-7f4dd88afbda086d.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bcollection%5D/%5B...slug%5D-ff6df9841d375177.js" defer=""></script><script src="/blog/_next/static/mOlT7iX02CiRvniF626pw/_buildManifest.js" defer=""></script><script src="/blog/_next/static/mOlT7iX02CiRvniF626pw/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header data-theme="dark" class="style_nav-root__jrAJR" style="height:80px"><section class="style_nav-section__sS_tB"><a class="style_nav-logo__jRYAT" href="/blog"><h3>Allen Lee@Collections</h3></a><nav aria-label="Main" data-orientation="horizontal" dir="ltr" class="style_nav-menus__4aQM9"><div style="position:relative"><ul data-orientation="horizontal" dir="ltr"><li><button class="style_btn__AkQj7 style_subtle__i70rQ style_nav-trigger__ekUye" id="radix-:Rj6:-trigger-radix-:Rjj6:" data-state="closed" aria-expanded="false" aria-controls="radix-:Rj6:-content-radix-:Rjj6:" data-radix-collection-item="">Overview <svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 15 15" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor"></path></svg></button></li></ul></div></nav></section></header><main data-theme="light" style="background-color:var(--colorNeutralBackground1);overflow-x:hidden;overflow-y:auto;width:100vw;height:calc(100vh - 80px)" id="main"><div class="collection_slug_Root__xztwf style_mainStyle__8eIxs"><div class="style_graphicsPost__36P1T"><h1><a href="#" title="undefined" class="style_titleStyle__6CuPY">Graphics Programming(一) —— 渲染流水线</a></h1><h2 id="现代渲染管线分为三个主要阶段"><span class="style_Quote__dLoMM" id="#12">现代渲染管线</span>分为三个主要阶段:<a class="anchor after" aria-hidden="true" aria-label="permalink" tabindex="-1" href="#现代渲染管线分为三个主要阶段"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" focusable="false"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a></h2>
<br/>
<p><a class="style_aStyle__sgfKN" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%98%B6%E6%AE%B5:">应用程序阶段</a> --&gt; <a class="style_aStyle__sgfKN" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5:">几何阶段</a> --&gt; <a class="style_aStyle__sgfKN" href="#%E5%85%89%E6%A0%85%E9%98%B6%E6%AE%B5:">光栅阶段</a></p>
<br/>
<h3><span name="应用程序阶段:">应用程序阶段:</span></h3>
<div class="style_Tab__IjTlz">主要和 CPU,内存打交道. 该阶段末端, 渲染所需的数据(渲染图元 rendering primitives)通过<span class="style_Quote__dLoMM" id="#1">数据总线</span>传送到 GPU<ol>
<li>将渲染图元读取到显存中: 从硬盘 HDD --&gt; 内存 RAM --&gt; 显存 VRAM</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">确定网格怎样被渲染</div>
<div class="style_Tab__IjTlz style_hidden__yfyDi">在Unity中, 通常是使用MeshRender来将信息传递给GPU.<br/>
特别的, 在3D模型中:<div class="style_Tab__IjTlz">skin mesh render: 带蒙皮的骨骼<br/>
mesh filter/ mesh render: 将哪个mesh信息传递给GPU/ 没有骨骼的模型</div></div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG"><span class="style_Quote__dLoMM" id="#11">调用Draw Call</span></div>
<!-- -->: CPU 通知 GPU 渲染<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">CPU向一个队列&quot;命令缓冲区&quot;push命令, 而GPU从其中pull命令.<br/>
这样实现了CPU和GPU的并行工作<br/>
通常性能的优化都会减少Draw Call的个数</div><br/>
</li>
</ol></div>
<h3><span name="几何阶段:">几何阶段:</span></h3>
<div class="style_Tab__IjTlz">主要和 GPU 打交道. 该阶段末端, 得到经过变换和投影之后的顶点坐标, 颜色及纹理坐标<ol>
<li>
<div role="expansion" class="style_Expansion__lekPG">顶点着色器</div>
<!-- -->: 实现顶点空间变换, 顶点着色, 光照等(可编程)<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">它的输入来自于CPU. 每个顶点都会调用一次顶点着色器.<br/>
顶点着色器本身本可以创建和销毁任何顶点, 而且
<span class="style_Quote__dLoMM" id="#6">顶点顶点之间是相互独立的</span>.<br/>
它最基本且必须完成的工作是: 将顶点坐标从 模型空间 转换到 <span class="style_Quote__dLoMM" id="#7">
齐次裁剪坐标系
</span> 下</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">曲面细分着色器</div>
<!-- -->: 用于细分图元(可选着色器, 可编程)
<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">很遗憾, 此部分并没有学到.</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">几何着色器</div>
<!-- -->:
执行逐图元的着色(Per-Primitive)或产生更多图元(可选着色器, 可编程)
<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">很遗憾, 此部分并没有学到.</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">裁剪</div>
<!-- -->:<!-- -->
<span class="style_Quote__dLoMM" id="#2">视锥裁剪</span>
<!-- -->(可配置)<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">确认视锥(即选择投影类型)并裁剪<br/>
裁剪并不一定是通过GPU来运算. 也可以<span class="style_Quote__dLoMM" id="#8">通过CPU运算</span>
后直接跳过该步骤.</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">屏幕映射</div>
<!-- -->: 将CVV 转换为Clip and Project space<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">屏幕映射(Screen Mapping)并不会处理深度值Z.<br/>
值得注意的是, OpenGL的坐标系将&quot;屏幕的左下角&quot;当作原点(0,0);
而DirectX的坐标系将&quot;屏幕的左上角&quot;当作原点(0,0)</div><br/>
<!-- -->附录: <!-- -->
<div role="expansion" class="style_Expansion__lekPG">
<span class="style_Quote__dLoMM" id="#13">坐标空间</span>
</div>
<!-- -->: 依照先后顺序<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">Object space物体坐标系
<span class="style_Quote__dLoMM" id="#3">--&gt;</span>
World space世界坐标系
<span class="style_Quote__dLoMM" id="#4">--&gt;</span>
View space观察坐标系
<span class="style_Quote__dLoMM" id="#5">--&gt;</span>
Project space屏幕坐标系<table><tbody><tr><th>Object space</th><td>模型建立时得到的坐标. 与其它物体没有任何参照关系</td></tr><tr><th>World space</th><td>以一个固定的坐标原点经行参照确定物体位置</td></tr><tr><th>View space</th><td>以Camera为原点, 组成的正交坐标系</td></tr><tr><th>Project space</th><td>屏幕坐标系</td></tr></tbody></table></div><br/>
</li>
</ol></div>
<h3><span name="光栅阶段:">光栅阶段:</span></h3>
<div class="style_Tab__IjTlz">基于几何阶段输出的数据, 雾化, 透明及为pixel正确配色. 经行单个像素的操作, 每个pixel的信息存储在颜色缓冲器(color buffer 或frame buffer)中<ol>
<li>
<div role="expansion" class="style_Expansion__lekPG">三角形设置</div>
<!-- -->: 计算光栅化一个三角网格所需的信息<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">上一阶段输出的是&quot;三角网格的顶点&quot;即每条边的两个端点.
如果需要得到三角网格对pixel的覆盖情况, 需要计算每条边的像素坐标.<br/>三角形设置(Triangle Setup)通过计算三角形边界的表示形式来确定每条边的坐标</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">三角形遍历</div>
<div class="style_Tab__IjTlz style_hidden__yfyDi"><span class="style_Quote__dLoMM" id="#9">三角形遍历</span>(Triangle
Traversal)确定每个三角网格所覆盖的pixel, 并使用顶点信息对覆盖区域进行差值<br/>遍历完成后的输出就称之为片元(fragment), 包含了深度值Z, 法线, 纹理等信息,
可以说是&quot;收集完全但未计算的像素信息&quot;</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">片元着色器</div>
<!-- -->: 实现逐片元的着色(Per-Fragment)(可编程)<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">这一阶段包含许多的渲染技术. 最重要的就是纹理采样(将贴图,
法线等颜色信息给片元)<br/>但它仅能影响单个片元, 无法将结果发送给它周围的pixel.(法线信息除外)</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">逐片元操作</div>
<!-- -->: 片元的可见性, 深度缓冲, 颜色混合等(可配置)<!-- -->
<div class="style_Tab__IjTlz style_hidden__yfyDi">在OpenGL中称为逐片元操作(Per-Fragment Operations),
在DirectX中称为输出合并阶段(Output-Merger)<br/>需要经过<div role="expansion" class="style_Expansion__lekPG"><span class="style_Quote__dLoMM" id="#10">两个测试</span></div>, 来决定片元的可见性问题<div class="style_Tab__IjTlz style_hidden__yfyDi">模板测试 --&gt; 深度测试<table><tbody><tr><th>模板测试</th><td>通常用于限制渲染的区域. 也可以用来渲染阴影, 轮廓渲染等</td></tr><tr><th>深度测试</th><td>通常用于视野深度计算</td></tr></tbody></table></div><br/>之后需要经行混合(Blend)操作,
决定此次操作和前一次操作的关系(实现不透明(全覆盖)或半透明(局部覆盖))</div><br/>
</li>
<li>
<div role="expansion" class="style_Expansion__lekPG">屏幕图像</div>
<div class="style_Tab__IjTlz style_hidden__yfyDi">使用通常所说的双缓冲技术(Double Buffering). 前置缓冲(front
buffer)和后置缓冲(frame buffer|back buffer)交替显示</div><br/>
</li>
</ol></div><div id="Comment" class="style_Comment__GsBhh"></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"matter":{"title":"Graphics Programming(一) —— 渲染流水线","tags":["graphics","index"],"index":1},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/index.mdx","type":"mdx","slug":["index"],"collection":"graphics","url":"/graphics/index"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(一) —— 渲染流水线\",\n  \"tags\": [\"graphics\", \"index\"],\n  \"index\": 1\n};\nconst QuoteList = ['\"数据总线\"是用于在多个设备间传输数据的通道. \"端口\"是用于在两个设备间传输数据的通道, 总线和端口将功能模块粘结在一起', \"视锥裁剪(Frustum Culling)在视锥(viewing frustum)中运行并非易事, 因此放在规范立方体(Canonical view volume, CVV 一个单位立方体)中经行\", \"Object space --\u003e World space 转换: 通常称为world matrix来转换\", \"World space --\u003e View space 转换: GPU运算\", \"View space --\u003e Project space 转换: 1. 用透视变换将顶点变换到CVV中; 2. 在CVV中经行视锥裁剪; 3. 将坐标映射到屏幕坐标系\", '意味着无法获取例如\"是否是同一网格\"之类的信息, 但同时GPU可以并行处理', \"齐次裁剪坐标也就是CVV坐标. 需要注意的是其深度值Z, 在OpenGL和Unity中, 范围是[-1, 1]; 而Direct中, 范围是[0, 1]\", \"关于c++视锥裁剪算法请参考: OGRE(Object-Oriented Graphics Rendering Engine)的源码\", \"这一阶段也被称为扫描变换(Scan Conversion)\", \"由于后置测试中被舍弃的片元会浪费前面的性能, 因此GPU通常会判断片元着色器和提前测试(Early-Z)是否冲突来决定是否使用提前测试. 如果冲突将禁用提前测试开启后置测试\", \"在OpenGL中是glDrawElements, DirectX中是DrawIndexedPrimitive\", \"现代渲染管线也称为可编程管线. 在较旧的GPU上称为固定函数流水线(Fixed-Function Pipeline), 这是一种配置管线(只提供开关功能)\", \"此部分内容会在第四部分(编写shader的数学基础)中完整叙述\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h2: \"h2\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    path: \"path\",\n    svg: \"svg\",\n    ...props.components\n  }, {Anchor, Expansion, Quote, Tab, Table} = _components;\n  if (!Anchor) _missingMdxReference(\"Anchor\", true);\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  if (!Table) _missingMdxReference(\"Table\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"现代渲染管线分为三个主要阶段\",\n      children: [_jsx(Quote, {\n        id: \"#12\",\n        children: \"现代渲染管线\"\n      }), \"分为三个主要阶段:\", _jsx(_components.a, {\n        className: \"anchor after\",\n        \"aria-hidden\": true,\n        \"aria-label\": \"permalink\",\n        tabIndex: \"-1\",\n        href: \"#现代渲染管线分为三个主要阶段\",\n        children: _jsx(_components.svg, {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 16 16\",\n          focusable: \"false\",\n          children: _jsx(_components.path, {\n            d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\",\n            fillRule: \"evenodd\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%98%B6%E6%AE%B5:\",\n        children: \"应用程序阶段\"\n      }), \" --\u003e \", _jsx(_components.a, {\n        href: \"#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5:\",\n        children: \"几何阶段\"\n      }), \" --\u003e \", _jsx(_components.a, {\n        href: \"#%E5%85%89%E6%A0%85%E9%98%B6%E6%AE%B5:\",\n        children: \"光栅阶段\"\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Anchor, {\n      children: \"应用程序阶段:\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"主要和 CPU,内存打交道. 该阶段末端, 渲染所需的数据(渲染图元 rendering primitives)通过\", _jsx(Quote, {\n        id: \"#1\",\n        children: \"数据总线\"\n      }), \"传送到 GPU\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"将渲染图元读取到显存中: 从硬盘 HDD --\u003e 内存 RAM --\u003e 显存 VRAM\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"确定网格怎样被渲染\"\n          }), \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"在Unity中, 通常是使用MeshRender来将信息传递给GPU.\", _jsx(\"br\", {}), \"\\n特别的, 在3D模型中:\", _jsxs(Tab, {\n              children: [\"skin mesh render: 带蒙皮的骨骼\", _jsx(\"br\", {}), \"\\nmesh filter/ mesh render: 将哪个mesh信息传递给GPU/ 没有骨骼的模型\"]\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: _jsx(Quote, {\n              id: \"#11\",\n              children: \"调用Draw Call\"\n            })\n          }), \"\\n\", \": CPU 通知 GPU 渲染\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"CPU向一个队列\\\"命令缓冲区\\\"push命令, 而GPU从其中pull命令.\", _jsx(\"br\", {}), \"\\n这样实现了CPU和GPU的并行工作\", _jsx(\"br\", {}), \"\\n通常性能的优化都会减少Draw Call的个数\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(Anchor, {\n      children: \"几何阶段:\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"主要和 GPU 打交道. 该阶段末端, 得到经过变换和投影之后的顶点坐标, 颜色及纹理坐标\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"顶点着色器\"\n          }), \"\\n\", \": 实现顶点空间变换, 顶点着色, 光照等(可编程)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"它的输入来自于CPU. 每个顶点都会调用一次顶点着色器.\", _jsx(\"br\", {}), \"\\n顶点着色器本身本可以创建和销毁任何顶点, 而且\\n\", _jsx(Quote, {\n              id: \"#6\",\n              children: \"顶点顶点之间是相互独立的\"\n            }), \".\", _jsx(\"br\", {}), \"\\n它最基本且必须完成的工作是: 将顶点坐标从 模型空间 转换到 \", _jsx(Quote, {\n              id: \"#7\",\n              children: \"\\n齐次裁剪坐标系\\n\"\n            }), \" 下\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"曲面细分着色器\"\n          }), \"\\n\", \": 用于细分图元(可选着色器, 可编程)\\n\", \"\\n\", _jsx(Tab, {\n            expan: true,\n            children: \"很遗憾, 此部分并没有学到.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"几何着色器\"\n          }), \"\\n\", \":\\n执行逐图元的着色(Per-Primitive)或产生更多图元(可选着色器, 可编程)\\n\", \"\\n\", _jsx(Tab, {\n            expan: true,\n            children: \"很遗憾, 此部分并没有学到.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"裁剪\"\n          }), \"\\n\", \":\", \"\\n\", _jsx(Quote, {\n            id: \"#2\",\n            children: \"视锥裁剪\"\n          }), \"\\n\", \"(可配置)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"确认视锥(即选择投影类型)并裁剪\", _jsx(\"br\", {}), \"\\n裁剪并不一定是通过GPU来运算. 也可以\", _jsx(Quote, {\n              id: \"#8\",\n              children: \"通过CPU运算\"\n            }), \"\\n后直接跳过该步骤.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"屏幕映射\"\n          }), \"\\n\", \": 将CVV 转换为Clip and Project space\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"屏幕映射(Screen Mapping)并不会处理深度值Z.\", _jsx(\"br\", {}), \"\\n值得注意的是, OpenGL的坐标系将\\\"屏幕的左下角\\\"当作原点(0,0);\\n而DirectX的坐标系将\\\"屏幕的左上角\\\"当作原点(0,0)\"]\n          }), \"\\n\", \"附录: \", \"\\n\", _jsxs(Expansion, {\n            children: [\"\\n\", _jsx(Quote, {\n              id: \"#13\",\n              children: \"坐标空间\"\n            }), \"\\n\"]\n          }), \"\\n\", \": 依照先后顺序\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"Object space物体坐标系\\n\", _jsx(Quote, {\n              id: \"#3\",\n              children: \"--\u003e\"\n            }), \"\\nWorld space世界坐标系\\n\", _jsx(Quote, {\n              id: \"#4\",\n              children: \"--\u003e\"\n            }), \"\\nView space观察坐标系\\n\", _jsx(Quote, {\n              id: \"#5\",\n              children: \"--\u003e\"\n            }), \"\\nProject space屏幕坐标系\", _jsx(Table, {\n              children: [{\n                cells: [\"Object space\", \"模型建立时得到的坐标. 与其它物体没有任何参照关系\"],\n                component: [\"th\"]\n              }, {\n                cells: [\"World space\", \"以一个固定的坐标原点经行参照确定物体位置\"],\n                component: [\"th\"]\n              }, {\n                cells: [\"View space\", \"以Camera为原点, 组成的正交坐标系\"],\n                component: [\"th\"]\n              }, {\n                cells: [\"Project space\", \"屏幕坐标系\"],\n                component: [\"th\"]\n              }]\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(Anchor, {\n      children: \"光栅阶段:\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"基于几何阶段输出的数据, 雾化, 透明及为pixel正确配色. 经行单个像素的操作, 每个pixel的信息存储在颜色缓冲器(color buffer 或frame buffer)中\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"三角形设置\"\n          }), \"\\n\", \": 计算光栅化一个三角网格所需的信息\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"上一阶段输出的是\\\"三角网格的顶点\\\"即每条边的两个端点.\\n如果需要得到三角网格对pixel的覆盖情况, 需要计算每条边的像素坐标.\", _jsx(\"br\", {}), \"三角形设置(Triangle Setup)通过计算三角形边界的表示形式来确定每条边的坐标\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"三角形遍历\"\n          }), \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [_jsx(Quote, {\n              id: \"#9\",\n              children: \"三角形遍历\"\n            }), \"(Triangle\\nTraversal)确定每个三角网格所覆盖的pixel, 并使用顶点信息对覆盖区域进行差值\", _jsx(\"br\", {}), \"遍历完成后的输出就称之为片元(fragment), 包含了深度值Z, 法线, 纹理等信息,\\n可以说是\\\"收集完全但未计算的像素信息\\\"\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"片元着色器\"\n          }), \"\\n\", \": 实现逐片元的着色(Per-Fragment)(可编程)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"这一阶段包含许多的渲染技术. 最重要的就是纹理采样(将贴图,\\n法线等颜色信息给片元)\", _jsx(\"br\", {}), \"但它仅能影响单个片元, 无法将结果发送给它周围的pixel.(法线信息除外)\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"逐片元操作\"\n          }), \"\\n\", \": 片元的可见性, 深度缓冲, 颜色混合等(可配置)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"在OpenGL中称为逐片元操作(Per-Fragment Operations),\\n在DirectX中称为输出合并阶段(Output-Merger)\", _jsx(\"br\", {}), \"需要经过\", _jsx(Expansion, {\n              children: _jsx(Quote, {\n                id: \"#10\",\n                children: \"两个测试\"\n              })\n            }), \", 来决定片元的可见性问题\", _jsxs(Tab, {\n              expan: true,\n              children: [\"模板测试 --\u003e 深度测试\", _jsx(Table, {\n                children: [{\n                  cells: [\"模板测试\", \"通常用于限制渲染的区域. 也可以用来渲染阴影, 轮廓渲染等\"],\n                  component: [\"th\"]\n                }, {\n                  cells: [\"深度测试\", \"通常用于视野深度计算\"],\n                  component: [\"th\"]\n                }]\n              })]\n            }), \"之后需要经行混合(Blend)操作,\\n决定此次操作和前一次操作的关系(实现不透明(全覆盖)或半透明(局部覆盖))\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"屏幕图像\"\n          }), \"\\n\", _jsx(Tab, {\n            expan: true,\n            children: \"使用通常所说的双缓冲技术(Double Buffering). 前置缓冲(front\\nbuffer)和后置缓冲(frame buffer|back buffer)交替显示\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[{"depth":2,"value":"现代渲染管线分为三个主要阶段:","id":"现代渲染管线分为三个主要阶段"}]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"},{"name":"practice","length":5}]},"__N_SSG":true},"page":"/[collection]/[...slug]","query":{"collection":"graphics","slug":["shaderSyntax","index"]},"buildId":"mOlT7iX02CiRvniF626pw","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>