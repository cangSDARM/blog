<!DOCTYPE html><html lang="cn"><head><meta charSet="UTF-8"/><title>第三章 | Network</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="第三章 | Network"/><meta name="description" content="Personal Blog"/><meta property="og:description" content="Personal Blog"/><meta property="og:type" content="website"/><meta property="twitter:card" content="summary_large_image"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="9"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog/_next/static/css/45e5796e091b4383.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/45e5796e091b4383.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/c7fd63396ea487eb.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/c7fd63396ea487eb.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/blog/_next/static/chunks/webpack-6965b024cefed38b.js" defer=""></script><script src="/blog/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/blog/_next/static/chunks/main-2917097014419c1d.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-ff17d0cfb1e0c0c9.js" defer=""></script><script src="/blog/_next/static/chunks/29107295-661baa9a9eae34db.js" defer=""></script><script src="/blog/_next/static/chunks/814c6784-d7d96a807e1f8484.js" defer=""></script><script src="/blog/_next/static/chunks/664-8af8765c6fed5950.js" defer=""></script><script src="/blog/_next/static/chunks/121-83baa50662375b7d.js" defer=""></script><script src="/blog/_next/static/chunks/675-c1479de6d423831c.js" defer=""></script><script src="/blog/_next/static/chunks/460-e203ea15416d29fa.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bcollection%5D/%5B...slug%5D-74b107c74286f645.js" defer=""></script><script src="/blog/_next/static/mzuzm50yGf6vkf53yEM99/_buildManifest.js" defer=""></script><script src="/blog/_next/static/mzuzm50yGf6vkf53yEM99/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header data-theme="dark" class="style_nav-root__yUsZa" style="height:80px"><section class="style_nav-section__SjkNQ"><a class="style_nav-logo__UiRaj" href="/blog"><h3>Allen Lee@Blog</h3></a><nav aria-label="Main" data-orientation="horizontal" dir="ltr" class="style_nav-menus__wdzNT"><div style="position:relative"><ul data-orientation="horizontal" dir="ltr"><li><button class="style_btn__g6gfm style_subtle__UH7MW style_nav-trigger__QiQTA" id="radix-:Rj6:-trigger-radix-:Rjj6:" data-state="closed" aria-expanded="false" aria-controls="radix-:Rj6:-content-radix-:Rjj6:" data-radix-collection-item="">Overview <svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 15 15" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor"></path></svg></button></li></ul></div></nav></section></header><main data-theme="light" style="background-color:var(--colorNeutralBackground1);overflow-x:hidden;overflow-y:auto;width:100vw;height:calc(100vh - 80px)" id="main"><div class="collection_slug_Root__qGxja"><div class="styles_netPost__2AMMk" style="max-width:960px;font-family:YaHei, Helvetica, arial, sans-serif;font-size:16px"><h1>第三章</h1><p>网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。因此<strong>运输层协议只工作在端系统上，路由器只处理到网络层</strong></p>
<p>将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用(transprot-layer multiplexing)</strong>，将数据块封装上首部信息生成报文段并传递到网络层；<strong>多路分解(demultiplexing)</strong>，将将运输层报文段的数据交付到正确的套接字</p>
<p>**数据报拥塞控制协议(Datagram Congestion Control Protocol, DCCP)**实现了面向报文、控制拥塞的类似 UDP 不可靠服务</p>
<h3 style="margin:20px 0 10px" id="udp">UDP<a rel="noopener noreferrer external nofollow" target="_blank" href="#udp" class="anchor after" aria-hidden="true" aria-label="permalink" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" focusable="false"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a></h3>
<p>除了复用/分解功能及少量的差错检测外，UDP 几乎没有对 ip 增加别的东西。</p>
<p>DNS 协议运行在 UDP 之上</p>
<p>UDP 可以实现可靠传输的，但是在应用层实现。如 Chrome 的 QUIC(快速 UDP 因特网连接)
</p>
<figure role="figure"><span class="resp-image-wrapper" style="display:flex;align-items:center;justify-content:center;position:relative"><a target="_blank" rel="noopener" style="display:block" href="/blog/images/network/udp_message.webp"><img crossorigin="anonymous" alt="udp_message" loading="lazy" width="445" height="474" decoding="async" data-nimg="1" style="color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http%3A//www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 445 474&#x27;%3E%3Cfilter id=&#x27;b&#x27; color-interpolation-filters=&#x27;sRGB&#x27;%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3C/filter%3E%3Cimage preserveAspectRatio=&#x27;none&#x27; filter=&#x27;url(%23b)&#x27; x=&#x27;0&#x27; y=&#x27;0&#x27; height=&#x27;100%25&#x27; width=&#x27;100%25&#x27; href=&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAO0lEQVR4nGP49evX5cvn1q9b3lxfxmBrZ+Ph4S4kyC0mxMHg7Oxgaqyvp6dpbqLLkJWZAkR5uZmZGUkALjoSKkizynoAAAAASUVORK5CYII=&#x27;/%3E%3C/svg%3E&quot;)" src="/blog/images/network/udp_message.webp"/></a></span><figcaption role="figcaption">udp_message</figcaption></figure>
<p>
UDP 首部只有 4 个字段，共 64bit, 8 字节</p>
<ul>
<li>长度字段指明 UDP 报文段的总字节数(首部+数据)</li>
<li>检验和为 UDP 提供差错检测功能</li>
</ul>
<p>UDP 协议里，应用程序的客户端让运输层自动的(且透明的)分配端口号，而服务端分配特定的端口号，不同源地址或不同源端口都没有关系，只要目标端口、目标主机地址相同，都会被分配到同一套接字</p>
<h3 style="margin:20px 0 10px" id="可靠数据传输原理">可靠数据传输原理<a rel="noopener noreferrer external nofollow" target="_blank" href="#可靠数据传输原理" class="anchor after" aria-hidden="true" aria-label="permalink" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" focusable="false"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a></h3>
<p><strong>比较复杂，笔记没用。看书！！！</strong>
</p>
<figure role="figure"><span class="resp-image-wrapper" style="display:flex;align-items:center;justify-content:center;position:relative"><a target="_blank" rel="noopener" style="display:block" href="/blog/images/network/reliable_data_transmission_mechanism&amp;its_use.webp"><img crossorigin="anonymous" alt="reliable_data_transmission_mechanism&amp;its_use" loading="lazy" width="621" height="301" decoding="async" data-nimg="1" style="color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http%3A//www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 621 301&#x27;%3E%3Cfilter id=&#x27;b&#x27; color-interpolation-filters=&#x27;sRGB&#x27;%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3C/filter%3E%3Cimage preserveAspectRatio=&#x27;none&#x27; filter=&#x27;url(%23b)&#x27; x=&#x27;0&#x27; y=&#x27;0&#x27; height=&#x27;100%25&#x27; width=&#x27;100%25&#x27; href=&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAIklEQVR4nGOwNdEM8nEvKix49ew5g5QQk5yUqAgfV2xEOABpjQc97pU92AAAAABJRU5ErkJggg==&#x27;/%3E%3C/svg%3E&quot;)" src="/blog/images/network/reliable_data_transmission_mechanism&amp;its_use.webp"/></a></span><figcaption role="figcaption">reliable_data_transmission_mechanism&amp;its_use</figcaption></figure>
<h3 style="margin:20px 0 10px" id="tcp">TCP<a rel="noopener noreferrer external nofollow" target="_blank" href="#tcp" class="anchor after" aria-hidden="true" aria-label="permalink" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" focusable="false"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a></h3>
<p>TCP 是面向连接、全双工、点对点的协议</p>
<p>TCP 报文段的长度受限于<strong>最大报文段长度(Maximum Segment Size, MSS)</strong>，而 MSS 通常根据主机的**最大链路帧长度(AKA 最大传输单元 Maximum Transmission Unit, MTU)**来设置。如底层以太网协议和 PPP 链路层协议 MTU=1500 字节，MSS 典型值就是 1460 字节(加首部 40 字节，共 1500)。
</p>
<figure role="figure"><span class="resp-image-wrapper" style="display:flex;align-items:center;justify-content:center;position:relative"><a target="_blank" rel="noopener" style="display:block" href="/blog/images/network/tcp_message.webp"><img crossorigin="anonymous" alt="tcp_message" loading="lazy" width="467" height="478" decoding="async" data-nimg="1" style="color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http%3A//www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 467 478&#x27;%3E%3Cfilter id=&#x27;b&#x27; color-interpolation-filters=&#x27;sRGB&#x27;%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3C/filter%3E%3Cimage preserveAspectRatio=&#x27;none&#x27; filter=&#x27;url(%23b)&#x27; x=&#x27;0&#x27; y=&#x27;0&#x27; height=&#x27;100%25&#x27; width=&#x27;100%25&#x27; href=&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAOklEQVR4nGP49fsbEO3cvikp2puhsDCvpbWpqDBHSVqIIT42srK8qLGuVlyQjaGzvQnImTp5UoCPOwC1Xxcs97dJzAAAAABJRU5ErkJggg==&#x27;/%3E%3C/svg%3E&quot;)" src="/blog/images/network/tcp_message.webp"/></a></span><figcaption role="figcaption">tcp_message</figcaption></figure>
<p>
TCP 首部共有 20 字节，但可变</p>
<ul>
<li>序号和确认号用来实现可靠数据传输(各 32bit)</li>
<li>接收窗口字段指示接收方愿意接收的字节数(16bit)</li>
<li>首部长度字段指示以 32bit 为单位的 TCP 首部长度(4bit)</li>
<li>选项字段用于协调窗口调节(可选+变长)</li>
<li>标志字段用于控制 TCP 状态，如 ACK, FIN(6bit)</li>
</ul>
<p>TCP 链接通过 <code>&lt;源 IP 地址、 源端口号、 目的 IP 地址、 目的端口号&gt;</code> 组来唯一标识每条连接。如 web 服务器，虽然所有客户端的目标 IP 和目标端口相同，但是源 IP 地址或源端口都不相同，则服务器上限会远远大于服务器端口数量（在 linux 上，每个链接都是以一个文件形式标识，则最大并发数受限于内存大小）</p>
<p>TCP 是<strong>有序</strong>传输的，对于失序的报文段会整理成序再发给应用层</p>
<p>TCP 的初始序号可以随机选择，以减少将仍在网络上的旧连接的报文段，误认为是新连接的报文段的可能性(防止和旧连接使用同一端口)</p>
<p>TCP 在收到三次<strong>冗余 ACK</strong>（同一 ACK 回复）时，会触发<strong>快速重传(fast retransmit)</strong>，即在该报文段的定时器过期之前就重传
</p>
<figure role="figure"><span class="resp-image-wrapper" style="display:flex;align-items:center;justify-content:center;position:relative"><a target="_blank" rel="noopener" style="display:block" href="/blog/images/network/fast_retransmission.webp"><img crossorigin="anonymous" alt="fast_retransmission" loading="lazy" width="541" height="791" decoding="async" data-nimg="1" style="color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http%3A//www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 541 791&#x27;%3E%3Cfilter id=&#x27;b&#x27; color-interpolation-filters=&#x27;sRGB&#x27;%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3C/filter%3E%3Cimage preserveAspectRatio=&#x27;none&#x27; filter=&#x27;url(%23b)&#x27; x=&#x27;0&#x27; y=&#x27;0&#x27; height=&#x27;100%25&#x27; width=&#x27;100%25&#x27; href=&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAECAIAAADETxJQAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAALUlEQVR4nGOwsbLct3fHtw+vGEJD/NmYGXZuWcegpaHu4mQHYkmICwPFjPU1ATxnDP27RqP1AAAAAElFTkSuQmCC&#x27;/%3E%3C/svg%3E&quot;)" src="/blog/images/network/fast_retransmission.webp"/></a></span><figcaption role="figcaption">fast_retransmission</figcaption></figure>
<p>
TCP 提供<strong>流量控制服务(flow-control service)</strong>，以消除发送端使得接收端缓存溢出的可能。发送端需要控制<code>LastByteSent - LastByteAcked ≤ rwnd</code>，其中，rwnd 是首部的接收窗口字段，rwnd=RcvBuffer - [LastByteRcvd - LastByteRead]。在 rwnd 为 0 时，发送端会一直发送只有一字节数据的报文段，直到返回非 0 的 rwnd 值。</p>
<p>TCP 通过三次握手，四次挥手工作。SYN 洪泛攻击可以通过设置 SYN cookie 来防御</p>
<p>当关闭 TCP 连接时，会通过一个控制块记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍(称为 2MSL)，以确保链接重用。</p>
<h4 id="拥塞控制congestion-control">拥塞控制(congestion control)<a rel="noopener noreferrer external nofollow" target="_blank" href="#拥塞控制congestion-control" class="anchor after" aria-hidden="true" aria-label="permalink" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" focusable="false"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a></h4>
<p>用于减少网络环境对连接的影响(如突然过载或拥塞)。即<code>LastByteSent - LastByteAcked ≤ min{ rwnd, cwnd }</code>，其中，cwnd 代表拥塞窗口通过**TCP 拥塞控制算法(TCP comgestion control algorithm)**来控制：
</p>
<figure role="figure"><span class="resp-image-wrapper" style="display:flex;align-items:center;justify-content:center;position:relative"><a target="_blank" rel="noopener" style="display:block" href="/blog/images/network/tcp_congestion_control.webp"><img crossorigin="anonymous" alt="tcp_congestion_control" loading="lazy" width="679" height="589" decoding="async" data-nimg="1" style="color:transparent;background-size:cover;background-position:50% 50%;background-repeat:no-repeat;background-image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&#x27;http%3A//www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 679 589&#x27;%3E%3Cfilter id=&#x27;b&#x27; color-interpolation-filters=&#x27;sRGB&#x27;%3E%3CfeGaussianBlur stdDeviation=&#x27;20&#x27;/%3E%3C/filter%3E%3Cimage preserveAspectRatio=&#x27;none&#x27; filter=&#x27;url(%23b)&#x27; x=&#x27;0&#x27; y=&#x27;0&#x27; height=&#x27;100%25&#x27; width=&#x27;100%25&#x27; href=&#x27;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAALUlEQVR4nGNoaaz4/OEZEL16dochPjr0+qUzxw/v3bhmKQMvOwgpyUlqqysDAM/qEn/iqPNTAAAAAElFTkSuQmCC&#x27;/%3E%3C/svg%3E&quot;)" src="/blog/images/network/tcp_congestion_control.webp"/></a></span><figcaption role="figcaption">tcp_congestion_control</figcaption></figure>
<p>
初始状态为 A，sshresh 为一阈值</p>
<p><strong>慢启动</strong>指：TCP 连接起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。限制了一个 TCP 端点在任意时刻可以传输的分组数。</p>
<p>如果 TCP 发送了大量包含少量数据的分组(发送端傻窗口综合症)，网络的性能会严重下降。<a rel="noopener noreferrer external nofollow" target="_blank" href="https://blog.csdn.net/wdscq1234/article/details/52432095">Nagle 算法</a>通过在发送一个分组之前，将大量 TCP 数据绑定在一起的方式来提高网络效率。其鼓励发送全尺寸的段，只有全尺寸的被确认后才允许发送非全尺寸的。只有当段被确认，或者缓存中积累了足够发送一个全尺寸段的数据时，才会将缓存的数据发送出去。(有时会有性能问题，可以通过 TCP_NODELAY 来禁用)</p></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"matter":{"date":"2018-01-25","title":"第三章","tags":["network"],"index":3},"absPath":"/home/runner/work/blog/blog/renderer/mdx/network/third.mdx","type":"mdx","slug":["third"],"collection":"network","url":"/network/third"},"compiled":{"content":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst date = \"2018-01-25\", title = \"第三章\", tags = [\"network\"], index = 3;\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    strong: \"strong\",\n    h3: \"h3\",\n    a: \"a\",\n    svg: \"svg\",\n    path: \"path\",\n    img: \"img\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    h4: \"h4\"\n  }, props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.p, {\n      children: [\"网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信。因此\", _jsx(_components.strong, {\n        children: \"运输层协议只工作在端系统上，路由器只处理到网络层\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"将主机间交付扩展到进程间交付被称为\", _jsx(_components.strong, {\n        children: \"运输层的多路复用(transprot-layer multiplexing)\"\n      }), \"，将数据块封装上首部信息生成报文段并传递到网络层；\", _jsx(_components.strong, {\n        children: \"多路分解(demultiplexing)\"\n      }), \"，将将运输层报文段的数据交付到正确的套接字\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"**数据报拥塞控制协议(Datagram Congestion Control Protocol, DCCP)**实现了面向报文、控制拥塞的类似 UDP 不可靠服务\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"udp\",\n      children: [\"UDP\", _jsx(_components.a, {\n        className: \"anchor after\",\n        \"aria-hidden\": true,\n        \"aria-label\": \"permalink\",\n        tabIndex: \"-1\",\n        href: \"#udp\",\n        children: _jsx(_components.svg, {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 16 16\",\n          focusable: \"false\",\n          children: _jsx(_components.path, {\n            d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\",\n            fillRule: \"evenodd\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除了复用/分解功能及少量的差错检测外，UDP 几乎没有对 ip 增加别的东西。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DNS 协议运行在 UDP 之上\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UDP 可以实现可靠传输的，但是在应用层实现。如 Chrome 的 QUIC(快速 UDP 因特网连接)\\n\"\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/images/network/udp_message.webp\",\n      alt: \"udp_message\",\n      width: \"445\",\n      height: \"474\",\n      sizes: \"(max-width: 445px) 100vw, 474px\",\n      blurDataURL: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAO0lEQVR4nGP49evX5cvn1q9b3lxfxmBrZ+Ph4S4kyC0mxMHg7Oxgaqyvp6dpbqLLkJWZAkR5uZmZGUkALjoSKkizynoAAAAASUVORK5CYII=\",\n      placeholder: \"blur\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\nUDP 首部只有 4 个字段，共 64bit, 8 字节\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"长度字段指明 UDP 报文段的总字节数(首部+数据)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"检验和为 UDP 提供差错检测功能\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"UDP 协议里，应用程序的客户端让运输层自动的(且透明的)分配端口号，而服务端分配特定的端口号，不同源地址或不同源端口都没有关系，只要目标端口、目标主机地址相同，都会被分配到同一套接字\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"可靠数据传输原理\",\n      children: [\"可靠数据传输原理\", _jsx(_components.a, {\n        className: \"anchor after\",\n        \"aria-hidden\": true,\n        \"aria-label\": \"permalink\",\n        tabIndex: \"-1\",\n        href: \"#可靠数据传输原理\",\n        children: _jsx(_components.svg, {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 16 16\",\n          focusable: \"false\",\n          children: _jsx(_components.path, {\n            d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\",\n            fillRule: \"evenodd\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"比较复杂，笔记没用。看书！！！\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/images/network/reliable_data_transmission_mechanism\u0026its_use.webp\",\n      alt: \"reliable_data_transmission_mechanism\u0026its_use\",\n      width: \"621\",\n      height: \"301\",\n      sizes: \"(max-width: 621px) 100vw, 301px\",\n      blurDataURL: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAACCAIAAADwyuo0AAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAIklEQVR4nGOwNdEM8nEvKix49ew5g5QQk5yUqAgfV2xEOABpjQc97pU92AAAAABJRU5ErkJggg==\",\n      placeholder: \"blur\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"tcp\",\n      children: [\"TCP\", _jsx(_components.a, {\n        className: \"anchor after\",\n        \"aria-hidden\": true,\n        \"aria-label\": \"permalink\",\n        tabIndex: \"-1\",\n        href: \"#tcp\",\n        children: _jsx(_components.svg, {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 16 16\",\n          focusable: \"false\",\n          children: _jsx(_components.path, {\n            d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\",\n            fillRule: \"evenodd\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TCP 是面向连接、全双工、点对点的协议\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"TCP 报文段的长度受限于\", _jsx(_components.strong, {\n        children: \"最大报文段长度(Maximum Segment Size, MSS)\"\n      }), \"，而 MSS 通常根据主机的**最大链路帧长度(AKA 最大传输单元 Maximum Transmission Unit, MTU)**来设置。如底层以太网协议和 PPP 链路层协议 MTU=1500 字节，MSS 典型值就是 1460 字节(加首部 40 字节，共 1500)。\\n\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/images/network/tcp_message.webp\",\n      alt: \"tcp_message\",\n      width: \"467\",\n      height: \"478\",\n      sizes: \"(max-width: 467px) 100vw, 478px\",\n      blurDataURL: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAIAAAAmkwkpAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAOklEQVR4nGP49fsbEO3cvikp2puhsDCvpbWpqDBHSVqIIT42srK8qLGuVlyQjaGzvQnImTp5UoCPOwC1Xxcs97dJzAAAAABJRU5ErkJggg==\",\n      placeholder: \"blur\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\nTCP 首部共有 20 字节，但可变\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"序号和确认号用来实现可靠数据传输(各 32bit)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"接收窗口字段指示接收方愿意接收的字节数(16bit)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"首部长度字段指示以 32bit 为单位的 TCP 首部长度(4bit)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"选项字段用于协调窗口调节(可选+变长)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"标志字段用于控制 TCP 状态，如 ACK, FIN(6bit)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"TCP 链接通过 \", _jsx(_components.code, {\n        children: \"\u003c源 IP 地址、 源端口号、 目的 IP 地址、 目的端口号\u003e\"\n      }), \" 组来唯一标识每条连接。如 web 服务器，虽然所有客户端的目标 IP 和目标端口相同，但是源 IP 地址或源端口都不相同，则服务器上限会远远大于服务器端口数量（在 linux 上，每个链接都是以一个文件形式标识，则最大并发数受限于内存大小）\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"TCP 是\", _jsx(_components.strong, {\n        children: \"有序\"\n      }), \"传输的，对于失序的报文段会整理成序再发给应用层\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TCP 的初始序号可以随机选择，以减少将仍在网络上的旧连接的报文段，误认为是新连接的报文段的可能性(防止和旧连接使用同一端口)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"TCP 在收到三次\", _jsx(_components.strong, {\n        children: \"冗余 ACK\"\n      }), \"（同一 ACK 回复）时，会触发\", _jsx(_components.strong, {\n        children: \"快速重传(fast retransmit)\"\n      }), \"，即在该报文段的定时器过期之前就重传\\n\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/images/network/fast_retransmission.webp\",\n      alt: \"fast_retransmission\",\n      width: \"541\",\n      height: \"791\",\n      sizes: \"(max-width: 541px) 100vw, 791px\",\n      blurDataURL: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAECAIAAADETxJQAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAALUlEQVR4nGOwsbLct3fHtw+vGEJD/NmYGXZuWcegpaHu4mQHYkmICwPFjPU1ATxnDP27RqP1AAAAAElFTkSuQmCC\",\n      placeholder: \"blur\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"\\nTCP 提供\", _jsx(_components.strong, {\n        children: \"流量控制服务(flow-control service)\"\n      }), \"，以消除发送端使得接收端缓存溢出的可能。发送端需要控制\", _jsx(_components.code, {\n        children: \"LastByteSent - LastByteAcked ≤ rwnd\"\n      }), \"，其中，rwnd 是首部的接收窗口字段，rwnd=RcvBuffer - [LastByteRcvd - LastByteRead]。在 rwnd 为 0 时，发送端会一直发送只有一字节数据的报文段，直到返回非 0 的 rwnd 值。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"TCP 通过三次握手，四次挥手工作。SYN 洪泛攻击可以通过设置 SYN cookie 来防御\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当关闭 TCP 连接时，会通过一个控制块记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍(称为 2MSL)，以确保链接重用。\"\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"拥塞控制congestion-control\",\n      children: [\"拥塞控制(congestion control)\", _jsx(_components.a, {\n        className: \"anchor after\",\n        \"aria-hidden\": true,\n        \"aria-label\": \"permalink\",\n        tabIndex: \"-1\",\n        href: \"#拥塞控制congestion-control\",\n        children: _jsx(_components.svg, {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 16 16\",\n          focusable: \"false\",\n          children: _jsx(_components.path, {\n            d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\",\n            fillRule: \"evenodd\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"用于减少网络环境对连接的影响(如突然过载或拥塞)。即\", _jsx(_components.code, {\n        children: \"LastByteSent - LastByteAcked ≤ min{ rwnd, cwnd }\"\n      }), \"，其中，cwnd 代表拥塞窗口通过**TCP 拥塞控制算法(TCP comgestion control algorithm)**来控制：\\n\"]\n    }), \"\\n\", _jsx(_components.img, {\n      src: \"/images/network/tcp_congestion_control.webp\",\n      alt: \"tcp_congestion_control\",\n      width: \"679\",\n      height: \"589\",\n      sizes: \"(max-width: 679px) 100vw, 589px\",\n      blurDataURL: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAIAAAA7ljmRAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAALUlEQVR4nGNoaaz4/OEZEL16dochPjr0+qUzxw/v3bhmKQMvOwgpyUlqqysDAM/qEn/iqPNTAAAAAElFTkSuQmCC\",\n      placeholder: \"blur\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\n初始状态为 A，sshresh 为一阈值\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"慢启动\"\n      }), \"指：TCP 连接起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。限制了一个 TCP 端点在任意时刻可以传输的分组数。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果 TCP 发送了大量包含少量数据的分组(发送端傻窗口综合症)，网络的性能会严重下降。\", _jsx(_components.a, {\n        href: \"https://blog.csdn.net/wdscq1234/article/details/52432095\",\n        children: \"Nagle 算法\"\n      }), \"通过在发送一个分组之前，将大量 TCP 数据绑定在一起的方式来提高网络效率。其鼓励发送全尺寸的段，只有全尺寸的被确认后才允许发送非全尺寸的。只有当段被确认，或者缓存中积累了足够发送一个全尺寸段的数据时，才会将缓存的数据发送出去。(有时会有性能问题，可以通过 TCP_NODELAY 来禁用)\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  date,\n  title,\n  tags,\n  index,\n  default: MDXContent\n};\n","toc":[{"depth":3,"value":"UDP","id":"udp"},{"depth":3,"value":"可靠数据传输原理","id":"可靠数据传输原理"},{"depth":3,"value":"TCP","id":"tcp","children":[{"depth":4,"value":"拥塞控制(congestion control)","id":"拥塞控制congestion-control"}]}]},"overview":[{"length":20,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"}]},"__N_SSG":true},"page":"/[collection]/[...slug]","query":{"collection":"network","slug":["third"]},"buildId":"mzuzm50yGf6vkf53yEM99","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>