<!DOCTYPE html><html lang="cn"><head><meta charSet="UTF-8"/><title>Graphics Programming(九) —— 后期处理效果 | Graphics</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Graphics Programming(九) —— 后期处理效果 | Graphics"/><meta name="description" content="Personal Blog"/><meta property="og:description" content="Personal Blog"/><meta property="og:type" content="website"/><meta property="twitter:card" content="summary_large_image"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="9"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/26ec16ccb915de94.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/26ec16ccb915de94.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-6965b024cefed38b.js" defer=""></script><script src="/blog/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/blog/_next/static/chunks/main-9840a9e213eaa478.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-ae897f29056b30d9.js" defer=""></script><script src="/blog/_next/static/chunks/29107295-2a9ca7f07685bf37.js" defer=""></script><script src="/blog/_next/static/chunks/117b9d7f-1415b8d5c023097d.js" defer=""></script><script src="/blog/_next/static/chunks/664-d254d21a6fe56bff.js" defer=""></script><script src="/blog/_next/static/chunks/475-f757a87f3cd5d391.js" defer=""></script><script src="/blog/_next/static/chunks/675-1b37aa8aa6ad9102.js" defer=""></script><script src="/blog/_next/static/chunks/295-669440b57b4b1b5e.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bcollection%5D/%5B...slug%5D-7308aaad3bf994ab.js" defer=""></script><script src="/blog/_next/static/jl9uEbaJnm6vwogTMthqb/_buildManifest.js" defer=""></script><script src="/blog/_next/static/jl9uEbaJnm6vwogTMthqb/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header data-theme="dark" class="style_nav-root__jrAJR" style="height:80px"><section class="style_nav-section__sS_tB"><a class="style_nav-logo__jRYAT" href="/blog"><h3>Allen Lee@Blog</h3></a><nav aria-label="Main" data-orientation="horizontal" dir="ltr" class="style_nav-menus__4aQM9"><div style="position:relative"><ul data-orientation="horizontal" dir="ltr"><li><button class="style_btn__AkQj7 style_subtle__i70rQ style_nav-trigger__ekUye" id="radix-:Rj6:-trigger-radix-:Rjj6:" data-state="closed" aria-expanded="false" aria-controls="radix-:Rj6:-content-radix-:Rjj6:" data-radix-collection-item="">Overview <svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 15 15" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor"></path></svg></button></li></ul></div></nav></section></header><main data-theme="light" style="background-color:var(--colorNeutralBackground1);overflow-x:hidden;overflow-y:auto;width:100vw;height:calc(100vh - 80px)" id="main"><div class="collection_slug_Root__xztwf style_mainStyle__8eIxs"><div class="style_graphicsPost__36P1T"><h1><a href="#" title="undefined" class="style_titleStyle__6CuPY">Graphics Programming(九) —— 后期处理效果</a></h1><p>前置知识</p>
<div class="style_Tab__IjTlz">屏幕后期处理效果:<div class="style_Tab__IjTlz">屏幕后期处理(Screen Post-processing Effects): 指在渲染完整个场景后, 再对整个屏幕图像进行处理<br/>获取屏幕图像是在C#中的OnRenderImage函数中<br/>屏幕后期处理其实是在场景中绘制一个和屏幕同宽高的面片, 为防止对其它物体产生影响, 需要设置相关渲染状态.</div><div role="expansion" class="style_Expansion__lekPG">OnRenderImage</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">public void OnRenderImage(SenderTexture src, RenderTexture dest){<div class="style_Tab__IjTlz">将预处理的屏幕图像写入src, 经过处理后得到最终图像dest显示在屏幕上<br/>可以加入ImageEffectOpaque来更改渲染管道, 区分透明和不透明物体效果<br/>在该函数中又通常使用 Graphics.Blit 函数处理图像<br/>public static void Blit(Texture src, RenderTexture dest);<br/>public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);<br/>public static void Blit(Texture src, Material mat, int pass=-1);</div>}</div><br/></div>
<p></p>
<p>处理效果</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">边缘检测</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">边缘检测: 用以实现物体的描边效果<br/>产生卷积核(convolution kernel)来操作屏幕, 计算边缘<br/>边界: 如果相邻像素之间颜色亮度和纹理等属性有明显差别, 认为其之间有边界. 并用梯度G表示这种差异性<br/>使用<span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R116pl6:" data-state="closed">边缘检测算子</span>对每个像素进行卷积, 得到两个方向的梯度Gx和Gy, 并得到G = |Gx|+|Gy|, 较大时可能是边缘点</div><br/><div role="expansion" class="style_Expansion__lekPG">模糊处理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">模糊: 实现类似于景深或毛玻璃的效果<br/>常见有: 均值模糊(卷积核各元素相等且相加等于一), 中值模糊(对邻近区域像素排序取中值), 以及<div role="expansion" class="style_Expansion__lekPG">高斯模糊</div><div class="style_Tab__IjTlz style_hidden__yfyDi">使用名为&quot;高斯核&quot;的卷积核, 是一种正方形的滤波核, 每个元素都基于<span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R9lcpl6:" data-state="closed">高斯方程</span>计算<br/>高斯核的维数越高模糊程度越大, 使用NxN维高斯核需要进行NxNxWxH次纹理采样<br/>需要<span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R11lcpl6:" data-state="closed">将其拆分</span>, 缩减计算量</div><br/></div><br/><div role="expansion" class="style_Expansion__lekPG">Bloom</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">Bloom: 模拟光线照在物体表面的散射效果<br/>实现简单, 只需要提取图片的光线较强的像素, 并高斯模糊该像素周围, 之后和原图混合</div><br/><div role="expansion" class="style_Expansion__lekPG">运动模糊</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">计算机图形缺少曝光现象, 需要特殊实现<br/>其实现有多种方式: 积累缓存(accumulation buffer)和速度缓存(velocity buffer)<br/>积累缓存混合连续图像进行叠加模糊. 效果好, 但是消耗大<br/>速度缓存存储像素当前速度, 利用速度值决定模糊方向及大小</div><br/><div role="expansion" class="style_Expansion__lekPG">雾化效果</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">雾效(Fog): 需要根据深度纹理来重建每个像素在世界空间中的坐标.<br/>使用快速深度重建技术, 将首先对<span class="style_Quote__dLoMM" id="#2">视锥体射线</span>进行插值, 用该射线*处理后的深度值+摄像机坐标 = 该像素在世界空间的坐标<br/>该技术基于坐标可以通过对另一坐标的偏移来求取的思想: worldPos = _WorldSpaceCameraPos + <span class="style_Quote__dLoMM" id="#3">linearDepth * interpolatedRay</span><br/>雾效实现需要一个系数f, 来作为颜色和雾的混合系数. 在unity内置中, 有三种: 线性, 指数, 指数平方<br/>若要雾效移动和深浅不一, 还需要噪声纹理</div><br/></div>
<p></p>
<span class="style_Quote__dLoMM" id="#1">不止于此</span>
<p>:</p><div id="Comment" class="style_Comment__GsBhh"></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"matter":{"title":"Graphics Programming(九) —— 后期处理效果","tags":["graphics"],"index":9},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/post-processing.mdx","type":"mdx","slug":["post-processing"],"collection":"graphics","url":"/graphics/post-processing"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(九) —— 后期处理效果\",\n  \"tags\": [\"graphics\"],\n  \"index\": 9\n};\nconst QuoteList = [\"参考: https://docs.unity3d.com/Manual/compImageEffects.html\u003cbr/\u003eGPU GAME系列: https://developer.nvidia.com/gpugames/GPUGames\", \"视锥体射线: 从摄像机指向图像的某一点. 存储了该像素在世界空间下到摄像机的方向\", \"linearDepth是深度纹理得到的线性深度值, interpolatedRay是后期处理平面四个角到摄像机的距离方向值\"];\nconst ImgList = [\"常见边缘检测算子\", \"高斯方程\", \"高斯核的简化\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  }, {Expansion, Model, Quote, Tab} = _components;\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Model) _missingMdxReference(\"Model\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"前置知识\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"屏幕后期处理效果:\", _jsxs(Tab, {\n        children: [\"屏幕后期处理(Screen Post-processing Effects): 指在渲染完整个场景后, 再对整个屏幕图像进行处理\", _jsx(\"br\", {}), \"获取屏幕图像是在C#中的OnRenderImage函数中\", _jsx(\"br\", {}), \"屏幕后期处理其实是在场景中绘制一个和屏幕同宽高的面片, 为防止对其它物体产生影响, 需要设置相关渲染状态.\"]\n      }), _jsx(Expansion, {\n        children: \"OnRenderImage\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"public void OnRenderImage(SenderTexture src, RenderTexture dest){\", _jsxs(Tab, {\n          children: [\"将预处理的屏幕图像写入src, 经过处理后得到最终图像dest显示在屏幕上\", _jsx(\"br\", {}), \"可以加入ImageEffectOpaque来更改渲染管道, 区分透明和不透明物体效果\", _jsx(\"br\", {}), \"在该函数中又通常使用 Graphics.Blit 函数处理图像\", _jsx(\"br\", {}), \"public static void Blit(Texture src, RenderTexture dest);\", _jsx(\"br\", {}), \"public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\", _jsx(\"br\", {}), \"public static void Blit(Texture src, Material mat, int pass=-1);\"]\n        }), \"}\"]\n      })]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"处理效果\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"边缘检测\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"边缘检测: 用以实现物体的描边效果\", _jsx(\"br\", {}), \"产生卷积核(convolution kernel)来操作屏幕, 计算边缘\", _jsx(\"br\", {}), \"边界: 如果相邻像素之间颜色亮度和纹理等属性有明显差别, 认为其之间有边界. 并用梯度G表示这种差异性\", _jsx(\"br\", {}), \"使用\", _jsx(Model, {\n          about: \"@1\",\n          children: \"边缘检测算子\"\n        }), \"对每个像素进行卷积, 得到两个方向的梯度Gx和Gy, 并得到G = |Gx|+|Gy|, 较大时可能是边缘点\"]\n      }), _jsx(Expansion, {\n        children: \"模糊处理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"模糊: 实现类似于景深或毛玻璃的效果\", _jsx(\"br\", {}), \"常见有: 均值模糊(卷积核各元素相等且相加等于一), 中值模糊(对邻近区域像素排序取中值), 以及\", _jsx(Expansion, {\n          children: \"高斯模糊\"\n        }), _jsxs(Tab, {\n          expan: true,\n          children: [\"使用名为\\\"高斯核\\\"的卷积核, 是一种正方形的滤波核, 每个元素都基于\", _jsx(Model, {\n            about: \"@2\",\n            children: \"高斯方程\"\n          }), \"计算\", _jsx(\"br\", {}), \"高斯核的维数越高模糊程度越大, 使用NxN维高斯核需要进行NxNxWxH次纹理采样\", _jsx(\"br\", {}), \"需要\", _jsx(Model, {\n            about: \"@3\",\n            children: \"将其拆分\"\n          }), \", 缩减计算量\"]\n        })]\n      }), _jsx(Expansion, {\n        children: \"Bloom\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"Bloom: 模拟光线照在物体表面的散射效果\", _jsx(\"br\", {}), \"实现简单, 只需要提取图片的光线较强的像素, 并高斯模糊该像素周围, 之后和原图混合\"]\n      }), _jsx(Expansion, {\n        children: \"运动模糊\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"计算机图形缺少曝光现象, 需要特殊实现\", _jsx(\"br\", {}), \"其实现有多种方式: 积累缓存(accumulation buffer)和速度缓存(velocity buffer)\", _jsx(\"br\", {}), \"积累缓存混合连续图像进行叠加模糊. 效果好, 但是消耗大\", _jsx(\"br\", {}), \"速度缓存存储像素当前速度, 利用速度值决定模糊方向及大小\"]\n      }), _jsx(Expansion, {\n        children: \"雾化效果\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"雾效(Fog): 需要根据深度纹理来重建每个像素在世界空间中的坐标.\", _jsx(\"br\", {}), \"使用快速深度重建技术, 将首先对\", _jsx(Quote, {\n          id: \"#2\",\n          children: \"视锥体射线\"\n        }), \"进行插值, 用该射线*处理后的深度值+摄像机坐标 = 该像素在世界空间的坐标\", _jsx(\"br\", {}), \"该技术基于坐标可以通过对另一坐标的偏移来求取的思想: worldPos = _WorldSpaceCameraPos + \", _jsx(Quote, {\n          className: \"Quote\",\n          id: \"#3\",\n          children: \"linearDepth * interpolatedRay\"\n        }), _jsx(\"br\", {}), \"雾效实现需要一个系数f, 来作为颜色和雾的混合系数. 在unity内置中, 有三种: 线性, 指数, 指数平方\", _jsx(\"br\", {}), \"若要雾效移动和深浅不一, 还需要噪声纹理\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {}), \"\\n\", _jsx(Quote, {\n      id: \"#1\",\n      children: \"不止于此\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \":\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  ImgList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"}]},"__N_SSG":true},"page":"/[collection]/[...slug]","query":{"collection":"graphics","slug":["post-processing"]},"buildId":"jl9uEbaJnm6vwogTMthqb","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>