{"pageProps":{"post":{"matter":{"title":"Graphics Programming(九) —— 后期处理效果","tags":["graphics"],"index":9},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/post-processing.mdx","type":"mdx","slug":["post-processing"],"collection":"graphics","url":"/graphics/post-processing"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(九) —— 后期处理效果\",\n  \"tags\": [\"graphics\"],\n  \"index\": 9\n};\nconst QuoteList = [\"参考: https://docs.unity3d.com/Manual/compImageEffects.html<br/>GPU GAME系列: https://developer.nvidia.com/gpugames/GPUGames\", \"视锥体射线: 从摄像机指向图像的某一点. 存储了该像素在世界空间下到摄像机的方向\", \"linearDepth是深度纹理得到的线性深度值, interpolatedRay是后期处理平面四个角到摄像机的距离方向值\"];\nconst ImgList = [\"常见边缘检测算子\", \"高斯方程\", \"高斯核的简化\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  }, {Expansion, Model, Quote, Tab} = _components;\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Model) _missingMdxReference(\"Model\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"前置知识\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"屏幕后期处理效果:\", _jsxs(Tab, {\n        children: [\"屏幕后期处理(Screen Post-processing Effects): 指在渲染完整个场景后, 再对整个屏幕图像进行处理\", _jsx(\"br\", {}), \"获取屏幕图像是在C#中的OnRenderImage函数中\", _jsx(\"br\", {}), \"屏幕后期处理其实是在场景中绘制一个和屏幕同宽高的面片, 为防止对其它物体产生影响, 需要设置相关渲染状态.\"]\n      }), _jsx(Expansion, {\n        children: \"OnRenderImage\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"public void OnRenderImage(SenderTexture src, RenderTexture dest){\", _jsxs(Tab, {\n          children: [\"将预处理的屏幕图像写入src, 经过处理后得到最终图像dest显示在屏幕上\", _jsx(\"br\", {}), \"可以加入ImageEffectOpaque来更改渲染管道, 区分透明和不透明物体效果\", _jsx(\"br\", {}), \"在该函数中又通常使用 Graphics.Blit 函数处理图像\", _jsx(\"br\", {}), \"public static void Blit(Texture src, RenderTexture dest);\", _jsx(\"br\", {}), \"public static void Blit(Texture src, RenderTexture dest, Material mat, int pass=-1);\", _jsx(\"br\", {}), \"public static void Blit(Texture src, Material mat, int pass=-1);\"]\n        }), \"}\"]\n      })]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"处理效果\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"边缘检测\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"边缘检测: 用以实现物体的描边效果\", _jsx(\"br\", {}), \"产生卷积核(convolution kernel)来操作屏幕, 计算边缘\", _jsx(\"br\", {}), \"边界: 如果相邻像素之间颜色亮度和纹理等属性有明显差别, 认为其之间有边界. 并用梯度G表示这种差异性\", _jsx(\"br\", {}), \"使用\", _jsx(Model, {\n          about: \"@1\",\n          children: \"边缘检测算子\"\n        }), \"对每个像素进行卷积, 得到两个方向的梯度Gx和Gy, 并得到G = |Gx|+|Gy|, 较大时可能是边缘点\"]\n      }), _jsx(Expansion, {\n        children: \"模糊处理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"模糊: 实现类似于景深或毛玻璃的效果\", _jsx(\"br\", {}), \"常见有: 均值模糊(卷积核各元素相等且相加等于一), 中值模糊(对邻近区域像素排序取中值), 以及\", _jsx(Expansion, {\n          children: \"高斯模糊\"\n        }), _jsxs(Tab, {\n          expan: true,\n          children: [\"使用名为\\\"高斯核\\\"的卷积核, 是一种正方形的滤波核, 每个元素都基于\", _jsx(Model, {\n            about: \"@2\",\n            children: \"高斯方程\"\n          }), \"计算\", _jsx(\"br\", {}), \"高斯核的维数越高模糊程度越大, 使用NxN维高斯核需要进行NxNxWxH次纹理采样\", _jsx(\"br\", {}), \"需要\", _jsx(Model, {\n            about: \"@3\",\n            children: \"将其拆分\"\n          }), \", 缩减计算量\"]\n        })]\n      }), _jsx(Expansion, {\n        children: \"Bloom\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"Bloom: 模拟光线照在物体表面的散射效果\", _jsx(\"br\", {}), \"实现简单, 只需要提取图片的光线较强的像素, 并高斯模糊该像素周围, 之后和原图混合\"]\n      }), _jsx(Expansion, {\n        children: \"运动模糊\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"计算机图形缺少曝光现象, 需要特殊实现\", _jsx(\"br\", {}), \"其实现有多种方式: 积累缓存(accumulation buffer)和速度缓存(velocity buffer)\", _jsx(\"br\", {}), \"积累缓存混合连续图像进行叠加模糊. 效果好, 但是消耗大\", _jsx(\"br\", {}), \"速度缓存存储像素当前速度, 利用速度值决定模糊方向及大小\"]\n      }), _jsx(Expansion, {\n        children: \"雾化效果\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"雾效(Fog): 需要根据深度纹理来重建每个像素在世界空间中的坐标.\", _jsx(\"br\", {}), \"使用快速深度重建技术, 将首先对\", _jsx(Quote, {\n          id: \"#2\",\n          children: \"视锥体射线\"\n        }), \"进行插值, 用该射线*处理后的深度值+摄像机坐标 = 该像素在世界空间的坐标\", _jsx(\"br\", {}), \"该技术基于坐标可以通过对另一坐标的偏移来求取的思想: worldPos = _WorldSpaceCameraPos + \", _jsx(Quote, {\n          className: \"Quote\",\n          id: \"#3\",\n          children: \"linearDepth * interpolatedRay\"\n        }), _jsx(\"br\", {}), \"雾效实现需要一个系数f, 来作为颜色和雾的混合系数. 在unity内置中, 有三种: 线性, 指数, 指数平方\", _jsx(\"br\", {}), \"若要雾效移动和深浅不一, 还需要噪声纹理\"]\n      })]\n    }), \"\\n\", _jsx(_components.p, {}), \"\\n\", _jsx(Quote, {\n      id: \"#1\",\n      children: \"不止于此\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \":\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  ImgList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"},{"name":"practice","length":1}]},"__N_SSG":true}