{"pageProps":{"post":{"matter":{"title":"Graphics Programming(五) —— 光照","tags":["graphics"],"index":5},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/illumination.mdx","type":"mdx","slug":["illumination"],"collection":"graphics","url":"/graphics/illumination"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(五) —— 光照\",\n  \"tags\": [\"graphics\"],\n  \"index\": 5\n};\nconst QuoteList = [\"这个等式也被称为光照模型(Lighting Model)\", \"间接光照(indirect light): 进入摄像机的光照之前经过了不止一次的反射\", \"如果没有使用全局光照技术(global illumination), 自发光并不会作为一个光源照射物体, 只是使得自身亮度提高\", \"亦称位Blinn-Phong模型. 是一种各向同性的模型, 无法实现菲涅尔反射(Fresnel reflection)\", \"场景中最亮的平行光一定是按逐像素处理(且在Base中处理)<br/>渲染模式设置为\\\"Not Important\\\"的按逐顶点或SH<br/>渲染模式设置为\\\"Important\\\"的按逐像素处理<br/>若以上规则小于Quality Setting中的Pixel Light Count, 则更多光源按逐像素\", \"G-buffer(Geometry-buffer)存储了表面法线, 位置, 用于光照计算的材质属性等\", \"其它光照参考: https://docs.unity3d.com/Manual/RenderTech-DefferedShadering.html\", \"参考: https://docs.unity3d.com/Manual/RenderingPath.html\", \"unity为简化计算会使用_LightTexture0(cookie后, 为_LightTextureB0)计算衰减, 但不够精确. 因此通常使用数学计算和衰减纹理来共同计算\", \"可以将Fallback设置为VertexLit或Diffuse等不透明物体的shader. 虽然可以接收和投射阴影, 但效果和不透明物体一样\"];\nconst ImgList = [\"Blinn-Phong光照模型\", \"halfLambert\", \"前向渲染的两种Pass\", \"常用内置光照变量\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  }, {Aphorism, Expansion, Model, Quote, Tab, Table} = _components;\n  if (!Aphorism) _missingMdxReference(\"Aphorism\", true);\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Model) _missingMdxReference(\"Model\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  if (!Table) _missingMdxReference(\"Table\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"计算机图形学第一定律:\"\n    }), \"\\n\", _jsx(_components.p, {}), \"\\n\", _jsx(Aphorism, {\n      children: \"如果它看起来是对的, 那么它就是对的\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\n光照基础\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"光源\"\n      }), \": 发出光线\", _jsxs(Tab, {\n        expan: true,\n        children: [\"表示: 一个点, 用 l 表示其方向\", _jsx(\"br\", {}), \"\\n拥有五个关键因素: 位置, 方向, 颜色, 强度及\", _jsx(Quote, {\n          id: \"#9\",\n          children: \"衰减\"\n        }), _jsx(\"br\", {}), \"\\nunity分为\", _jsx(Expansion, {\n          children: \"平行光, 点光源, 聚光灯\"\n        }), \"\\n和面光源(只在烘焙时起作用)\", _jsxs(Tab, {\n          expan: true,\n          children: [\"平行光: 只有方向属性, 到场景中所有点的方向相同, 光强不会因距离而衰减\", _jsx(\"br\", {}), \"\\n点光源: 有位置属性(方向靠算), 照亮空间为四周呈球形, 光强因距离远近而衰减\", _jsx(\"br\", {}), \"\\n聚光灯: 有位置属性(方向靠算), 照亮空间为锥形, 光强因距离远近而衰减\"]\n        })]\n      }), _jsx(Expansion, {\n        children: \"吸收和散射\"\n      }), \": 光线与物体相交时, 一部分吸收一部分散射\", _jsxs(Tab, {\n        expan: true,\n        children: [\"散射(scattering): 改变光线方向, 但不改变其性质.\", _jsxs(Tab, {\n          children: [\"若散射到物体内部, 称为折射(refraction)或透射(transmission)\", _jsx(\"br\", {}), \"\\n若散射到物体外表面, 称为反射(reflection)\"]\n        }), \"吸收(absorption): 吸收改变性质, 但不改变方向.\", _jsx(\"br\", {}), \"\\n计量: 出射度(exitance) = β辐射度, β值由材质的漫反射和高光反射来部分决定\"]\n      }), _jsx(Expansion, {\n        children: \"着色\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"严格的讲(物理): 物体反射特定颜色的光, 该光被接收而感受到颜色\", _jsx(\"br\", {}), \"\\n定义(图形学): 着色(shading)指根据材质信息,\\n光源信息来计算沿某个观察方向出射度的\", _jsx(Quote, {\n          id: \"#1\",\n          children: \"一个等式\"\n        }), _jsx(\"br\", {}), \"\\n分为各向同性和各向异性光\", _jsxs(Tab, {\n          children: [\"各向同性(isotropic): 参数不变时, 旋转物体反射光不产生变化\", _jsx(\"br\", {}), \"\\n各向异性(anisotropic): 参数不变时 ,旋转物体反射光产生变化\"]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"光照模型\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"光照计算位置\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"逐顶点(per-vertex lighting): 在顶点着色器中计算\", _jsxs(Tab, {\n          children: [\"得到法线数据, 然后进行插值计算. 称为Gouraud着色\", _jsx(\"br\", {}), \"每个顶点计算光照, 会在渲染图元内部进行线性插值, 使得图片\\\"棱角分明\\\",\\n且容易出错\"]\n        }), \"逐像素(per-pixel lighting): 在片元着色器中计算\\n\", _jsx(Tab, {\n          children: \"得到法线数据, 然后进行插值计算. 称为Phong着色\"\n        })]\n      }), _jsx(Expansion, {\n        children: \"渲染路径\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"渲染路径(Rendering Path): 决定光照如何运用到shader中\", _jsx(\"br\", {}), \"不同渲染路径, shader可以访问的内置变量及函数也不同\", _jsx(Table, {\n          title: \"LightMode的渲染路径选项\",\n          children: [{\n            cells: [\"Always\", \"该Pass总会被渲染, 但不计算任何光照\"]\n          }, {\n            cells: [\"ForwardBase\", \"前向渲染. (计算环境光, 关键平行光, 逐顶点/SH光源和Lightmaps)\"]\n          }, {\n            cells: [\"ForwardAdd\", \"前向渲染. (计算额外的逐像素光源, 每个Pass对应一个光源)\"]\n          }, {\n            cells: [\"Deferred\", \"延迟渲染. (会渲染G-buffer)\"]\n          }, {\n            cells: [\"ShadowCaster\", \"把物体的深度信息渲染到阴影映射纹理(shadowmap)或深度纹理中\"]\n          }]\n        }), _jsx(Expansion, {\n          children: \"前向渲染(Forward)\"\n        }), _jsxs(Tab, {\n          expan: true,\n          children: [\"该路径指明: 对每个逐像素光源来说, 其中受影响的每个图元,\\n必需经过\\\"深度缓冲区\\\"和\\\"颜色缓冲区\\\"\", _jsx(\"br\", {}), \"有三种处理光照的方式: 逐顶点处理, 逐像素处理, 球谐函数(Spherical\\nHarmonics,SH)处理\", _jsx(\"br\", {}), \"对于场景中所有光源, unity会按\", _jsx(Quote, {\n            id: \"#5\",\n            children: \"一定规则\"\n          }), \":\\n指定一定数目的逐像素光源; 最多4个逐顶点; 剩下的按SH处理\", _jsx(\"br\", {}), \"其Pass被分为\", _jsx(Model, {\n            about: \"@3\",\n            children: \"Base和Add\"\n          }), \"两种\", _jsx(\"br\", {}), \"当场景包含大量实时光源时, 前向渲染速度会急速下降\"]\n        }), _jsx(Expansion, {\n          children: \"延迟渲染\"\n        }), _jsxs(Tab, {\n          expan: true,\n          children: [\"除\\\"深度缓冲区\\\"和颜色缓冲区外, 延迟渲染将访问\\n\", _jsx(Quote, {\n            id: \"#6\",\n            children: \"G-buffer\"\n          }), \", 包含两个Pass\", _jsx(\"br\", {}), \"第一个Pass不进行光照计算, 仅仅决定片元的可见性(可见信息存储于G-buffer),\\n每个物体只执行一次\", _jsx(\"br\", {}), \"第二个利用G-buffer计算光照,\", \" \", \"\\n\", _jsx(Quote, {\n            id: \"#7\",\n            children: \"且仅能使用Standard光照模型\"\n          }), _jsx(\"br\", {}), \"其不依赖于场景复杂度, 只和使用的屏幕空间大小有关\", _jsx(\"br\", {}), \"延迟渲染不能使用抗锯齿和处理半透明\"]\n        }), _jsx(Quote, {\n          id: \"#8\",\n          children: \"选用何种路径?\"\n        }), _jsx(\"br\", {}), \"附录: \", _jsx(Model, {\n          about: \"@4\",\n          children: \"常用内置光照变量\"\n        })]\n      }), _jsx(Quote, {\n        className: \"Quote\",\n        id: \"#4\",\n        children: \"标准光照模型\"\n      }), \":\", _jsxs(Tab, {\n        children: [\"标准光照模型只关心光照(direct light). 即直接从光源发射照射到物体后,\\n经过一次反射直接进入摄像机\", _jsx(\"br\", {}), \"基本方法: 计算\", _jsx(Expansion, {\n          children: \"自发光, 高光反射, 漫反射和环境光\"\n        }), \"的\\n\", _jsx(Model, {\n          about: \"@1\",\n          children: \"贡献度\"\n        }), \", 最后得出SCORE\", _jsxs(Tab, {\n          expan: true,\n          children: [\"环境光(ambient): 用以模拟\", _jsx(Quote, {\n            id: \"#2\",\n            children: \"间接光照\"\n          }), \"对物体的影响\", _jsx(\"br\", {}), _jsx(Quote, {\n            id: \"#3\",\n            children: \"自发光(emissive)\"\n          }), \":\\n直接由光源不经过任何反射进入摄像机\", _jsx(\"br\", {}), _jsx(Expansion, {\n            children: \"漫反射(diffuse)\"\n          }), \":\\n用于对被物体表面随机散射到各方向的辐射度进行建模\", _jsxs(Tab, {\n            expan: true,\n            children: [\"视角的位置是不重要的,\\n因为反射是完全随机的(近乎于每个方向都是一样的分布); 但入射光线十分重要\", _jsx(\"br\", {}), \"符合兰伯特定理(Lambert's law):\\n反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比\", _jsx(\"br\", {}), \"也有\", _jsx(Model, {\n              about: \"@2\",\n              children: \"半兰伯特模型\"\n            }), \": 只是为了增强视觉效果,\\n没有物理依据\"]\n          }), _jsx(Expansion, {\n            children: \"高光反射(specular)\"\n          }), \":\\n计算沿着完全镜面反射方向反射的光线\", _jsxs(Tab, {\n            expan: true,\n            children: [\"一种经验模型\", _jsx(\"br\", {}), \"计算时需要知道: 表面法线, 视角方向, 光源方向, 反射方向等单位矢量\", _jsx(\"br\", {}), \"有两种模型: Phong模型和Blinn模型\"]\n          })]\n        })]\n      }), \"BRDF光照模型(Bidirectional Reflectance Distribution Function)\", _jsxs(Tab, {\n        children: [\"BRDF是对真实环境理想化和简化后的模型, 并不能真正的反映物体和光线的交互,\\n被称为经验模型.\", _jsx(\"br\", {}), \"当给定模型表面上一点时, BRDF给出其外观的完整描述\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  ImgList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"}]},"__N_SSG":true}