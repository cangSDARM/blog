<!DOCTYPE html><html lang="cn"><head><meta charSet="UTF-8"/><title>Graphics Programming(六) —— 纹理 | Graphics</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Graphics Programming(六) —— 纹理 | Graphics"/><meta name="description" content="Personal Blog"/><meta property="og:description" content="Personal Blog"/><meta property="og:type" content="website"/><meta property="twitter:card" content="summary_large_image"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="9"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog/_next/static/css/660e458111ee01f4.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/660e458111ee01f4.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/866d038d1ebd987d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/866d038d1ebd987d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-6965b024cefed38b.js" defer=""></script><script src="/blog/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/blog/_next/static/chunks/main-c4ae4cd412b87996.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-ae897f29056b30d9.js" defer=""></script><script src="/blog/_next/static/chunks/29107295-2a9ca7f07685bf37.js" defer=""></script><script src="/blog/_next/static/chunks/117b9d7f-c05aadfcc1af22be.js" defer=""></script><script src="/blog/_next/static/chunks/664-d254d21a6fe56bff.js" defer=""></script><script src="/blog/_next/static/chunks/712-0ac9ab5907aab179.js" defer=""></script><script src="/blog/_next/static/chunks/675-d64d4792f164bc88.js" defer=""></script><script src="/blog/_next/static/chunks/819-0038ff0571d9d7c4.js" defer=""></script><script src="/blog/_next/static/chunks/35-7d389070bf4bfa72.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bcollection%5D/%5B...slug%5D-73cb049fd2992997.js" defer=""></script><script src="/blog/_next/static/D7x4DkC9fYkIpJlQ3dnHJ/_buildManifest.js" defer=""></script><script src="/blog/_next/static/D7x4DkC9fYkIpJlQ3dnHJ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header data-theme="dark" class="style_fluent-nav__g_gBy" style="height:80px"><section class="style_nav-section__sS_tB"><a class="style_nav-logo__jRYAT" href="/blog"><h3>Allen Lee@Collections</h3></a><nav aria-label="Main" data-orientation="horizontal" dir="ltr" class="style_nav-menus__4aQM9"><div style="position:relative"><ul data-orientation="horizontal" dir="ltr"><li><button class="style_btn__AkQj7 style_subtle__i70rQ style_nav-trigger__ekUye" id="radix-:Rj6:-trigger-overview" data-state="closed" aria-expanded="false" aria-controls="radix-:Rj6:-content-overview" data-radix-collection-item="">Overview <svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 15 15" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor"></path></svg></button></li></ul></div></nav></section></header><main data-theme="light" style="background-color:var(--colorNeutralBackground1);overflow-x:hidden;overflow-y:auto;width:100vw;height:calc(100vh - 80px)" id="main"><div class="collection_slug_Root__xztwf style_mainStyle__8eIxs"><div class="style_graphicsPost__36P1T"><h1><a href="#" title="undefined" class="style_titleStyle__6CuPY">Graphics Programming(六) —— 纹理</a></h1><div style="width:100%;text-align:center;margin:0.5rem auto"><span class="style_aphorism__ue0s6">纹理可以存储任何表面属性</span></div>
<p>预先准备</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">纹理属性</div><div class="style_Tab__IjTlz style_hidden__yfyDi"><span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R595l6:" data-state="closed">unity中调整</span><br/>Texture Type: 正确的纹理类型, 才能正确的传递纹理且unity能尽量正确的优化<br/>Alpha Source: Alpha通道的来源.(none: 没有alpha通道, Input Texture Alpha: alpha来自于该纹理, From Gray Scale: 高度纹理需要)<br/>Alpha Is Transparency: 当alpha用于透明处理时, 可以防止不透明边缘锯齿现象. 如果Alpha有他用, 可以不勾选<br/><span class="style_Quote__dLoMM" id="#2">Wrap Mode</span>: 决定纹理坐标(Tiling)超过[0, 1]时如何填充.(Repeat:平铺, Clamp: 纯色填充)<br/><span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R1h95l6:" data-state="closed">Filter Mode</span>: 决定当纹理由于变换产生拉伸时采用的滤波模式<br/><span class="style_Quote__dLoMM" id="#1">Generate Mip Maps</span>: 使用多级渐远纹理(mip mapping)技术处理纹理缩小时的处理</div><br/>纹理由纹理映射(texture-mapping)将纹理坐标存储在各个顶点上<br/>纹理类型的属性还需要一个float4的变量 纹理名_ST 来存储缩放和偏移</div>
<p></p>
<p>基础纹理</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">凹凸映射</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">凹凸映射(bump mapping)是指使用一张2D纹理来修改模型表面法线, 使得光线反射等原因让模型具有更多细节<br/>有两种方法: <div role="expansion" class="style_Expansion__lekPG">高度纹理和法线纹理</div>, 通常将二者结合使用<div class="style_Tab__IjTlz style_hidden__yfyDi">高度纹理(height map): 模拟表面位移(displacement), 得到修改后的法线值<div class="style_Tab__IjTlz">高度纹理中存储的是强度值(intensity). 颜色越浅表示越向外凸, 越深表示越向里凹<br/>高度纹理十分直观, 容易看出细节情况; 但计算复杂, 性能的消耗十分严重</div>法线纹理(normal map): 直接存储法线<div class="style_Tab__IjTlz">法线分量在[-1, 1], 而像素值为[0, 1]. 因此图片制作时需要映射 pixel = (normal+1)/2<br/>同理, shader中对法线纹理进行采样后, 需要反映射 normal = 2*pixel - 1<br/>法线纹理中的法线方向是存储在<span class="style_Quote__dLoMM" id="#3">切线空间中(tangent space)</span>, 因此又被称为切线空间的法线纹理(tangent-space normal map)<br/>由于法线方向就是切线空间中的z轴, 如果法线方向不变, 映射后的RGB就是(0.5, 0.5, 1)浅蓝色, 所以法线纹理通常为大片的蓝色<br/><span class="style_Quote__dLoMM" id="#6">法线纹理在延迟渲染中很容易获得, 但前向渲染默认无法获得</span></div></div><br/>计算光照要统一坐标空间. 可以统一到切线空间(性能较好); 也可以统一到世界空间(通用性较好)</div><br/><div role="expansion" class="style_Expansion__lekPG">渐变纹理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">渐变纹理: 用来控制漫反射光照效果. 能够使得模型的轮廓线更加明显, 形成&quot;卡通风格&quot;<br/>如果使用渐变纹理, 纹理的Wrap Mode需指定为Clamp</div><br/><div role="expansion" class="style_Expansion__lekPG">遮罩纹理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">遮罩纹理(mask texture): 使用遮罩纹理来更加细化光照影响的层次性变化</div><br/><div role="expansion" class="style_Expansion__lekPG">立方体纹理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">立方体纹理(Cubemap): 用类似镜子的效果反射周围环境<br/>对其采样需要三维的方向矢量: 该方向矢量由中心点出发, 向外延伸与六个面相交得到交点. 采样结果就是由该交点计算出<br/>实现简单快速效果好, 但不能多重反射, 且更改环境时需要重新计算<br/>常用于实现环境映射(Environment Mapping)和天空盒<div class="style_Tab__IjTlz">天空盒在所有不透明物体后才渲染<br/>环境映射可以实现光反射及折射效果, 有三种方式创建: <div role="expansion" class="style_Expansion__lekPG">由特殊布局的纹理创建; 使用Cubemap; 脚本生成</div><div class="style_Tab__IjTlz style_hidden__yfyDi">第一种提供好TextureType为Cubemap的纹理即可. 在基于物理的渲染中, <span class="style_Quote__dLoMM" id="#4">使用HDR图像来生成高质量纹理</span>.<br/>第二种是旧方法. 推荐第一种(支持边缘修正, 光滑反射及HDR)<br/>第三种可以根据物体位置不同生成不同的Cubemap. (前两种是场景物体共用的)<br/>对于反射和折射:<div class="style_Tab__IjTlz">普通反射通过入射光线方向和表面法线方向来计算反射方向, 再利用反射方向对立方体纹理采样即可<br/>菲涅尔(Fresnel)反射利用Schlick菲涅尔近似等式或Empricical菲涅尔近似等式计算<br/>折射通过斯涅尔定理(Snell&#x27;s law)计算反射角, 图形学中对于透明物体只模拟第一次折射(第二次很复杂, 且第一次看着也没啥错)</div></div><br/></div></div><br/><div role="expansion" class="style_Expansion__lekPG">渲染纹理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">现代GPU通常会将整个场景渲染到一个中间缓存, 即渲染目标纹理(Render Target Texture, RTT), 而不是帧缓冲<br/>相关技术称为多重渲染目标(Multiple Render Target, MRT), 将场景同时渲染到多个RTT中, 而不需要为每个RTT渲染完整场景<br/>而渲染纹理(Render Texture)就是针对RTT的纹理, 使得程序员可以获取实时屏幕图像<br/>有两种创建方式: Project中创建, 并设置摄像机目标; 在屏幕后处理时使用GrabPass或OnRenderImage来获取当前屏幕图像</div><br/><div role="expansion" class="style_Expansion__lekPG">程序纹理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">程序纹理(Procedural Texture): 指由特定算法生成的图像. 如木头石子等<br/>好处在于可以使用更多的属性来得到丰富的动画和视觉效果, 可以不断更改<br/>但是对CPU运算性能要求较高<br/>通常使用Substance Designer创建(后缀为.sbsar), 直接拖入unity将生成程序纹理资源(Procedural Material Asset)</div><br/><div role="expansion" class="style_Expansion__lekPG">命令缓冲</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">命令缓冲(Command Buffers): 在不透明物体渲染后把当前图像复制到一个临时的渲染纹理中.<br/>命令缓冲常用来模糊远景等, 具体参考<span class="style_Quote__dLoMM" id="#5">图像命令缓冲</span></div><br/></div>
<p></p>
<p>高级纹理</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">深度纹理</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">深度纹理实际上就是一张存储高精度深度值的渲染纹理.<br/>这些深度值在齐次裁剪坐标系下裁剪后的Z值: d = 0.5Z + 0.5(由[-1,1]转换到[0,1]区间)<br/>若要使用, 则需正确设置RenderType标签<br/>若只生成深度纹理, 将通过不透明物体的ShadowCaster Pass来得到深度纹理.(不包含该Pass就无法得到)<br/>若生成深度纹理+法线纹理, 将创建一张屏幕分辨率的32位纹理.(RG通道存储法线, BA通道存储深度)<br/><span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rmthl6:" data-state="closed">获取纹理</span> -&gt; <span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rqthl6:" data-state="closed">纹理采样</span> -&gt; <span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Ruthl6:" data-state="closed">线性处理</span></div><br/></div><div id="Comment" class="style_Comment__GsBhh"></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"matter":{"title":"Graphics Programming(六) —— 纹理","tags":["graphics"],"index":6},"absPath":"/home/runner/work/blog/blog/mdx/graphics/texture.mdx","type":"mdx","slug":["texture"],"collection":"graphics","url":"/graphics/texture"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(六) —— 纹理\",\n  \"tags\": [\"graphics\"],\n  \"index\": 6\n};\nconst QuoteList = [\"这是典型的空间换取时间的方法. 所以如果图像因为距离关系会放大缩小, 比如场景资源, 应尽量用mip map, 否则取消mip map\", \"需要在shader里有 使得纹理偏移的代码(TRANSFORM_TEX等)才有Warp Mode效果\", \"对于模型的每个顶点都有一个对应的切线空间. 该空间原点为顶点本身, z轴是法线方向, x轴是切线方向, y轴由(x轴 × z轴)计算得到称为副切线(bitangent)\", \"参考: https://docs.unity3d.com/Manual/class-Cubemap.html\", \"参考: https://docs.unity3d.com/Manual/Graphics CommandBuffers.html\", \"获取方式详见深度纹理部分\"];\nconst ImgList = [\"纹理属性\", \"滤波模式\", \"获取深度或法线纹理\", \"深度法线纹理的采样\", \"深度和法线的线性处理\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  }, {Aphorism, Expansion, Model, Quote, Tab} = _components;\n  if (!Aphorism) _missingMdxReference(\"Aphorism\", true);\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Model) _missingMdxReference(\"Model\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(Aphorism, {\n      children: \"纹理可以存储任何表面属性\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"预先准备\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"纹理属性\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [_jsx(Model, {\n          about: \"@1\",\n          children: \"unity中调整\"\n        }), _jsx(\"br\", {}), \"Texture Type: 正确的纹理类型, 才能正确的传递纹理且unity能尽量正确的优化\", _jsx(\"br\", {}), \"Alpha Source: Alpha通道的来源.(none: 没有alpha通道, Input Texture Alpha: alpha来自于该纹理, From Gray Scale: 高度纹理需要)\", _jsx(\"br\", {}), \"Alpha Is Transparency: 当alpha用于透明处理时, 可以防止不透明边缘锯齿现象. 如果Alpha有他用, 可以不勾选\", _jsx(\"br\", {}), _jsx(Quote, {\n          id: \"#2\",\n          children: \"Wrap Mode\"\n        }), \": 决定纹理坐标(Tiling)超过[0, 1]时如何填充.(Repeat:平铺, Clamp: 纯色填充)\", _jsx(\"br\", {}), _jsx(Model, {\n          about: \"@2\",\n          children: \"Filter Mode\"\n        }), \": 决定当纹理由于变换产生拉伸时采用的滤波模式\", _jsx(\"br\", {}), _jsx(Quote, {\n          id: \"#1\",\n          children: \"Generate Mip Maps\"\n        }), \": 使用多级渐远纹理(mip mapping)技术处理纹理缩小时的处理\"]\n      }), \"纹理由纹理映射(texture-mapping)将纹理坐标存储在各个顶点上\", _jsx(\"br\", {}), \"纹理类型的属性还需要一个float4的变量 纹理名_ST 来存储缩放和偏移\"]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"基础纹理\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"凹凸映射\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"凹凸映射(bump mapping)是指使用一张2D纹理来修改模型表面法线, 使得光线反射等原因让模型具有更多细节\", _jsx(\"br\", {}), \"有两种方法: \", _jsx(Expansion, {\n          children: \"高度纹理和法线纹理\"\n        }), \", 通常将二者结合使用\", _jsxs(Tab, {\n          expan: true,\n          children: [\"高度纹理(height map): 模拟表面位移(displacement), 得到修改后的法线值\", _jsxs(Tab, {\n            children: [\"高度纹理中存储的是强度值(intensity). 颜色越浅表示越向外凸, 越深表示越向里凹\", _jsx(\"br\", {}), \"高度纹理十分直观, 容易看出细节情况; 但计算复杂, 性能的消耗十分严重\"]\n          }), \"法线纹理(normal map): 直接存储法线\", _jsxs(Tab, {\n            children: [\"法线分量在[-1, 1], 而像素值为[0, 1]. 因此图片制作时需要映射 pixel = (normal+1)/2\", _jsx(\"br\", {}), \"同理, shader中对法线纹理进行采样后, 需要反映射 normal = 2*pixel - 1\", _jsx(\"br\", {}), \"法线纹理中的法线方向是存储在\", _jsx(Quote, {\n              id: \"#3\",\n              children: \"切线空间中(tangent space)\"\n            }), \", 因此又被称为切线空间的法线纹理(tangent-space normal map)\", _jsx(\"br\", {}), \"由于法线方向就是切线空间中的z轴, 如果法线方向不变, 映射后的RGB就是(0.5, 0.5, 1)浅蓝色, 所以法线纹理通常为大片的蓝色\", _jsx(\"br\", {}), _jsx(Quote, {\n              id: \"#6\",\n              children: \"法线纹理在延迟渲染中很容易获得, 但前向渲染默认无法获得\"\n            })]\n          })]\n        }), \"计算光照要统一坐标空间. 可以统一到切线空间(性能较好); 也可以统一到世界空间(通用性较好)\"]\n      }), _jsx(Expansion, {\n        children: \"渐变纹理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"渐变纹理: 用来控制漫反射光照效果. 能够使得模型的轮廓线更加明显, 形成\\\"卡通风格\\\"\", _jsx(\"br\", {}), \"如果使用渐变纹理, 纹理的Wrap Mode需指定为Clamp\"]\n      }), _jsx(Expansion, {\n        children: \"遮罩纹理\"\n      }), \":\", _jsx(Tab, {\n        expan: true,\n        children: \"遮罩纹理(mask texture): 使用遮罩纹理来更加细化光照影响的层次性变化\"\n      }), _jsx(Expansion, {\n        children: \"立方体纹理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"立方体纹理(Cubemap): 用类似镜子的效果反射周围环境\", _jsx(\"br\", {}), \"对其采样需要三维的方向矢量: 该方向矢量由中心点出发, 向外延伸与六个面相交得到交点. 采样结果就是由该交点计算出\", _jsx(\"br\", {}), \"实现简单快速效果好, 但不能多重反射, 且更改环境时需要重新计算\", _jsx(\"br\", {}), \"常用于实现环境映射(Environment Mapping)和天空盒\", _jsxs(Tab, {\n          children: [\"天空盒在所有不透明物体后才渲染\", _jsx(\"br\", {}), \"环境映射可以实现光反射及折射效果, 有三种方式创建: \", _jsx(Expansion, {\n            children: \"由特殊布局的纹理创建; 使用Cubemap; 脚本生成\"\n          }), _jsxs(Tab, {\n            expan: true,\n            children: [\"第一种提供好TextureType为Cubemap的纹理即可. 在基于物理的渲染中, \", _jsx(Quote, {\n              id: \"#4\",\n              children: \"使用HDR图像来生成高质量纹理\"\n            }), \".\", _jsx(\"br\", {}), \"第二种是旧方法. 推荐第一种(支持边缘修正, 光滑反射及HDR)\", _jsx(\"br\", {}), \"第三种可以根据物体位置不同生成不同的Cubemap. (前两种是场景物体共用的)\", _jsx(\"br\", {}), \"对于反射和折射:\", _jsxs(Tab, {\n              children: [\"普通反射通过入射光线方向和表面法线方向来计算反射方向, 再利用反射方向对立方体纹理采样即可\", _jsx(\"br\", {}), \"菲涅尔(Fresnel)反射利用Schlick菲涅尔近似等式或Empricical菲涅尔近似等式计算\", _jsx(\"br\", {}), \"折射通过斯涅尔定理(Snell's law)计算反射角, 图形学中对于透明物体只模拟第一次折射(第二次很复杂, 且第一次看着也没啥错)\"]\n            })]\n          })]\n        })]\n      }), _jsx(Expansion, {\n        children: \"渲染纹理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"现代GPU通常会将整个场景渲染到一个中间缓存, 即渲染目标纹理(Render Target Texture, RTT), 而不是帧缓冲\", _jsx(\"br\", {}), \"相关技术称为多重渲染目标(Multiple Render Target, MRT), 将场景同时渲染到多个RTT中, 而不需要为每个RTT渲染完整场景\", _jsx(\"br\", {}), \"而渲染纹理(Render Texture)就是针对RTT的纹理, 使得程序员可以获取实时屏幕图像\", _jsx(\"br\", {}), \"有两种创建方式: Project中创建, 并设置摄像机目标; 在屏幕后处理时使用GrabPass或OnRenderImage来获取当前屏幕图像\"]\n      }), _jsx(Expansion, {\n        children: \"程序纹理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"程序纹理(Procedural Texture): 指由特定算法生成的图像. 如木头石子等\", _jsx(\"br\", {}), \"好处在于可以使用更多的属性来得到丰富的动画和视觉效果, 可以不断更改\", _jsx(\"br\", {}), \"但是对CPU运算性能要求较高\", _jsx(\"br\", {}), \"通常使用Substance Designer创建(后缀为.sbsar), 直接拖入unity将生成程序纹理资源(Procedural Material Asset)\"]\n      }), _jsx(Expansion, {\n        children: \"命令缓冲\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"命令缓冲(Command Buffers): 在不透明物体渲染后把当前图像复制到一个临时的渲染纹理中.\", _jsx(\"br\", {}), \"命令缓冲常用来模糊远景等, 具体参考\", _jsx(Quote, {\n          id: \"#5\",\n          children: \"图像命令缓冲\"\n        })]\n      })]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"高级纹理\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"深度纹理\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"深度纹理实际上就是一张存储高精度深度值的渲染纹理.\", _jsx(\"br\", {}), \"这些深度值在齐次裁剪坐标系下裁剪后的Z值: d = 0.5Z + 0.5(由[-1,1]转换到[0,1]区间)\", _jsx(\"br\", {}), \"若要使用, 则需正确设置RenderType标签\", _jsx(\"br\", {}), \"若只生成深度纹理, 将通过不透明物体的ShadowCaster Pass来得到深度纹理.(不包含该Pass就无法得到)\", _jsx(\"br\", {}), \"若生成深度纹理+法线纹理, 将创建一张屏幕分辨率的32位纹理.(RG通道存储法线, BA通道存储深度)\", _jsx(\"br\", {}), _jsx(Model, {\n          about: \"@3\",\n          children: \"获取纹理\"\n        }), \" -\u003e \", _jsx(Model, {\n          about: \"@4\",\n          children: \"纹理采样\"\n        }), \" -\u003e \", _jsx(Model, {\n          about: \"@5\",\n          children: \"线性处理\"\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  ImgList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"},{"name":"practice","length":7}]},"__N_SSG":true},"page":"/[collection]/[...slug]","query":{"collection":"graphics","slug":["texture"]},"buildId":"D7x4DkC9fYkIpJlQ3dnHJ","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>