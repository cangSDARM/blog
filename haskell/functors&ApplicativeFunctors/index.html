<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/blog/styles.0ef63cbdf5e256ef74b8.css">code[class*=language-],pre[class*=language-]{color:#c5c8c6;text-shadow:0 1px rgba(0,0,0,.3);font-family:Fira Mono,Inconsolata,Monaco,Consolas,Courier New,Courier,monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.3em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#1d1f21}:not(pre)>code[class*=language-]{padding:.15em .2em .1em;border-radius:.3em;white-space:normal;color:#dcb973;background-color:#272c35}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#7c7c7c}.token.punctuation{color:#c5c8c6}.namespace{opacity:.7}.token.keyword,.token.property,.token.tag{color:#96cbfe}.token.class-name{color:#ffffb6;font-weight:500}.token.boolean,.token.constant{color:#9c9}.token.deleted,.token.symbol{color:#f92672}.token.number{color:#ff73fd}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a8ff60}.token.variable{color:#c6c5fe}.token.operator{color:#ededed}.token.entity{color:#ffffb6;cursor:help}.token.url{color:#96cbfe}.language-css .token.string,.style .token.string{color:#87c38a}.token.atrule,.token.attr-value{color:#f9ee98}.token.function{color:#dad085}.token.regex{color:#e9c062}.token.important{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.gatsby-highlight pre[class*=language-].line-numbers{padding-left:2.8em}.gatsby-highlight{background-color:#1d1f21;border-radius:.3em;margin:.5em 0;overflow:auto}.gatsby-highlight pre[class*=language-].line-numbers{padding:0 0 0 2.8em;overflow:initial;position:relative}.gatsby-highlight pre[class*=language-].line-numbers .line-numbers-rows>span:before{text-align:center;padding:0 .5em}.gatsby-highlight-code-line{background-color:transparent}.gatsby-highlight-code-line:before{background-color:#feb;margin-right:-1em;margin-left:-.7em;padding-right:1em;padding-left:.75em;content:" ";position:absolute;left:0}pre[class*=language-].line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}pre[class*=language-].line-numbers>code{position:relative;white-space:inherit}.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:0;font-size:100%;left:-3.8em;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.line-numbers-rows>span{display:block;counter-increment:linenumber}.line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.main-module--arcivePost--3tg7H{cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.main-module--arcivePost--3tg7H figcaption{font-size:1em;display:inherit;visibility:inherit}.main-module--references--3Wn29{position:fixed;left:calc(50vw + 4em + 345px);height:0;margin:auto;top:120px}.main-module--references--3Wn29>div{display:flex;height:52;align-items:center;justify-content:center;-webkit-box-pack:center;margin-left:16}.main-module--references--3Wn29 nav{display:flex;flex-flow:column;margin-left:.2em}.type-module--ZhiHu_Zhuanlan--3WVIV{width:690px;margin:0 auto;overflow:hidden;position:relative;color:#1a1a1a;font-family:-apple-system,BlinkMacSystemFont,Helvetica Neue,PingFang SC,Microsoft YaHei,Source Han Sans SC,Noto Sans CJK SC,WenQuanYi Micro Hei,sans-serif;line-height:1.6;word-wrap:break-word;font-size:16px;counter-reset:sup}.type-module--ZhiHu_Zhuanlan--3WVIV h2{clear:left;margin-top:2.3333em;margin-bottom:1.16667em;font-size:1.2em;line-height:1.5;font-weight:600}.type-module--ZhiHu_Zhuanlan--3WVIV h3{clear:left;margin-bottom:1em;font-size:1em;line-height:1.2;font-weight:600;text-decoration:underline}.type-module--ZhiHu_Zhuanlan--3WVIV ol,.type-module--ZhiHu_Zhuanlan--3WVIV ul{display:table;margin:1.4em 0}.type-module--ZhiHu_Zhuanlan--3WVIV ol{counter-reset:ol}.type-module--ZhiHu_Zhuanlan--3WVIV ol>li{display:table-row;list-style:none}.type-module--ZhiHu_Zhuanlan--3WVIV ol>li:before{display:table-cell;text-align:right;counter-increment:ol;content:counter(ol) ". ";white-space:pre}.type-module--ZhiHu_Zhuanlan--3WVIV a{color:inherit;text-decoration:none;cursor:pointer;border-bottom:1px solid grey}.type-module--ZhiHu_Zhuanlan--3WVIV p{margin:1.4em 0}.type-module--ZhiHu_Zhuanlan--3WVIV blockquote{padding-left:1em;margin:1em 0;color:#646464;border-left:3px solid #d3d3d3}.type-module--ZhiHu_Zhuanlan--3WVIV :not(pre)>code[class*=language-]{margin:0 2px;padding:3px 4px;border-radius:3px;font-family:Menlo,Monaco,Consolas,Andale Mono,lucida console,Courier New,monospace;font-size:.9em;background-color:#eae8e8;text-shadow:none;color:#1a1a1a}.type-module--ZhiHu_Zhuanlan--3WVIV [class=gatsby-resp-image-wrapper]{margin:0 auto!important}.type-module--ZhiHu_Zhuanlan--3WVIV [class=gatsby-resp-image-wrapper]+figcaption{margin-top:.66667em;padding:0 1em;font-size:.9em;line-height:1.5;text-align:center;color:#999}.type-module--ZhiHu_Zhuanlan--3WVIV sup:before{margin:0 3px;display:inline-block;transform:translateY(2px);font-weight:500;font-style:italic;counter-increment:sup;content:"[" counter(sup) "]";font-style:normal}.type-module--ZhiHu_Zhuanlan--3WVIV strong{font-weight:600}.type-module--ZhiHu_Zhuanlan--3WVIV hr{margin:4em auto;width:240px;max-width:100%;border:none;border-top:1px solid #d3d3d3}.type-module--JianShu--2PkeO{margin-top:5px;background-color:#fff;border-radius:4px;box-sizing:border-box;font-size:16px;font-family:-apple-system,BlinkMacSystemFont,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Segoe UI,PingFang SC,Hiragino Sans GB,Microsoft YaHei,Helvetica Neue,Helvetica,Arial,sans-serif;font-feature-settings:"tnum";font-variant:tabular-nums;line-height:1.42857;padding:24px;min-height:calc(100vh - 66px);flex-shrink:0;width:730px;font-weight:400;line-height:1.8;margin-bottom:20px}.type-module--JianShu--2PkeO h1{font-size:30px;font-weight:700;word-break:break-word;color:#404040;text-rendering:optimizelegibility}.type-module--JianShu--2PkeO article{font-weight:400;line-height:1.8;margin-bottom:20px}.type-module--JianShu--2PkeO article p{margin-bottom:20px;word-break:break-word;margin-top:0}.type-module--JianShu--2PkeO a{color:inherit}.type-module--Bilibili--3NSY4 [class=gatsby-resp-image-wrapper]{margin:0 auto!important}.type-module--Bilibili--3NSY4+div[class=empty]{width:100%;height:100%;background-color:#fff;position:absolute;z-index:-999;top:0;left:0}.type-module--Bilibili--3NSY4{width:860px;padding-right:200px;overflow-x:initial;font-size:16px;line-height:1.8;color:#222;padding-bottom:50px;margin:5px auto 0;position:relative;font-family:Microsoft YaHei,-apple-system,PingFang SC,Droid Sans Fallback,Droid Sans,HYQiHei,Arial,Helvetica Neue,Hiragino Sans GB,sans-serif}.type-module--Bilibili--3NSY4>h1{margin-top:410px;text-align:left;font-size:28px;color:#222;margin-bottom:14px;font-weight:700;line-height:1.4;word-wrap:break-word}.type-module--Bilibili--3NSY4>article>span[class=header-banner]{border-radius:4px;width:660px;margin-bottom:0;position:absolute;top:0}.type-module--Bilibili--3NSY4>article>span[class=meta]{color:#9b9b9b;font-size:12px;font-weight:400;word-spacing:30px;padding-bottom:30px;display:block}.type-module--Bilibili--3NSY4>article>details>p,.type-module--Bilibili--3NSY4>article>p,.type-module--Bilibili--3NSY4>article>strong>p{margin-bottom:20px}.type-module--Bilibili--3NSY4>article>details{margin-bottom:20px;border:none}.type-module--Bilibili--3NSY4>article>blockquote,.type-module--Bilibili--3NSY4>article figcaption{color:#999;font-size:14px;line-height:1.5;text-align:center;display:inline-block;width:100%}.type-module--Bilibili--3NSY4>article>blockquote{margin-bottom:20px;padding:0 5%}.type-module--Bilibili--3NSY4>article>h2{text-align:center;color:#ee230d;font-weight:700;line-height:1.8;font-size:22px;margin:20px 0}.type-module--Bilibili--3NSY4>article>h2:not(:first-of-type){padding-top:20px}.type-module--Bilibili--3NSY4>article>h2:not(:first-of-type):before{content:" ";display:inline-block;height:1px;width:260px;background-color:rgba(0,0,0,.1);border:none;position:absolute;top:0;left:50%;transform:translateX(-50%)}.type-module--Bilibili--3NSY4>article>aside{margin-bottom:20px;display:block}.type-module--Bilibili--3NSY4>article>aside>p span[class=gatsby-resp-image-wrapper]{width:214px;background-color:transparent;display:inline-block;border:none;position:relative;font-size:0}.type-module--Bilibili--3NSY4 span[class=gatsby-resp-image-wrapper]>a{cursor:default;pointer-events:none}.type-module--Bilibili--3NSY4 a{color:#fb7299}.type-module--Bilibili--3NSY4 ul[role=tree]{margin-top:10px}.type-module--Douban--3vxJD{width:675px;padding-right:40px;font:12px Helvetica,Arial,sans-serif;line-height:1.62;margin-top:40px}.type-module--Douban--3vxJD h1{font-size:26px;word-wrap:break-word;display:block;font-weight:700;color:#494949;margin:0;padding:0 0 15px;line-height:1.1}.type-module--Douban--3vxJD h3,.type-module--Douban--3vxJD h4{margin:1em 0}.type-module--Douban--3vxJD article{color:#111;margin-top:10px;word-wrap:break-word;font-size:14px;font-weight:400;padding-bottom:20px;margin-bottom:1em;border-bottom:1px solid #eee}.type-module--Douban--3vxJD article div[class=meta]{color:#999;line-height:1.4;font-size:13px;margin-bottom:20px;overflow:hidden;padding-top:4px}.type-module--Douban--3vxJD article div[class=meta] a{color:#669;text-decoration:none}.type-module--Douban--3vxJD article div[class=meta] a:after{zoom:1;content:" ";font-size:0;background:-webkit-image-set(url(https://img3.doubanio.com/f/shire/b8f4c3672ef81106701071831e22422a745d3b74/pics/rating_icons/ic_rating_s.png) 1x,url(https://img3.doubanio.com/f/shire/b8f4c3672ef81106701071831e22422a745d3b74/pics/rating_icons/ic_rating_s@2x.png) 2x) no-repeat;display:inline-block;margin:0 5px;width:55px;height:11px;overflow:hidden;cursor:default;pointer-events:none}.type-module--Douban--3vxJD+div[class=empty]{width:100%;height:calc(100% + 80px);background-color:#fff;position:absolute;z-index:-999;top:0;left:0}.type-module--Douban--3vxJD article>p{margin-top:2em}.type-module--Douban--3vxJD nav>a{color:#669}.type-module--Douban--3vxJD figcaption{text-align:center;margin-bottom:1.5em}footer{display:flex;background-color:transparent}.default-footer{position:relative;margin:1rem auto 0;padding:.25rem 0;align-items:center;justify-content:center;flex-direction:column}.default-footer:before{content:"";position:absolute;top:0;height:2px;width:75vw;background:#eee}html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}:root{background-color:#f5f5f5}figcaption{font-size:0;display:none;visibility:hidden}body,form,html,img{margin:0;padding:0;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}article,aside,details,figure,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{text-decoration:none;background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box}*{margin:0}*,:after,:before{box-sizing:inherit}body{overflow:hidden;color:rgba(0,0,0,.8);font-family:Fira Mono,georgia,serif;font-weight:400;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt"}main{position:relative;display:flex;align-items:center;justify-content:center}main details summary{cursor:pointer;display:inline-block}main :focus{outline:0}img{max-width:100%;padding:0}h1{font-size:2.25rem}h1,h2{padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{padding:0}ol,ul{list-style-image:none;list-style-position:inside}dd,dl,figure,ol,p,ul{padding:0}pre{font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}table{font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:auto}blockquote,fieldset,form,hr,iframe,noscript,table{padding:0}hr{background:rgba(0,0,0,.2);border:none;height:1px}address{padding:0}b,dt,strong,th{font-weight:700}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum"}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:.2em 0}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}@font-face{font-family:KaTeX_AMS;src:url(/blog/static/KaTeX_AMS-Regular-e78e28b4834954df047e4925e9dbf354.woff2) format("woff2"),url(/blog/static/KaTeX_AMS-Regular-7f06b4e30317f784d61d26686aed0ab2.woff) format("woff"),url(/blog/static/KaTeX_AMS-Regular-aaf4eee9fba9907d61c3935e0b6a54ae.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(/blog/static/KaTeX_Caligraphic-Bold-4ec58befa687e9752c3c91cd9bcf1bcb.woff2) format("woff2"),url(/blog/static/KaTeX_Caligraphic-Bold-1e802ca9dedc4ed4e3c6f645e4316128.woff) format("woff"),url(/blog/static/KaTeX_Caligraphic-Bold-021dd4dc61ee5f5cdf315f43b48c094b.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Caligraphic;src:url(/blog/static/KaTeX_Caligraphic-Regular-7edb53b6693d75b8a2232481eea1a52c.woff2) format("woff2"),url(/blog/static/KaTeX_Caligraphic-Regular-d3b46c3a530116933081d9d74e3e9fe8.woff) format("woff"),url(/blog/static/KaTeX_Caligraphic-Regular-d49f2d55ce4f40f982d8ba63d746fbf9.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(/blog/static/KaTeX_Fraktur-Bold-d5b59ec9764e10f4a82369ae29f3ac58.woff2) format("woff2"),url(/blog/static/KaTeX_Fraktur-Bold-c4c8cab7d5be97b2bb283e531c077355.woff) format("woff"),url(/blog/static/KaTeX_Fraktur-Bold-a31e7cba7b7221ebf1a2ae545fb306b2.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Fraktur;src:url(/blog/static/KaTeX_Fraktur-Regular-32a5339eb809f381a7357ba56f82aab3.woff2) format("woff2"),url(/blog/static/KaTeX_Fraktur-Regular-b7d9c46bff5d51da6209e355cc4a235d.woff) format("woff"),url(/blog/static/KaTeX_Fraktur-Regular-a48dad4f58c82e38a10da0ceebb86370.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(/blog/static/KaTeX_Main-Bold-8e1e01c4b1207c0a383d9a2b4f86e637.woff2) format("woff2"),url(/blog/static/KaTeX_Main-Bold-22086eb5d97009c3e99bcc1d16ce6865.woff) format("woff"),url(/blog/static/KaTeX_Main-Bold-9ceff51b3cb7ce6eb4e8efa8163a1472.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:KaTeX_Main;src:url(/blog/static/KaTeX_Main-BoldItalic-284a17fe5baf72ff8217d4c7e70c0f82.woff2) format("woff2"),url(/blog/static/KaTeX_Main-BoldItalic-4c57dbc44bfff1fdf08a59cf556fdab3.woff) format("woff"),url(/blog/static/KaTeX_Main-BoldItalic-e8b44b990516dab7937bf240fde8b46a.ttf) format("truetype");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(/blog/static/KaTeX_Main-Italic-e533d5a2506cf053cd671b335ec04dde.woff2) format("woff2"),url(/blog/static/KaTeX_Main-Italic-99be0e10c38cd42466e6fe1665ef9536.woff) format("woff"),url(/blog/static/KaTeX_Main-Italic-29c86397e75cdcb3135af8295f1c2e28.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:KaTeX_Main;src:url(/blog/static/KaTeX_Main-Regular-5c734d78610fa35282f3379f866707f2.woff2) format("woff2"),url(/blog/static/KaTeX_Main-Regular-b741441f6d71014d0453ca3ebc884dd4.woff) format("woff"),url(/blog/static/KaTeX_Main-Regular-5c94aef490324b0925dbe5f643e8fd04.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Math;src:url(/blog/static/KaTeX_Math-BoldItalic-d747bd1e7a6a43864285edd73dcde253.woff2) format("woff2"),url(/blog/static/KaTeX_Math-BoldItalic-b13731ef4e2bfc3d8d859271e39550fc.woff) format("woff"),url(/blog/static/KaTeX_Math-BoldItalic-9a2834a9ff8ab411153571e0e55ac693.ttf) format("truetype");font-weight:700;font-style:italic}@font-face{font-family:KaTeX_Math;src:url(/blog/static/KaTeX_Math-Italic-4ad08b826b8065e1eab85324d726538c.woff2) format("woff2"),url(/blog/static/KaTeX_Math-Italic-f0303906c2a67ac63bf1e8ccd638a89e.woff) format("woff"),url(/blog/static/KaTeX_Math-Italic-291e76b8871b84560701bd29f9d1dcc7.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:"KaTeX_SansSerif";src:url(/blog/static/KaTeX_SansSerif-Bold-6e0830bee40435e72165345e0682fbfc.woff2) format("woff2"),url(/blog/static/KaTeX_SansSerif-Bold-3fb419559955e3ce75619f1a5e8c6c84.woff) format("woff"),url(/blog/static/KaTeX_SansSerif-Bold-7dc027cba9f7b11ec92af4a311372a85.ttf) format("truetype");font-weight:700;font-style:normal}@font-face{font-family:"KaTeX_SansSerif";src:url(/blog/static/KaTeX_SansSerif-Italic-fba01c9c6fb2866a0f95bcacb2c187a5.woff2) format("woff2"),url(/blog/static/KaTeX_SansSerif-Italic-727a9b0d97d72d2fc0228fe4e07fb4d8.woff) format("woff"),url(/blog/static/KaTeX_SansSerif-Italic-4059868e460d2d2e6be18e180d20c43d.ttf) format("truetype");font-weight:400;font-style:italic}@font-face{font-family:"KaTeX_SansSerif";src:url(/blog/static/KaTeX_SansSerif-Regular-d929cd671b19f0cfea55b6200fb47461.woff2) format("woff2"),url(/blog/static/KaTeX_SansSerif-Regular-2555754a67062cac3a0913b715ab982f.woff) format("woff"),url(/blog/static/KaTeX_SansSerif-Regular-5c58d168c0b66d2c32234a6718e74dfb.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Script;src:url(/blog/static/KaTeX_Script-Regular-755e2491f13b5269f0afd5a56f7aa692.woff2) format("woff2"),url(/blog/static/KaTeX_Script-Regular-d524c9a5b62a17f98f4a97af37fea735.woff) format("woff"),url(/blog/static/KaTeX_Script-Regular-d12ea9efb375f9dc331f562e69892638.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size1;src:url(data:font/woff2;base64,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) format("woff2"),url(data:font/woff;base64,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) format("woff"),url(/blog/static/KaTeX_Size1-Regular-7342d45b052c3a2abc21049959fbab7f.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size2;src:url(data:font/woff2;base64,d09GMgABAAAAABUQAA4AAAAAL6gAABS4AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABmAAg1oIDAmXFxEICq0opA0BNgIkA4EsC1gABCAFjWcHgkIMfxu/KRXsmC94HKBlnAHx/5cDeohagu27Bd+UDRYS4HoJ9Iy0jqKYlRsb40/dVFO9V45+vBidwLEdz2Gm4PgTf4CQaHIvyLYhf9sMFn8t9SMkmfXh+VP/3PsQonVe0CZ1UKRTzaTg5nYAOkkZ9CXO7N/PKXA2NaGeLIYKjGq9HwCyagD/j7Z+VpTgaW544DuD2BfNGioJmlkraoo6XXUyeP/DrhS2ytZ278UMmJp9mQ5irIsgMT+tHJIQUHAu1XIo8YgobOwDQa2sAmBY7l+hdXhviuy9mdpJkvAtnfmt9poLbE7WnYBUTQhM5XCtJCBW5f8/16e992XyIVtKkVNw7IE8KiBj3rxMcvLeG0pKmczCzAdKRWYRZv4CkC+QAs7f5QKxYrX1iBpIoxH/rKqskbpaVdcQO5xIu+77agxhGzkvromsLBKeLtS2DwGUySArwQF0MX0ZwNLktZPf4SIU4cizgJtqXLuOZ1I5KG8AMiHc7GbU7UUjV8m0CsCKVgZhZwEEGWYtwwt04GtJ9jqLC891LASwkEJADJLQgqmYjp30Xfozw1g0llBLouUtq8x+OZbGsrH8ze4JKAhwyI/apFOL6vBxltetYvv/sYDnv2V1/+Vn3zlqheWGPS947n6u+JX+8uSXK780/GL4Pv1b67eWb83qOBDAAMKDxjTUtCgAURmP5baASRROt0gswVkihQyGTgMDND1OI8hxcgol3qWMHEHgKY6T9PQfuvUp/MOnSPIKx1teqfgiVLv/Ylcnm9vMeQ/eAG3Uw8McGggQ4lUDhRbi9RIbPvUOL80Zz8dvPkdv3pV6UfkqejKTE97MJd63pIpX7hY4WKuASohTOJHh9YhWKou7E0h5JoVQLaQZkgqp+ZxmyUHs9Q3QzhK+4A0MNBasdgvB8VWEkwAvwXmfIHEDC/PmtahcGlSZks8SPojvMszJpx4HVYT/k+tWnZUo2PA65leue5OiJUEh8228hGuXJZz20Tkg4o0ekXWAd0StZALR0UHTlfPsHgnu1CCC9OxBxvk/1qUCEWTmhHV+Hq3WJ0YvaoHjcN3bGyQT2j8tZXT3xAwQVrPGxZpoYSwPK4PmEVAu00R0tKh1IykzIuPgYitE1NyAnLXpBeplTSYvemc+XfcNClQa5TGgGzUoAYkl5HyyTuIuCQlFAd6jgupCFYTaKhvUP9ZlxZqgZFZpF6QasDg1nr6Llc1H6WLVNoX9cDRky+v49O3Rdf5WdAfVoqLn3jsqcMeQJKCyBAjVUOUbVAwPmZpg9JWS2S8PyxbLYkkunLxV2tm0QwGa3MxLNCHnFIUlE1W81R0f3mmFO2EjCMFlTzw5v9Y6rNWi8C6ikqAxMglIBcRBGZL8VvfX0eU2lPaqrcYx/oa7kBr0qBjdaDBAQsBIKAQRBoIJCyGEg1DCQxgRQTgRQwSRRGOgFvLlSiz8KnHwd52OxBrH1EQTblFgKzATChbCgJWwYCMcRBEeookI7EQMDiJx4g32IIaEyow61tAYOfQIhR7xXe5TkwgSjIRTQxKkqZzRZN2WjWTdR/KdT0/O6aHVkylJp8p5wzjeSm3MuYxTG6PZDd1XmXuk83EnJ4CY/NpVTZj+Qvj0jA5sq7q94XpDMrSnqco+YLyHGlLQntlrSMUuQzivuIM0VOqml9RqCqRzdzwui6e2PK5OceZ8gkjoUz0xnLze4AWYwqqbWPFIeGNZEkXaK17FUdIvUMumCVYCYiDaF/k7zHwdf9KzTcH9pGEzNIVhMBRTxUrg2yTHNLk0iTwUpcb7GMq8MBh2i0ie3c51kYehqmT3qzMJNtik23KGmBOoIlPQfLM2woBbkmdYhtNuq4oXwIZGSdWjUbM50I0nzkkv9GjAlPqFXDCDb3tbGaXnIRBLkDRh8pjDRK8qsw2WUdeHx9hqz7yDli8hOKu7vBJTPf4AnPJVzU5sOUdITxa978zg9oX+linEq63tTb8PTMoM50/eRDKa2pro9Tcy9RlHezWNTILaaFecNcBrfKPZA9KtCCTrL/Mr3nUFLFsS1bmcTobB7oUl054is8WxlDuoYtGsDr2xV0w7IGsBG2IuvWdbzrv8Qp/UFHn2sE1A8i/0tqVVVVqNBenJ8un1WBSdE6mG5NNxKewoGlT4s0tKLxcPSENQsi5Mx6ZWk2JNTOWVDnqkS8mpomzQQyA/MBGQNYWFgKpTwEZApynsCRh0MjgSMGkKZwIWnRyuBGyawp2AQ6eIJwGXpvAm4NHJ4kvApyn8iXZwHj91Swsh7/60D4qIHZC8OyNgF+RcgwCURAPURENqK3YDvb4JRqIJZqIJVqIJdn0LnEQL3EQLvERrKB//70/086d19LM/b3yqGFvlpA8rfgLIcrBuUAEyLoH+NfQA+A8BSQvCkAJAtKAF0yIPJw0QnYI5NqIz4ARFY4lYlo0wKcUqcWVJkLOF0Y5e4RmbQ1Ub1OHhSS7eDwuOVN1BpFytVEZq1Rq9KzmNhU1xW4MH4gEZ7o9GSIJCyAJU4meBLZBk0S2+ywPpj6ktVIVxXac1kPyQIO1gxWNvhCr7KVtyk8vnQHWWV3g2kKeIyQsMUAeDERJp5s4wV+GS2tMF3EEQFyNIZoSQTZiSZWwCfk2cUxWPorqYCwUjr2AUG1+uMKZgyKobfEISCTwxwCf7CKF1KqndXJA+XfPvtRaoVyrp/gcDxlNef2Xzi8lqnFUyQF4EgnUvGK2plM7Hww/Gq6uf+cz48MaHOQvZgvaEKVlgM8JLbv5tMKyM8f4/qZyErtsfnst0sstfc42e8jEu69X31vdaXIqDD1cV55bSB7xH+rk5L4X7HNLJvgeMIcQx9nB8OY7hdEKOrOzUGIMGLLg0H9oYkBeMOGHBdWsQgheiykSc+oIq0ly6b0CzaJMpqnPPTcfXkylixx/b8lDI9rzVoJepJcMlHnt/FFEsvB2bJPnke+ag4o9vjeJ/pkLI3mOqKFvy1B0GIdcOw8bdcIu76eadj7+W/3z2Z1OVy2csnY8tPymi+P31ODd880Zc1lfKRUgvgOp55lxUIE1mJb67v/SBD8ontiEdLlNLcTmfw2b7UwV6yZv6B73hqYU3vzK6f/lPAqzYzucrXkFX/eSinF/m3b3ke248pi96MTFGjvQD6/wV42SrTq8t+cT4tsomJeO8J7i8PkZRdeQ8pNtuzCkyjr/Pq7NCmh6pZU9TW6iFGdkpDOcDScxatAcCLPw6rdfS+Lr7s4Qzr5w+6+//OQsB6cT7xPTbxf/Mo4hFtRCX81vWHFpGD0JIpxU+n7iQB+r9QIzyRD3S14XwasgmhJ7P86IJUKeAzQ4q8gJ3MEh0NKCAvcarK94SkPd33NHdDTbDaZetOteOw95e9dNPzE0cp5LZwfqBmGKuuuaQx2SFq/R94a/h0YlL+KZD+hoNPKBJYrZtmIrfCRGqn7LwgTqJVx8HjiG9pe24PeB8IFp1j/8hGQdk8+M5iLHNsRA6B8fiVYwe2PgOAGtBzWGQUarRGMAlrdxKMVFH6kDueB2o01QI9VD44L9MP7HsDp3vePyti3EsHPJJ8m9aPr3y7oE8dsloGwLV/wCHaZmY3aRFWx11QuZdGg8Ac655PpDXGKT3IATkuI7wSCZAiPQupNkcqBbyCmOo5IQDBpzPfcnebwFTq6XjIw6AcdeYxltz2lCZFpQTrQJCiAH2CZLP8V3U0Ryx/i53wC12zmR84QP9G5441nku/f6b5+Ua95dnwn0M+8nnD49eFsaISsdPsHVHHfvn4Sc8TR4jHqtQEGzxx68RhbK/GK9oqI5q8xPGb7SO1m7o0W+v8GULq4wyx7ffWWI0GKTw/ePmf1sIkeg/zxnwu854+NujgoPUMVbHtz+y0hsyeYOlYBiesCWe/xD/Y8Zb5vgUitOn+kSOdUrwKW6HFoww1w5xr04NTls9xG2uHVEYilu2dGzuTYm+tMl7cN9omdKnVNjGtP6b71Lmh+BWbAaWJYAY6zqzHNWrz27uHTGeIAHLMmJxM1SZn+/6t3WMTcGLxnWqclWKt7/5tTJVW5h36zLP5+QfLuiyyRW2rhdr/JnSBv7yrTxtYWXqr9+8rVD6lBKv+7QrtaJytYx8Lw8kZB5f9ueertHO+Py4FU4JPsFtfnVFZarrtNvLs43ku4LHNaV3D2Qyu+n//80wL7+XzdzJXj7D/N//dDefdE3jyJUOfbVJuB+ILq8If/uhUK1W2wtnuvyx8+PLkuTnsluEf2pvjQr76Uw93+fLJvYn0vmvJNucpq2dL029lSqdHlLiOH+/GY1lkf5Hli1uTRuwbECXoYZiGssQlFuXRVPz/QuF/0Mgz7x1xtzYmD7/U1PJHzbH8EKbesLInI/kNBG2KZ9OMhBG1UC+OqRZyBdpVlur+xb3ckT13JO+uR6N5ioR1UUHzduYWShJJCSrfuW73jLJMKWB77N2hkbDmv89Yxykketzkl/aGfeH/sECzbJR6T0/+6KGV/0VvfNFoIHf/3dcmdZtDX39Z0vy47DZsQ8bNPOCDTXGqoS57sp/RCZP7ywh4vXwoO7guDKrZYP5spZTPxIahQb7hxGrgje32WYS0wxDtm3kxU8zE/rkmMI/DwvqZvxPU53ZbCbF2va6pzC11AQxCV8kJZZGFSdk19i3ct6tYRnZnHSJb2bMgvi17qz+DkEs5Y6WJ5lLohoS8qpqErJ/H55JvUtVR/zmKXNEPm/qrqMjQmZqG/Wc7ew3mRUBf6Zf5y9zN5MIIbgrIXb+jIKu4OXDQ2aL3kKsfHy2qnmgvMAkzbq9SveKPvLHlJDcFSG1q6wfRuo/1osYR3iKUXfBFP6dNtwXZqQ8M3au7rjB9EFTiG1xyLi15HKE/hWdiBoFHdr3wiMuK7dJMcT8nghdZ43JJ1eqRtYWpbZvU9SXohoz32OEc5Z9Tubl1ySSlX99vbcoL2S4ffFp0UjJay8zzn2WcwLzHt6TBr25YsLMITzTtcK0X6s5SwLFRx+mJbEPUdoQXVK8fHVhp3ti/N8+2dbq7W0d+vlCUx8KtjF5rsmvx3w0CU+e5qxb5zUP/9QHpQf3MfAj7yoDx7eMDc1tXCiV/yoRnTpp79v6l893akZPiKQ3pKo9WarI8yM77+7OicTrTAJHTp02Sj6XqYfh3IUzZ5Rnzp67gGF8zFsnv07suXOOosP106BhPxSt2TcuamTGxTVTts55LyR5lO1UkPHTknXb13rtlO1z/Xk7PUk1J43zRk/t7LEnoql9R/nSgql3d29XaCIiNcMl7fEDE7fti+mIGzH2wF719JIJ+cHFjmyHy2x3rFez+d9pYVKxP5qbw+z0dH3A/lQU+WqZnOhWWjVspV2nI5SIGPm0qd/3K57Vqlm7qXT4/sVz+x9RL7MRH8xe2SlpjtPsGlguyy9TNfwOdPJR++Vz25aw/rrOzjfCxt5kl8xuiswnzOxZ/NS72W90e/nS1WvGsNQIrjenLyF1dR3aKhjf9xfzX5l9777/3nt5ZE4XoSmPJ5WuV2h6adYpppQ+jlL1qaa32jLms3nh6LCOjmHCnU6N6ei7JpFg6Oj0ywovh0f8UCjzd3YYBJHp3aMmTecdAbVFzHStoByImTDeNn6CuA3vc+r1BS2YOH3V/FXTMbGlgLmJI/7N/OgD/Dilri+PAWFqcfr+8JgFtANA2vOJ9A47A6M6ysDPCdXjWZ4loM6403JKgKLQeChEkxCFUaI0G9XE7DyDNFlFkFqYw0EYNqbo/bPjaiDQ4Pzp1XtkDjayo5+/MNI5ncuRxBwqCLuYQIkJs5qBb5Sj43xeRqLpdRiPyZSXFvXskZhgimQId7jW2oKs3u5Y01Bnyzw2Spl7Z7nm20lbwDMCAUCAWXM1sjZVr/tiGfM/AHx/apME7vKZ7tlu0ctcJQAxKEBEKZoooZH3ChpeTGOFE4YwDk9AY/OyBk/K1Icz24hWJg5e8j1+h5jWpaZbMBEYWgvzf/dTFdxnurZvMPsC1TK3F2mp6EgajzS2lzXwXjM7jTrYharxe06dLPTHKDvAz/0Hr43eROIBaMQASZTWXwGnA3QNakwEIMg2IAwwEmUzocrKGgQyVBkUIjQbDKzob7DQYb7BQYFNU/JVhoJ4sN9QIpT8MKVahKJxmGhkJf12k7tZg8BI1xkUSnrEYJBPLxosomm3wSGUiZqSXxsKOojJMJRI5vZNqV4TzXj/LAavtdn0k61FfsZlasKuNXMm9UdBVcXXqOIQVVhIyHjp1YEW6Mhfby9gk6HfLIu9TA/dfEfkiy6Nk1AHpEx+W6vUmk2bJ/FlRoqKTj+3pTLRnHDEpjcFCoqmby18O629RctVNo02KXovh03MsV9en7WJzWQeX/UijqFpTGa9/ecB2hMxx5uiFBxmyxfrN/GtX9TLbnWewheTn02eg1/q10HXkL0dIK+Ozbi0/gYN+i+1uVMruBkvKx/33cC0YkcWJQ9SbBpocinW8hlOxaAw5F10bgw80IY8Z0GYgxmsHI4x34kqYpUvZBIxxl4BcdGpx4sjHg99vR3kpJPe8+3OfA05Y9PwktxJSV6MxJVekTqwmUZ+PykQ+ZmQjhkUs0ji0awsmnNW5faMVbEZPnTiOmoFSYE8olLN/pe004avJjSjIk6FdhMK57kohrJqEowmXVPxAAzgwEkHhzXSu+UY1n04luISObVLzA8HFHj4QycDSFyDkjUdusA1+pJTQYJSkmdQmC1bsLHQJ2Q+9ZIJ5Ko7GimgLOVqiu4EFJiUu4rOaFOCWSQSWuztsqFXx1xEF241TljRZV3HrUGPElcgpxn6uk9sxkuy8x/CeepyZzdF+B368fnV7nS/T4nRfugHjNEEXOPb11a8adkut8fx+vw0tHT0DIyCBAsROscbsi5OZ5YzeeMep1syrmPYgIG/wCgrbHG7XU7Y0p2j5ibytsxxqi7VrXh28Di9arqapWTvkJbnTaH0y3I6QXWpbjWZpO6Rl5+fq+bdVT5KLuD96voAIcsbTpIfs48+KgA+OwDEwtHFl7kIQLKPZ5AbsJGFVfUnMxfWEzCAREcuiWeBsGzQv7YeizfMngOQx14g3Y9dFqCFATcgFwAAAA==) format("woff2"),url(data:font/woff;base64,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) format("woff"),url(/blog/static/KaTeX_Size2-Regular-eb130dcc661de766c999c60ba1525a88.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size3;src:url(data:font/woff2;base64,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) format("woff2"),url(data:font/woff;base64,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) format("woff"),url(data:font/ttf;base64,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ZQBYAF8AUwBpAHoAZQAzAC0AUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMAAuADAALgA0AEMAbwBwAHkAcgBpAGcAaAB0ACAAKABjACkAIAAyADAAMAA5AC0AMgAwADEAMAAsACAARABlAHMAaQBnAG4AIABTAGMAaQBlAG4AYwBlACwAIABJAG4AYwAuACAAKAA8AHcAdwB3AC4AbQBhAHQAaABqAGEAeAAuAG8AcgBnAD4AKQAKAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABjACkAIAAyADAAMQA0AC0AMgAwADEAOAAgAEsAaABhAG4AIABBAGMAYQBkAGUAbQB5ACAAKAA8AHcAdwB3AC4AawBoAGEAbgBhAGMAYQBkAGUAbQB5AC4AbwByAGcAPgApACwACgB3AGkAdABoACAAUgBlAHMAZQByAHYAZQBkACAARgBvAG4AdAAgAE4AYQBtAGUAIABLAGEAVABlAFgAXwBTAGkAegBlADMALgAKAAoAVABoAGkAcwAgAEYAbwBuAHQAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABsAGkAYwBlAG4AcwBlAGQAIAB1AG4AZABlAHIAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACwAIABWAGUAcgBzAGkAbwBuACAAMQAuADEALgAKAFQAaABpAHMAIABsAGkAYwBlAG4AcwBlACAAYQB2AGEAaQBsAGEAYgBsAGUAIAB3AGkAdABoACAAYQAgAEYAQQBRACAAYQB0ADoACgBoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAAACAAAAAAAA/4MAMgAAAAAAAAAAAAAAAAAAAAAAAAAAABsAAAABAAIAAwALAAwAEgA+AD8AQABeAGABAgDYANkBAwEEAKUBBQEGAQcBCAEJAQoBCwEMAQ0HdW5pMDBBMAd1bmkwMzAyCXRpbGRlY29tYgd1bmkyMzA4B3VuaTIzMDkHdW5pMjMwQQd1bmkyMzBCB3VuaTI3RTgHdW5pMjdFOQd1bmlFRkZEB3VuaUVGRkUHdW5pRUZGRgAAAAEAAf//AA8=) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Size4;src:url(data:font/woff2;base64,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) format("woff2"),url(data:font/woff;base64,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) format("woff"),url(/blog/static/KaTeX_Size4-Regular-ad7672524b64b730dfd176140a8945cb.ttf) format("truetype");font-weight:400;font-style:normal}@font-face{font-family:KaTeX_Typewriter;src:url(/blog/static/KaTeX_Typewriter-Regular-6cc31ea5c223c88705a13727a71417fa.woff2) format("woff2"),url(/blog/static/KaTeX_Typewriter-Regular-3fe216d2a5f736c560cde71984554b64.woff) format("woff"),url(/blog/static/KaTeX_Typewriter-Regular-257023560753aeb0b89b7e434d3da17f.ttf) format("truetype");font-weight:400;font-style:normal}.katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0;text-rendering:auto}.katex *{-ms-high-contrast-adjust:none!important}.katex .katex-version:after{content:"0.11.1"}.katex .katex-mathml{position:absolute;clip:rect(1px,1px,1px,1px);padding:0;border:0;height:1px;width:1px;overflow:hidden}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathdefault{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-weight:700;font-style:italic}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;vertical-align:bottom;position:relative}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;vertical-align:bottom;font-size:1px;width:2px;min-width:2px}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{width:0;position:relative}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{display:inline-block;border:0 solid;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{display:inline-block;width:100%;border-bottom-style:solid}.katex .hdashline{display:inline-block;width:100%;border-bottom-style:dashed}.katex .sqrt>.root{margin-left:.27777778em;margin-right:-.55555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.83333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.16666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.66666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.45666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.14666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.71428571em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.85714286em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.14285714em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.28571429em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.42857143em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.71428571em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.05714286em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.46857143em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.96285714em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.55428571em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.55555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.66666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.77777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.88888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.11111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.33333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.30444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.76444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.41666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.58333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.66666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.83333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.72833333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.07333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.34722222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.41666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.48611111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.55555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.69444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.83333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.44027778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.72777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.28935185em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.34722222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.40509259em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.46296296em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.52083333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.69444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.83333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.20023148em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.43981481em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.24108004em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.28929605em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.33751205em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.38572806em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.43394407em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.48216008em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.57859209em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.69431051em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.83317261em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.19961427em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.20096463em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.24115756em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.28135048em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.32154341em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.36173633em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.40192926em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.48231511em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.57877814em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.69453376em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.83360129em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{display:block;position:absolute;width:100%;height:inherit;fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1}.katex svg path{stroke:none}.katex img{border-style:none;min-width:0;min-height:0;max-width:none;max-height:none}.katex .stretchy{width:100%;display:block;position:relative;overflow:hidden}.katex .stretchy:after,.katex .stretchy:before{content:""}.katex .hide-tail{width:100%;position:relative;overflow:hidden}.katex .halfarrow-left{position:absolute;left:0;width:50.2%;overflow:hidden}.katex .halfarrow-right{position:absolute;right:0;width:50.2%;overflow:hidden}.katex .brace-left{position:absolute;left:0;width:25.1%;overflow:hidden}.katex .brace-center{position:absolute;left:25%;width:50%;overflow:hidden}.katex .brace-right{position:absolute;right:0;width:25.1%;overflow:hidden}.katex .x-arrow-pad{padding:0 .5em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{box-sizing:border-box;border:.04em solid}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{text-align:left}.main-module--mainStyle--32g9c{background-color:#293134}.main-module--graphicsPost--1mZH_{font-size:18px;width:auto;font-family:Source Code Pro,sans-serif;color:#e0e2e4;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;white-space:nowrap}.main-module--indexingStyle--3CMDN{-webkit-filter:invert(1);filter:invert(1)}.main-module--taglistsStyle--2SdT_{-webkit-filter:invert(25%) contrast(2);filter:invert(25%) contrast(2)}.main-module--titleStyle--1zFlz{color:inherit}.main-module--hrStyle--1G--l{height:12px;background-color:#e0e2e4;border:0;margin-left:0;width:50%}.main-module--aStyle--ssxnB{color:#a6b9e4;font-weight:700;text-decoration:none}.main-module--tdStyle--j2vgb,.main-module--thStyle--Zhl2Q{font-size:90%;padding-right:2%;padding-left:2%;text-align:left;width:auto;white-space:nowrap}.main-module--tdStyle--j2vgb{padding-left:2em;width:auto}tr{background-color:#444757}.main-module--Comment---gWqV{padding:8px;position:fixed;bottom:2%;right:0;font-size:18px;background-color:#e0e2e4;color:#293134;margin-left:45%;animation:main-module--CommentAnima--2aB03 1.5s;z-index:999}@keyframes main-module--CommentAnima--2aB03{0%{opacity:0}to{opacity:1}}#style-module--Title--2_9nm{font-size:24px;margin-left:40px}.style-module--model--3Iq--{display:inline-block;cursor:pointer;color:#d9ff00}.style-module--FullScreen--3if3Y{position:absolute;top:0;left:0;right:0;bottom:0;background-color:#293134;z-index:200;cursor:default;overflow:auto}.style-module--hide--2kZ6I{display:none}.style-module--aphorism--1Mfjq{color:#a6b9e4;font-weight:700;font-size:20px}.style-module--Quote--3Uja4{background-color:#424c4f}.style-module--Quote--3Uja4:after{content:"\262D"}.style-module--Tab--37ZWx,.style-module--Tab--37ZWx[vicinage]+*{margin-left:3.5%}.style-module--Expansion--2EPqa,.style-module--Imgs--e8MUK{display:inline-block;-webkit-text-decoration-line:underline;text-decoration-line:underline;font-family:文泉驿等宽微米黑,sans-serif,monospace;text-shadow:1px 1px 1px #830600,2px 2px 2px #004284}.style-module--Expansion--2EPqa:hover{cursor:pointer;transition-duration:.6s;-webkit-text-decoration-line:underline overline;text-decoration-line:underline overline;letter-spacing:.1em;text-shadow:-1px -1px 1px #111,2px 2px 1px #363636}.style-module--Expansioned--2DB3r{letter-spacing:.1em}div.style-module--hidden--127KT{display:none;visibility:hidden}.style-module--netPost--2lUUb{color:inherit}.style-module--cblockquote--3N1Cj{border-left:4px solid #ddd;color:#777;padding:0 15px;margin:15px 0}.style-module--netPost--2lUUb h2{border-bottom:1px solid #ccc;line-height:1.2;color:#000;margin:26px 0 15px}.style-module--netPost--2lUUb p{margin:10px 0}.style-module--netPost--2lUUb span[class=gatsby-resp-image-wrapper]{margin:1em auto!important}.style-module--netPost--2lUUb ul{margin:20px}</style><meta name="generator" content="Gatsby 2.24.47"/><title data-react-helmet="true">Functors, Applicative Functors | LearnYouAHaskell</title><meta data-react-helmet="true" name="description" content="This barebones starter ships with the main Gatsby configuration files you might need."/><meta data-react-helmet="true" property="og:title" content="Functors, Applicative Functors"/><meta data-react-helmet="true" property="og:description" content="This barebones starter ships with the main Gatsby configuration files you might need."/><meta data-react-helmet="true" property="og:type" content="website"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:creator" content="@allenEyes"/><meta data-react-helmet="true" name="twitter:title" content="Functors, Applicative Functors"/><meta data-react-helmet="true" name="twitter:description" content="This barebones starter ships with the main Gatsby configuration files you might need."/><link rel="icon" href="/blog/favicon-32x32.png?v=4a9773549091c227cd2eb82ccd9c5e3a" type="image/png"/><link rel="manifest" href="/blog/manifest.webmanifest"/><meta name="theme-color" content="#663399"/><link rel="apple-touch-icon" sizes="48x48" href="/blog/icons/icon-48x48.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="72x72" href="/blog/icons/icon-72x72.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="96x96" href="/blog/icons/icon-96x96.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="144x144" href="/blog/icons/icon-144x144.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="192x192" href="/blog/icons/icon-192x192.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="256x256" href="/blog/icons/icon-256x256.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="384x384" href="/blog/icons/icon-384x384.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><link rel="apple-touch-icon" sizes="512x512" href="/blog/icons/icon-512x512.png?v=4a9773549091c227cd2eb82ccd9c5e3a"/><style id="jss-server-side">.MuiSvgIcon-root{fill:currentColor;width:1em;height:1em;display:inline-block;font-size:1.5rem;transition:fill .2s cubic-bezier(.4,0,.2,1) 0s;flex-shrink:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.MuiSvgIcon-colorPrimary{color:#3f51b5}.MuiSvgIcon-colorSecondary{color:#f50057}.MuiSvgIcon-colorAction{color:rgba(0,0,0,.54)}.MuiSvgIcon-colorError{color:#f44336}.MuiSvgIcon-colorDisabled{color:rgba(0,0,0,.26)}.MuiSvgIcon-fontSizeInherit{font-size:inherit}.MuiSvgIcon-fontSizeSmall{font-size:1.25rem}.MuiSvgIcon-fontSizeLarge{font-size:2.1875rem}.MuiPaper-root{color:rgba(0,0,0,.87);transition:box-shadow .3s cubic-bezier(.4,0,.2,1) 0s;background-color:#fff}.MuiPaper-rounded{border-radius:4px}.MuiPaper-outlined{border:1px solid rgba(0,0,0,.12)}.MuiPaper-elevation0{box-shadow:none}.MuiPaper-elevation1{box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.MuiPaper-elevation2{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.MuiPaper-elevation3{box-shadow:0 3px 3px -2px rgba(0,0,0,.2),0 3px 4px 0 rgba(0,0,0,.14),0 1px 8px 0 rgba(0,0,0,.12)}.MuiPaper-elevation4{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12)}.MuiPaper-elevation5{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 5px 8px 0 rgba(0,0,0,.14),0 1px 14px 0 rgba(0,0,0,.12)}.MuiPaper-elevation6{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12)}.MuiPaper-elevation7{box-shadow:0 4px 5px -2px rgba(0,0,0,.2),0 7px 10px 1px rgba(0,0,0,.14),0 2px 16px 1px rgba(0,0,0,.12)}.MuiPaper-elevation8{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.MuiPaper-elevation9{box-shadow:0 5px 6px -3px rgba(0,0,0,.2),0 9px 12px 1px rgba(0,0,0,.14),0 3px 16px 2px rgba(0,0,0,.12)}.MuiPaper-elevation10{box-shadow:0 6px 6px -3px rgba(0,0,0,.2),0 10px 14px 1px rgba(0,0,0,.14),0 4px 18px 3px rgba(0,0,0,.12)}.MuiPaper-elevation11{box-shadow:0 6px 7px -4px rgba(0,0,0,.2),0 11px 15px 1px rgba(0,0,0,.14),0 4px 20px 3px rgba(0,0,0,.12)}.MuiPaper-elevation12{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 12px 17px 2px rgba(0,0,0,.14),0 5px 22px 4px rgba(0,0,0,.12)}.MuiPaper-elevation13{box-shadow:0 7px 8px -4px rgba(0,0,0,.2),0 13px 19px 2px rgba(0,0,0,.14),0 5px 24px 4px rgba(0,0,0,.12)}.MuiPaper-elevation14{box-shadow:0 7px 9px -4px rgba(0,0,0,.2),0 14px 21px 2px rgba(0,0,0,.14),0 5px 26px 4px rgba(0,0,0,.12)}.MuiPaper-elevation15{box-shadow:0 8px 9px -5px rgba(0,0,0,.2),0 15px 22px 2px rgba(0,0,0,.14),0 6px 28px 5px rgba(0,0,0,.12)}.MuiPaper-elevation16{box-shadow:0 8px 10px -5px rgba(0,0,0,.2),0 16px 24px 2px rgba(0,0,0,.14),0 6px 30px 5px rgba(0,0,0,.12)}.MuiPaper-elevation17{box-shadow:0 8px 11px -5px rgba(0,0,0,.2),0 17px 26px 2px rgba(0,0,0,.14),0 6px 32px 5px rgba(0,0,0,.12)}.MuiPaper-elevation18{box-shadow:0 9px 11px -5px rgba(0,0,0,.2),0 18px 28px 2px rgba(0,0,0,.14),0 7px 34px 6px rgba(0,0,0,.12)}.MuiPaper-elevation19{box-shadow:0 9px 12px -6px rgba(0,0,0,.2),0 19px 29px 2px rgba(0,0,0,.14),0 7px 36px 6px rgba(0,0,0,.12)}.MuiPaper-elevation20{box-shadow:0 10px 13px -6px rgba(0,0,0,.2),0 20px 31px 3px rgba(0,0,0,.14),0 8px 38px 7px rgba(0,0,0,.12)}.MuiPaper-elevation21{box-shadow:0 10px 13px -6px rgba(0,0,0,.2),0 21px 33px 3px rgba(0,0,0,.14),0 8px 40px 7px rgba(0,0,0,.12)}.MuiPaper-elevation22{box-shadow:0 10px 14px -6px rgba(0,0,0,.2),0 22px 35px 3px rgba(0,0,0,.14),0 8px 42px 7px rgba(0,0,0,.12)}.MuiPaper-elevation23{box-shadow:0 11px 14px -7px rgba(0,0,0,.2),0 23px 36px 3px rgba(0,0,0,.14),0 9px 44px 8px rgba(0,0,0,.12)}.MuiPaper-elevation24{box-shadow:0 11px 15px -7px rgba(0,0,0,.2),0 24px 38px 3px rgba(0,0,0,.14),0 9px 46px 8px rgba(0,0,0,.12)}.MuiAppBar-root{width:100%;display:flex;z-index:1100;box-sizing:border-box;flex-shrink:0;flex-direction:column}.MuiAppBar-positionFixed{top:0;left:auto;right:0;position:fixed}@media print{.MuiAppBar-positionFixed{position:absolute}}.MuiAppBar-positionAbsolute{top:0;left:auto;right:0;position:absolute}.MuiAppBar-positionSticky{top:0;left:auto;right:0;position:-webkit-sticky;position:sticky}.MuiAppBar-positionStatic{position:static;transform:translateZ(0)}.MuiAppBar-positionRelative{position:relative}.MuiAppBar-colorDefault{color:rgba(0,0,0,.87);background-color:#f5f5f5}.MuiAppBar-colorPrimary{color:#fff;background-color:#3f51b5}.MuiAppBar-colorSecondary{color:#fff;background-color:#f50057}.MuiAppBar-colorInherit{color:inherit}.MuiAppBar-colorTransparent{color:inherit;background-color:transparent}.MuiAvatar-root{width:40px;height:40px;display:flex;overflow:hidden;position:relative;font-size:1.25rem;align-items:center;flex-shrink:0;font-family:Roboto,Helvetica,Arial,sans-serif;line-height:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:50%;justify-content:center}.MuiAvatar-colorDefault{color:#303030;background-color:#757575}.MuiAvatar-rounded{border-radius:4px}.MuiAvatar-square{border-radius:0}.MuiAvatar-img{color:transparent;width:100%;height:100%;-o-object-fit:cover;object-fit:cover;text-align:center;text-indent:10000px}.MuiAvatar-fallback{width:75%;height:75%}.MuiButtonBase-root{color:inherit;border:0;cursor:pointer;margin:0;display:inline-flex;outline:0;padding:0;position:relative;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:0;vertical-align:middle;-moz-appearance:none;justify-content:center;text-decoration:none;background-color:transparent;-webkit-appearance:none;-webkit-tap-highlight-color:transparent}.MuiButtonBase-root::-moz-focus-inner{border-style:none}.MuiButtonBase-root.Mui-disabled{cursor:default;pointer-events:none}@media print{.MuiButtonBase-root{-webkit-print-color-adjust:exact;color-adjust:exact}}.MuiButtonBase-root{color:inherit;border:0;cursor:pointer;margin:0;display:inline-flex;outline:0;padding:0;position:relative;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-radius:0;vertical-align:middle;-moz-appearance:none;justify-content:center;text-decoration:none;background-color:transparent;-webkit-appearance:none;-webkit-tap-highlight-color:transparent}.MuiButtonBase-root::-moz-focus-inner{border-style:none}.MuiButtonBase-root.Mui-disabled{cursor:default;pointer-events:none}@media print{.MuiButtonBase-root{-webkit-print-color-adjust:exact;color-adjust:exact}}.MuiTypography-root{margin:0}.MuiTypography-body2{font-size:.875rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.43;letter-spacing:.01071em}.MuiTypography-body1{font-size:1rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.5;letter-spacing:.00938em}.MuiTypography-caption{font-size:.75rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.66;letter-spacing:.03333em}.MuiTypography-button{font-size:.875rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:500;line-height:1.75;letter-spacing:.02857em;text-transform:uppercase}.MuiTypography-h1{font-size:6rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:300;line-height:1.167;letter-spacing:-.01562em}.MuiTypography-h2{font-size:3.75rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:300;line-height:1.2;letter-spacing:-.00833em}.MuiTypography-h3{font-size:3rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.167;letter-spacing:0}.MuiTypography-h4{font-size:2.125rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.235;letter-spacing:.00735em}.MuiTypography-h5{font-size:1.5rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.334;letter-spacing:0}.MuiTypography-h6{font-size:1.25rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:500;line-height:1.6;letter-spacing:.0075em}.MuiTypography-subtitle1{font-size:1rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:1.75;letter-spacing:.00938em}.MuiTypography-subtitle2{font-size:.875rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:500;line-height:1.57;letter-spacing:.00714em}.MuiTypography-overline{font-size:.75rem;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:400;line-height:2.66;letter-spacing:.08333em;text-transform:uppercase}.MuiTypography-srOnly{width:1px;height:1px;overflow:hidden;position:absolute}.MuiTypography-alignLeft{text-align:left}.MuiTypography-alignCenter{text-align:center}.MuiTypography-alignRight{text-align:right}.MuiTypography-alignJustify{text-align:justify}.MuiTypography-noWrap{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.MuiTypography-gutterBottom{margin-bottom:.35em}.MuiTypography-paragraph{margin-bottom:16px}.MuiTypography-colorInherit{color:inherit}.MuiTypography-colorPrimary{color:#3f51b5}.MuiTypography-colorSecondary{color:#f50057}.MuiTypography-colorTextPrimary{color:rgba(0,0,0,.87)}.MuiTypography-colorTextSecondary{color:rgba(0,0,0,.54)}.MuiTypography-colorError{color:#f44336}.MuiTypography-displayInline{display:inline}.MuiTypography-displayBlock{display:block}.MuiButton-root{color:rgba(0,0,0,.87);padding:6px 16px;font-size:.875rem;min-width:64px;box-sizing:border-box;transition:background-color 250ms cubic-bezier(.4,0,.2,1) 0s,box-shadow 250ms cubic-bezier(.4,0,.2,1) 0s,border 250ms cubic-bezier(.4,0,.2,1) 0s;font-family:Roboto,Helvetica,Arial,sans-serif;font-weight:500;line-height:1.75;border-radius:4px;letter-spacing:.02857em;text-transform:uppercase}.MuiButton-root:hover{text-decoration:none;background-color:rgba(0,0,0,.04)}.MuiButton-root.Mui-disabled{color:rgba(0,0,0,.26)}@media (hover:none){.MuiButton-root:hover{background-color:transparent}}.MuiButton-root:hover.Mui-disabled{background-color:transparent}.MuiButton-label{width:100%;display:inherit;align-items:inherit;justify-content:inherit}.MuiButton-text{padding:6px 8px}.MuiButton-textPrimary{color:#3f51b5}.MuiButton-textPrimary:hover{background-color:rgba(63,81,181,.04)}@media (hover:none){.MuiButton-textPrimary:hover{background-color:transparent}}.MuiButton-textSecondary{color:#f50057}.MuiButton-textSecondary:hover{background-color:rgba(245,0,87,.04)}@media (hover:none){.MuiButton-textSecondary:hover{background-color:transparent}}.MuiButton-outlined{border:1px solid rgba(0,0,0,.23);padding:5px 15px}.MuiButton-outlined.Mui-disabled{border:1px solid rgba(0,0,0,.12)}.MuiButton-outlinedPrimary{color:#3f51b5;border:1px solid rgba(63,81,181,.5)}.MuiButton-outlinedPrimary:hover{border:1px solid #3f51b5;background-color:rgba(63,81,181,.04)}@media (hover:none){.MuiButton-outlinedPrimary:hover{background-color:transparent}}.MuiButton-outlinedSecondary{color:#f50057;border:1px solid rgba(245,0,87,.5)}.MuiButton-outlinedSecondary:hover{border:1px solid #f50057;background-color:rgba(245,0,87,.04)}.MuiButton-outlinedSecondary.Mui-disabled{border:1px solid rgba(0,0,0,.26)}@media (hover:none){.MuiButton-outlinedSecondary:hover{background-color:transparent}}.MuiButton-contained{color:rgba(0,0,0,.87);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);background-color:#e0e0e0}.MuiButton-contained:hover{box-shadow:0 2px 4px -1px rgba(0,0,0,.2),0 4px 5px 0 rgba(0,0,0,.14),0 1px 10px 0 rgba(0,0,0,.12);background-color:#d5d5d5}.MuiButton-contained.Mui-focusVisible{box-shadow:0 3px 5px -1px rgba(0,0,0,.2),0 6px 10px 0 rgba(0,0,0,.14),0 1px 18px 0 rgba(0,0,0,.12)}.MuiButton-contained:active{box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.MuiButton-contained.Mui-disabled{color:rgba(0,0,0,.26);box-shadow:none;background-color:rgba(0,0,0,.12)}@media (hover:none){.MuiButton-contained:hover{box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);background-color:#e0e0e0}}.MuiButton-contained:hover.Mui-disabled{background-color:rgba(0,0,0,.12)}.MuiButton-containedPrimary{color:#fff;background-color:#3f51b5}.MuiButton-containedPrimary:hover{background-color:#303f9f}@media (hover:none){.MuiButton-containedPrimary:hover{background-color:#3f51b5}}.MuiButton-containedSecondary{color:#fff;background-color:#f50057}.MuiButton-containedSecondary:hover{background-color:#c51162}@media (hover:none){.MuiButton-containedSecondary:hover{background-color:#f50057}}.MuiButton-disableElevation{box-shadow:none}.MuiButton-disableElevation:hover{box-shadow:none}.MuiButton-disableElevation.Mui-focusVisible{box-shadow:none}.MuiButton-disableElevation:active{box-shadow:none}.MuiButton-disableElevation.Mui-disabled{box-shadow:none}.MuiButton-colorInherit{color:inherit;border-color:currentColor}.MuiButton-textSizeSmall{padding:4px 5px;font-size:.8125rem}.MuiButton-textSizeLarge{padding:8px 11px;font-size:.9375rem}.MuiButton-outlinedSizeSmall{padding:3px 9px;font-size:.8125rem}.MuiButton-outlinedSizeLarge{padding:7px 21px;font-size:.9375rem}.MuiButton-containedSizeSmall{padding:4px 10px;font-size:.8125rem}.MuiButton-containedSizeLarge{padding:8px 22px;font-size:.9375rem}.MuiButton-fullWidth{width:100%}.MuiButton-startIcon{display:inherit;margin-left:-4px;margin-right:8px}.MuiButton-startIcon.MuiButton-iconSizeSmall{margin-left:-2px}.MuiButton-endIcon{display:inherit;margin-left:8px;margin-right:-4px}.MuiButton-endIcon.MuiButton-iconSizeSmall{margin-right:-2px}.MuiButton-iconSizeSmall>:first-child{font-size:18px}.MuiButton-iconSizeMedium>:first-child{font-size:20px}.MuiButton-iconSizeLarge>:first-child{font-size:22px}.MuiChip-root{color:#fff;border:none;cursor:default;height:32px;display:inline-flex;outline:0;padding:0;font-size:.8125rem;box-sizing:border-box;transition:background-color .3s cubic-bezier(.4,0,.2,1) 0s,box-shadow .3s cubic-bezier(.4,0,.2,1) 0s;align-items:center;font-family:Roboto,Helvetica,Arial,sans-serif;white-space:nowrap;border-radius:16px;vertical-align:middle;justify-content:center;text-decoration:none;background-color:#616161}.MuiChip-root.Mui-disabled{opacity:.5;pointer-events:none}.MuiChip-root .MuiChip-avatar{color:#e0e0e0;width:24px;height:24px;font-size:.75rem;margin-left:5px;margin-right:-6px}.MuiChip-root .MuiChip-avatarColorPrimary{color:#fff;background-color:#303f9f}.MuiChip-root .MuiChip-avatarColorSecondary{color:#fff;background-color:#c51162}.MuiChip-root .MuiChip-avatarSmall{width:18px;height:18px;font-size:.625rem;margin-left:4px;margin-right:-4px}.MuiChip-sizeSmall{height:24px}.MuiChip-colorPrimary{color:#fff;background-color:#3f51b5}.MuiChip-colorSecondary{color:#fff;background-color:#f50057}.MuiChip-clickable{cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.MuiChip-clickable:focus,.MuiChip-clickable:hover{background-color:#6d6d6d}.MuiChip-clickable:active{box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.MuiChip-clickableColorPrimary:focus,.MuiChip-clickableColorPrimary:hover{background-color:#4e5eba}.MuiChip-clickableColorSecondary:focus,.MuiChip-clickableColorSecondary:hover{background-color:#f51464}.MuiChip-deletable:focus{background-color:#6d6d6d}.MuiChip-deletableColorPrimary:focus{background-color:#6573c3}.MuiChip-deletableColorSecondary:focus{background-color:#f73378}.MuiChip-outlined{border:1px solid rgba(255,255,255,.23);background-color:transparent}.MuiChip-clickable.MuiChip-outlined:focus,.MuiChip-clickable.MuiChip-outlined:hover,.MuiChip-deletable.MuiChip-outlined:focus{background-color:rgba(255,255,255,.08)}.MuiChip-outlined .MuiChip-avatar{margin-left:4px}.MuiChip-outlined .MuiChip-avatarSmall{margin-left:2px}.MuiChip-outlined .MuiChip-icon{margin-left:4px}.MuiChip-outlined .MuiChip-iconSmall{margin-left:2px}.MuiChip-outlined .MuiChip-deleteIcon{margin-right:5px}.MuiChip-outlined .MuiChip-deleteIconSmall{margin-right:3px}.MuiChip-outlinedPrimary{color:#3f51b5;border:1px solid #3f51b5}.MuiChip-clickable.MuiChip-outlinedPrimary:focus,.MuiChip-clickable.MuiChip-outlinedPrimary:hover,.MuiChip-deletable.MuiChip-outlinedPrimary:focus{background-color:rgba(63,81,181,.08)}.MuiChip-outlinedSecondary{color:#f50057;border:1px solid #f50057}.MuiChip-clickable.MuiChip-outlinedSecondary:focus,.MuiChip-clickable.MuiChip-outlinedSecondary:hover,.MuiChip-deletable.MuiChip-outlinedSecondary:focus{background-color:rgba(245,0,87,.08)}.MuiChip-icon{color:#e0e0e0;margin-left:5px;margin-right:-6px}.MuiChip-iconSmall{width:18px;height:18px;margin-left:4px;margin-right:-4px}.MuiChip-iconColorPrimary{color:inherit}.MuiChip-iconColorSecondary{color:inherit}.MuiChip-label{overflow:hidden;white-space:nowrap;padding-left:12px;padding-right:12px;text-overflow:ellipsis}.MuiChip-labelSmall{padding-left:8px;padding-right:8px}.MuiChip-deleteIcon{color:rgba(255,255,255,.26);width:22px;cursor:pointer;height:22px;margin:0 5px 0 -6px;-webkit-tap-highlight-color:transparent}.MuiChip-deleteIcon:hover{color:rgba(255,255,255,.4)}.MuiChip-deleteIconSmall{width:16px;height:16px;margin-left:-4px;margin-right:4px}.MuiChip-deleteIconColorPrimary{color:rgba(255,255,255,.7)}.MuiChip-deleteIconColorPrimary:active,.MuiChip-deleteIconColorPrimary:hover{color:#fff}.MuiChip-deleteIconColorSecondary{color:rgba(255,255,255,.7)}.MuiChip-deleteIconColorSecondary:active,.MuiChip-deleteIconColorSecondary:hover{color:#fff}.MuiChip-deleteIconOutlinedColorPrimary{color:rgba(63,81,181,.7)}.MuiChip-deleteIconOutlinedColorPrimary:active,.MuiChip-deleteIconOutlinedColorPrimary:hover{color:#3f51b5}.MuiChip-deleteIconOutlinedColorSecondary{color:rgba(245,0,87,.7)}.MuiChip-deleteIconOutlinedColorSecondary:active,.MuiChip-deleteIconOutlinedColorSecondary:hover{color:#f50057}.MuiDrawer-docked{flex:0 0 auto}.MuiDrawer-paper{top:0;flex:1 0 auto;height:100%;display:flex;outline:0;z-index:1200;position:fixed;overflow-y:auto;flex-direction:column;-webkit-overflow-scrolling:touch}.MuiDrawer-paperAnchorLeft{left:0;right:auto}.MuiDrawer-paperAnchorRight{left:auto;right:0}.MuiDrawer-paperAnchorTop{top:0;left:0;right:0;bottom:auto;height:auto;max-height:100%}.MuiDrawer-paperAnchorBottom{top:auto;left:0;right:0;bottom:0;height:auto;max-height:100%}.MuiDrawer-paperAnchorDockedLeft{border-right:1px solid rgba(0,0,0,.12)}.MuiDrawer-paperAnchorDockedTop{border-bottom:1px solid rgba(0,0,0,.12)}.MuiDrawer-paperAnchorDockedRight{border-left:1px solid rgba(0,0,0,.12)}.MuiDrawer-paperAnchorDockedBottom{border-top:1px solid rgba(0,0,0,.12)}.MuiToolbar-root{display:flex;position:relative;align-items:center}.MuiToolbar-gutters{padding-left:16px;padding-right:16px}@media (min-width:600px){.MuiToolbar-gutters{padding-left:24px;padding-right:24px}}.MuiToolbar-regular{min-height:56px}@media (min-width:0px) and (orientation:landscape){.MuiToolbar-regular{min-height:48px}}@media (min-width:600px){.MuiToolbar-regular{min-height:64px}}.MuiToolbar-dense{min-height:48px}.jss120{background-color:#fff}.jss1{height:86px;overflow:hidden;background:#663399;font-family:Source Sans Pro,Helvetica,Arial,sans-serif;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;border-bottom:1px solid rgba(50,50,50,.5);justify-content:center;text-decoration:none}.jss41{height:96%}.jss46{max-width:48px;min-width:48px;max-height:48px;min-height:48px;margin-right:2em}.jss89{align-items:baseline;font-family:inherit}.jss79{width:32px;height:32px}</style><link as="script" rel="preload" href="/blog/webpack-runtime-68ebc8805482afd56a55.js"/><link as="script" rel="preload" href="/blog/framework-760826a8d97e681b6d2c.js"/><link as="script" rel="preload" href="/blog/app-14d25a46968a3c2b56f1.js"/><link as="script" rel="preload" href="/blog/styles-c2fe8482057191dca484.js"/><link as="script" rel="preload" href="/blog/commons-c87939d66181bb0ac368.js"/><link as="script" rel="preload" href="/blog/530275e58203fbd3f547d44d34265e339f2a60ee-702422cc019cc7fbae4b.js"/><link as="script" rel="preload" href="/blog/18d2a1d1bd11dfeb160d0f057d2a379edc7a722f-715d20d2b55ae16f8940.js"/><link as="script" rel="preload" href="/blog/component---src-templates-haskell-js-30289d0cce2065e4a20c.js"/><link as="fetch" rel="preload" href="/blog/page-data/haskell/functors&amp;ApplicativeFunctors/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/sq/d/3649515864.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/sq/d/49750724.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/sq/d/63159454.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/blog/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><header class="MuiPaper-root MuiAppBar-root MuiAppBar-positionStatic MuiAppBar-colorPrimary jss1 MuiPaper-elevation4" style="background-image:url(/blog/static/e2fc27e9a595aba180863dee8aba2e7b/b8745/haskell-header.png);background-size:cover"><div class="MuiToolbar-root MuiToolbar-regular jss41 MuiToolbar-gutters"><button class="MuiButtonBase-root MuiButton-root MuiButton-text jss46 MuiButton-colorInherit" tabindex="0" type="button" edge="start" aria-label="menu"><span class="MuiButton-label"><svg class="MuiSvgIcon-root jss79" focusable="false" viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M21,15.61L19.59,17L14.58,12L19.59,7L21,8.39L17.44,12L21,15.61M3,6H16V8H3V6M3,13V11H13V13H3M3,18V16H16V18H3Z"></path></svg></span></button><h2 class="MuiTypography-root jss89 default-wrapper  MuiTypography-h2"><a id="head" href="/blog/">Allen Lee@Blog</a><a href="/blog/tags/haskell"><div style="display:inline-flex;color:#fff;margin-left:5rem;flex-direction:column"><img alt="haskell-logo" src="/blog/static/ee1ae3d6f2df9f1582f5de243d7ef20c/83922/haskell-logo.png" style="font-size:45px;width:288px;height:45px;filter:hue-rotate(180deg) invert(1)"/><h6>An advanced, purely functional programming language</h6></div></a></h2></div></header><div style="margin:0 auto;padding-top:0;height:calc(100vh - 86px);overflow-y:auto;overflow-x:hidden"><main><div class="haskell-post"><h1>Functors, Applicative Functors</h1><ul style="margin:1rem 0"><div class="MuiButtonBase-root MuiChip-root MuiChip-colorPrimary MuiChip-clickableColorPrimary MuiChip-clickable" tabindex="0" role="button"><div class="MuiAvatar-root MuiAvatar-circle MuiChip-avatar MuiChip-avatarColorPrimary MuiAvatar-colorDefault">h</div><span class="MuiChip-label">haskell</span></div></ul><p>Haskell 的一些特色，像是纯粹性，高阶函数，algebraic data types，typeclasses，这些让我们可以从更高的角度来看到 polymorphism 这件事。不像 OOP 当中需要从庞大的型态阶层来思考。我们只需要看看手边的型态的行为，将他们跟适当地 typeclass 对应起来就可以了。像 Int 的行为跟很多东西很像。好比说他可以比较相不相等，可以从大到小排列，也可以将他们一一穷举出来。</p><p>Typeclass 的运用是很随意的。我们可以定义自己的资料型态，然后描述他可以怎样被操作，跟 typeclass 关联起来便定义了他的行为。由于 Haskell 强大的型态系统，这让我们只要读函数的型态宣告就可以知道很多资讯。typeclass 可以定义得很抽象很 general。我们之前有看过 typeclass 定义了可以比较两个东西是否相等，或是定义了可以比较两个东西的大小。这些是既抽象但又描述简洁的行为，但我们不会认为他们有什么特别之处，因为我们时常碰到他们。最近我们看过了 functor，基本上他们是一群可以被 map over 的物件。这是其中一个例子能够抽象但又漂亮地描述行为。在这一章中，我们会详加阐述 functors，并会提到比较强一些的版本，也就是 applicative functors。我们也会提到 monoids。</p><p>温习 Functors</p><p>我们已经在之前的章节提到 functors。如果你还没读那个章节，也许你应该先去看看。或是你直接假装你已经读过了。</p><p>来快速复习一下：Functors 是可以被 map over 的物件，像是 lists，Maybe，trees 等等。在 Haskell 中我们是用 Functor 这个 typeclass 来描述他。这个 typeclass 只有一个 method，叫做 fmap，他的型态是 fmap :: (a -&gt; b) -&gt; f a -&gt; f b。这型态说明了如果给我一个从 a 映到 b 的函数，以及一个装了 a 的盒子，我会回给你一个装了 b 的盒子。就好像用这个函数将每个元素都转成 b 一样</p><p><em>给一点建议</em>。这盒子的比喻尝试让你抓到些 functors 是如何运作的感觉。在之后我们也会用相同的比喻来比喻 applicative functors 跟 monads。在多数情况下这种比喻是恰当的，但不要过度引申，有些 functors 是不适用这个比喻的。一个比较正确的形容是 functors 是一个计算语境（computational context）。这个语境可能是这个 computation 可能带有值，或是有可能会失败（像 <code class="language-text">Maybe</code> 跟 <code class="language-text">Either a</code>），或是他可能有多个值（像 lists），等等。
如果一个 type constructor 要是 Functor 的 instance，那他的 kind 必须是 <em> -&gt; </em>，这代表他必须刚好接受一个 type 当作 type parameter。像是 Maybe 可以是 Functor 的一个 instance，因为他接受一个 type parameter，来做成像是 Maybe Int，或是 Maybe String。如果一个 type constructor 接受两个参数，像是 Either，我们必须给他两个 type parameter。所以我们不能这样写：instance Functor Either where，但我们可以写 instance Functor (Either a) where，如果我们把 fmap 限缩成只是 Either a 的，那他的型态就是 fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c。就像你看到的，Either a 的是固定的一部分，因为 Either a 只恰好接受一个 type parameter，但 Either 则要接受两个 type parameters。这样 fmap 的型态变成 fmap :: (b -&gt; c) -&gt; Either b -&gt; Either c，这不太合理。</p><p>我们知道有许多型态都是 Functor 的 instance，像是 []，Maybe，Either a 以及我们自己写的 Tree。我们也看到了如何用一个函数 map 他们。在这一章节，我们再多举两个例子，也就是 IO 跟 (-&gt;) r。</p><p>如果一个值的型态是 IO String，他代表的是一个会被计算成 String 结果的 I/O action。我们可以用 do syntax 来把结果绑定到某个名称。我们之前把 I/O action 比喻做长了脚的盒子，会到真实世界帮我们取一些值回来。我们可以检视他们取了什么值，但一旦看过，我们必须要把值放回盒子中。用这个比喻，IO 的行为就像是一个 functor。</p><p>我们来看看 IO 是怎么样的一个 Functor instance。当我们 fmap 用一个 function 来 map over I/O action 时，我们会想要拿回一个装着已经用 function 映射过值的 I/O action。</p><p>instance Functor IO where
fmap f action = do
result &lt;- action
return (f result)
对一个 I/O action 做 map over 动作的结果仍会是一个 I/O action，所以我们才用 do syntax 来把两个 I/O action 黏成一个。在 fmap 的实作中，我们先执行了原本传进的 I/O action，并把结果绑定成 result。然后我们写了 return (f result)。return 就如你所知道的，是一个只会回传包了你传给他东西的 I/O action。还有一个 do block 的回传值一定是他最后一个 I/O action 的回传值。这也是为什么我们需要 return。其实他只是回传包了 f result 的 I/O action。</p><p>我们可以再多实验一下来找到些感觉。来看看这段 code：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>   
        <span class="token keyword">let</span> <span class="token hvariable">line</span>&#x27; <span class="token operator">=</span> <span class="token builtin">reverse</span> <span class="token hvariable">line</span>  
        <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">&quot;You said &quot;</span> <span class="token operator">++</span> <span class="token hvariable">line</span>&#x27; <span class="token operator">++</span> <span class="token string">&quot; backwards!&quot;</span>  
        <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">&quot;Yes, you really said&quot;</span> <span class="token operator">++</span> <span class="token hvariable">line</span>&#x27; <span class="token operator">++</span> <span class="token string">&quot; backwards!&quot;</span>  </code></pre></div><p>这程式要求使用者输入一行文字，然后印出一行反过来的。 我们可以用 fmap 来改写：</p><p>main = do line &lt;- fmap reverse getLine<br/>
<!-- -->putStrLn <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">&quot;</mi><mi>Y</mi><mi>o</mi><mi>u</mi><mi>s</mi><mi>a</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">&quot;</mi><mo>+</mo><mo>+</mo><mi>l</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>+</mo><mo>+</mo><mi mathvariant="normal">&quot;</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>w</mi><mi>a</mi><mi>r</mi><mi>d</mi><mi>s</mi><mo stretchy="false">!</mo><mi mathvariant="normal">&quot;</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>L</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">&quot;You said &quot; ++ line ++ &quot; backwards!&quot;  
            putStrLn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.22222em">Y</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em"></span><span class="mord">+</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord">+</span><span class="mord">&quot;</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em">k</span><span class="mord mathdefault" style="margin-right:0.02691em">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault">s</span><span class="mclose">!</span><span class="mord">&quot;</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05764em">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">L</span><span class="mord mathdefault">n</span></span></span></span> &quot;Yes, you really said&quot; ++ line ++ &quot; backwards!&quot;  </p><p>就像我们用 fmap reverse 来 map over Just &quot;blah&quot; 会得到 Just &quot;halb&quot;，我们也可以 fmap reverse 来 map over getLine。getLine 是一个 I/O action，他的 type 是 IO String，而用 reverse 来 map over 他会回传一个取回一个字串并 reverse 他的 I/O action。就像我们 apply 一个 function 到一个 Maybe 一样，我们也可以 apply 一个 function 到一个 IO，只是这个 IO 会跑去外面拿回某些值。然后我们把结果用 &lt;- 绑定到某个名称，而这个名称绑定的值是已经 reverse 过了。</p><p>而 fmap (++&quot;!&quot;) getLine 这个 I/O action 表现得就像 getLine，只是他的结果多了一个 &quot;!&quot; 在最后。</p><p>如果我们限缩 fmap 到 IO 型态上，那 fmap 的型态是 fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b。fmap 接受一个函数跟一个 I/O action，并回传一个 I/O action 包含了已经 apply 过 function 的结果。</p><p>如果你曾经注意到你想要将一个 I/O action 绑定到一个名称上，只是为了要 apply 一个 function。你可以考虑使用 fmap，那会更漂亮地表达这件事。或者你想要对 functor 中的资料做 transformation，你可以先将你要用的 function 写在 top level，或是把他作成一个 lambda function，甚至用 function composition。</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token import_statement"><span class="token keyword">import</span> Data.Char</span>  
<span class="token import_statement"><span class="token keyword">import</span> Data.List</span>  

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">intersperse</span> <span class="token char">&#x27;-&#x27;</span><span class="token operator"> . </span><span class="token builtin">reverse</span><span class="token operator"> . </span><span class="token builtin">map</span> <span class="token builtin">toUpper</span><span class="token punctuation">)</span> <span class="token builtin">getLine</span>  
          <span class="token builtin">putStrLn</span> <span class="token hvariable">line</span>  
<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">fmapping_io</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>  
<span class="token hvariable">hello</span> <span class="token hvariable">there</span>  
<span class="token constant">E</span><span class="token operator">-</span><span class="token constant">R</span><span class="token operator">-</span><span class="token constant">E</span><span class="token operator">-</span><span class="token constant">H</span><span class="token operator">-</span><span class="token constant">T</span><span class="token operator">-</span> <span class="token operator">-</span><span class="token constant">O</span><span class="token operator">-</span><span class="token constant">L</span><span class="token operator">-</span><span class="token constant">L</span><span class="token operator">-</span><span class="token constant">E</span><span class="token operator">-</span><span class="token constant">H</span> </code></pre></div><p>正如你想的，intersperse &#x27;-&#x27; . reverse . map toUpper 合成了一个 function，他接受一个字串，将他转成大写，然后反过来，再用 intersperse &#x27;-&#x27; 安插&#x27;-&#x27;。他是比较漂亮版本的 (\xs -&gt; intersperse &#x27;-&#x27; (reverse (map toUpper xs)))。</p><p>另一个 Functor 的案例是 (-&gt;) r，只是我们先前没有注意到。你可能会困惑到底 (-&gt;) r 究竟代表什么？一个 r -&gt; a 的型态可以写成 (-&gt;) r a，就像是 2 + 3 可以写成 (+) 2 3 一样。我们可以从一个不同的角度来看待 (-&gt;) r a，他其实只是一个接受两个参数的 type constructor，好比 Either。但记住我们说过 Functor 只能接受一个 type constructor。这也是为什么 (-&gt;) 不是 Functor 的一个 instance，但 (-&gt;) r 则是。如果程式的语法允许的话，你也可以将 (-&gt;) r 写成 (r -&gt;)。就如 (2+) 代表的其实是 (+) 2。至于细节是如何呢？我们可以看看 Control.Monad.Instances。</p><p>我们通常说一个接受任何东西以及回传随便一个东西的函数型态是 <code class="language-text">a -&gt; b</code>。<code class="language-text">r -&gt; a</code> 是同样意思，只是把符号代换了一下。
instance Functor ((-&gt;) r) where<br/>
<!-- -->fmap f g = (\x -&gt; f (g x))<br/>
<!-- -->如果语法允许的话，他可以被写成</p><p>instance Functor (r -&gt;) where<br/>
<!-- -->fmap f g = (\x -&gt; f (g x))<br/>
<!-- -->但其实是不允许的，所以我们必须写成第一种的样子。</p><p>首先我们来看看 fmap 的型态。他的型态是 fmap :: (a -&gt; b) -&gt; f a -&gt; f b。我们把所有的 f 在心里代换成 (-&gt;) r。则 fmap 的型态就变成 fmap :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)。接着我们把 (-&gt;) r a 跟 (-&gt;) r b 换成 r -&gt; a 跟 r -&gt; b。则我们得到 fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)。</p><p>从上面的结果看到将一个 function map over 一个 function 会得到另一个 function，就如 map over 一个 function 到 Maybe 会得到一个 Maybe，而 map over 一个 function 到一个 list 会得到一个 list。而 fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b) 告诉我们什么？他接受一个从 a 到 b 的 function，跟一个从 r 到 a 的 function，并回传一个从 r 到 b 的 function。这根本就是 function composition。把 r -&gt; a 的输出接到 a -&gt; b 的输入，的确是 function composition 在做的事。如果你再仔细看看 instance 的定义，会发现真的就是一个 function composition。</p><p>instance Functor ((-&gt;) r) where<br/>
<!-- -->fmap = (.)<br/>
<!-- -->这很明显就是把 fmap 当 composition 在用。可以用 :m + Control.Monad.Instances 把模组装载进来，并做一些尝试。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> :t fmap <span class="token punctuation">(</span>*3<span class="token punctuation">)</span> <span class="token punctuation">(</span>+100<span class="token punctuation">)</span>  
fmap <span class="token punctuation">(</span>*3<span class="token punctuation">)</span> <span class="token punctuation">(</span>+100<span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Num a<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> a  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>*3<span class="token punctuation">)</span> <span class="token punctuation">(</span>+100<span class="token punctuation">)</span> <span class="token number">1</span>  
<span class="token number">303</span>  
ghci<span class="token operator">&gt;</span> <span class="token punctuation">(</span>*3<span class="token punctuation">)</span> <span class="token variable"><span class="token variable">`</span>fmap<span class="token variable">`</span></span> <span class="token punctuation">(</span>+100<span class="token punctuation">)</span> $ <span class="token number">1</span>  
<span class="token number">303</span>  
ghci<span class="token operator">&gt;</span> <span class="token punctuation">(</span>*3<span class="token punctuation">)</span> <span class="token builtin class-name">.</span> <span class="token punctuation">(</span>+100<span class="token punctuation">)</span> $ <span class="token number">1</span>  
<span class="token number">303</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>show <span class="token builtin class-name">.</span> <span class="token punctuation">(</span>*3<span class="token punctuation">))</span> <span class="token punctuation">(</span>*100<span class="token punctuation">)</span> <span class="token number">1</span>  
<span class="token string">&quot;300&quot;</span>  </code></pre></div><p>我们呼叫 fmap 的方式是 infix 的方式，这跟 . 很像。在第二行，我们把 (<em>3) map over 到 (+100) 上，这会回传一个先把输入值 (+100) 再 (</em>3) 的 function，我们再用 1 去呼叫他。</p><p>到这边为止盒子的比喻还适用吗？如果你硬是要解释的话还是解释得通。当我们将 fmap (+3) map over Just 3 的时候，对于 Maybe 我们很容易把他想成是装了值的盒子，我们只是对盒子里面的值 (+3)。但对于 fmap (<em>3) (+100) 呢？你可以把 (+100) 想成是一个装了值的盒子。有点像把 I/O action 想成长了脚的盒子一样。对 (+100) 使用 fmap (</em>3) 会产生另一个表现得像 (+100) 的 function。只是在算出值之前，会再多计算 (*3)。这样我们可以看出来 fmap 表现得就像 . 一样。</p><p>fmap 等同于 function composition 这件事对我们来说并不是很实用，但至少是一个有趣的观点。这也让我们打开视野，看到盒子的比喻不是那么恰当，functors 其实比较像 computation。function 被 map over 到一个 computation 会产生经由那个 function 映射过后的 computation。</p><p>在我们继续看 fmap 该遵守的规则之前，我们再看一次 fmap 的型态，他是 fmap :: (a -&gt; b) -&gt; f a -&gt; f b。很明显我们是在讨论 Functor，所以为了简洁，我们就不写 (Functor f) =&gt; 的部份。当我们在学 curry 的时候，我们说过 Haskell 的 function 实际上只接受一个参数。一个型态是 a -&gt; b -&gt; c 的函数实际上是接受 a 然后回传 b -&gt; c，而 b -&gt; c 实际上接受一个 b 然后回传一个 c。如果我们用比较少的参数呼叫一个函数，他就会回传一个函数需要接受剩下的参数。所以 a -&gt; b -&gt; c 可以写成 a -&gt; (b -&gt; c)。这样 curry 可以明显一些。</p><p>同样的，我们可以不要把 fmap 想成是一个接受 function 跟 functor 并回传一个 function 的 function。而是想成一个接受 function 并回传一个新的 function 的 function，回传的 function 接受一个 functor 并回传一个 functor。他接受 a -&gt; b 并回传 f a -&gt; f b。这动作叫做 lifting。我们用 GHCI 的 :t 来做的实验。</p><p>ghci&gt; :t fmap (<em>2)<br/>fmap (</em>2) :: (Num a, Functor f) =&gt; f a -&gt; f a<br/>
<!-- -->ghci&gt; :t fmap (replicate 3)<br/>
<!-- -->fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f <!-- -->[a]<br/>
<!-- -->fmap (*2) 接受一个 functor f，并回传一个基于数字的 functor。那个 functor 可以是 list，可以是 Maybe，可以是 Either String。fmap (replicate 3) 可以接受一个基于任何型态的 functor，并回传一个基于 list 的 functor。</p><p>当我们提到 functor over numbers 的时候，你可以想像他是一个 functor 包含有许多数字在里面。前面一种说法其实比较正确，但后面一种说法比较容易让人理解。
这样的观察在我们只有绑定一个部份套用的函数，像是 fmap (++&quot;!&quot;)，的时候会显得更清楚，</p><p>你可以把 fmap 想做是一个函数，他接受另一个函数跟一个 functor，然后把函数对 functor 每一个元素做映射，或你可以想做他是一个函数，他接受一个函数并把他 lift 到可以在 functors 上面操作。两种想法都是正确的，而且在 Haskell 中是等价。</p><p>fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f <!-- -->[a]<!-- --> 这样的型态代表这个函数可以运作在任何 functor 上。至于确切的行为则要看究竟我们操作的是什么样的 functor。如果我们是用 fmap (replicate 3) 对一个 list 操作，那我们会选择 fmap 针对 list 的实作，也就是只是一个 map。如果我们是碰到 Maybe a。那他在碰到 Just 型态的时候，会对里面的值套用 replicate 3。而碰到 Nothing 的时候就回传 Nothing。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>replicate <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3,4<span class="token punctuation">]</span>  
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1,1</span>,1<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">2,2</span>,2<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">3,3</span>,3<span class="token punctuation">]</span>,<span class="token punctuation">[</span><span class="token number">4,4</span>,4<span class="token punctuation">]</span><span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>replicate <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Just <span class="token number">4</span><span class="token punctuation">)</span>  
Just <span class="token punctuation">[</span><span class="token number">4,4</span>,4<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>replicate <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Right <span class="token string">&quot;blah&quot;</span><span class="token punctuation">)</span>  
Right <span class="token punctuation">[</span><span class="token string">&quot;blah&quot;</span>,<span class="token string">&quot;blah&quot;</span>,<span class="token string">&quot;blah&quot;</span><span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>replicate <span class="token number">3</span><span class="token punctuation">)</span> Nothing  
Nothing  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>replicate <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Left <span class="token string">&quot;foo&quot;</span><span class="token punctuation">)</span>  
Left <span class="token string">&quot;foo&quot;</span>  </code></pre></div><p>接下来我们来看看 functor laws。一个东西要成为 functor，必须要遵守某些定律。不管任何一个 functor 都被要求具有某些性质。他们必须是能被 map over 的。对他们呼叫 fmap 应该是要用一个函数 map 每一个元素，不多做任何事情。这些行为都被 functor laws 所描述。对于 Functor 的 instance 来说，总共两条定律应该被遵守。不过他们不会在 Haskell 中自动被检查，所以你必须自己确认这些条件。</p><p>functor law 的第一条说明，如果我们对 functor 做 map id，那得到的新的 functor 应该要跟原来的一样。如果写得正式一点，他代表 fmap id = id。基本上他就是说对 functor 呼叫 fmap id，应该等同于对 functor 呼叫 id 一样。毕竟 id 只是 identity function，他只会把参数照原样丢出。他也可以被写成 \x -&gt; x。如果我们对 functor 的概念就是可以被 map over 的物件，那 fmap id = id 的性就显而易见。</p><p>我们来看看这个定律的几个案例：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> fmap <span class="token function">id</span> <span class="token punctuation">(</span>Just <span class="token number">3</span><span class="token punctuation">)</span>  
Just <span class="token number">3</span>  
ghci<span class="token operator">&gt;</span> <span class="token function">id</span> <span class="token punctuation">(</span>Just <span class="token number">3</span><span class="token punctuation">)</span>  
Just <span class="token number">3</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token function">id</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span>  
<span class="token punctuation">[</span><span class="token number">1,2</span>,3,4,5<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> <span class="token function">id</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">..</span><span class="token number">5</span><span class="token punctuation">]</span>  
<span class="token punctuation">[</span><span class="token number">1,2</span>,3,4,5<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token function">id</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
<span class="token punctuation">[</span><span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token function">id</span> Nothing  
Nothing  </code></pre></div><p>如果我们看看 Maybe 的 fmap 的实作，我们不难发现第一定律为何被遵守。</p><p>instance Functor Maybe where<br/>
<!-- -->fmap f (Just x) = Just (f x)<br/>
<!-- -->fmap f Nothing = Nothing<br/>
<!-- -->我们可以想像在 f 的位置摆上 id。我们看到 fmap id 拿到 Just x 的时候，结果只不过是 Just (id x)，而 id 有只回传他拿到的东西，所以可以知道 Just (id x) 等价于 Just x。所以说我们可以知道对 Maybe 中的 Just 用 id 去做 map over 的动作，会拿回一样的值。</p><p>而将 id map over Nothing 会拿回 Nothing 并不稀奇。所以从这两个 fmap 的实作，我们可以看到的确 fmap id = id 有被遵守。</p><p>第二定律描述说先将两个函数合成并将结果 map over 一个 functor 的结果，应该跟先将第一个函数 map over 一个 functor，再将第二个函数 map over 那个 functor 的结果是一样的。正式地写下来的话就是 fmap (f . g) = fmap f . fmap g。或是用另外一种写法，对于任何一个 functor F，下面这个式子应该要被遵守：fmap (f . g) F = fmap f (fmap g F)。</p><p>如果我们能够证明某个型别遵守两个定律，那我们就可以保证他跟其他 functor 对于映射方面都拥有相同的性质。我们知道如果对他用 fmap，我们知道不会有除了 mapping 以外的事会发生，而他就仅仅会表现成某个可以被 map over 的东西。也就是一个 functor。你可以再仔细检视 fmap 对于某些型别的实作来了解第二定律。正如我们先前对 Maybe 检视第一定律一般。</p><p>如果你需要的话，我们能在这边演练一下 Maybe 是如何遵守第二定律的。首先 fmap (f . g) 来 map over Nothing 的话，我们会得到 Nothing。因为用任何函数来 fmap Nothing 的话都会回传 Nothing。如果我们 fmap f (fmap g Nothing)，我们会得到 Nothing。可以看到当面对 Nothing 的时候，Maybe 很显然是遵守第二定律的。 那对于 Just something 呢？如果我们使用 fmap (f . g) (Just x) 的话，从实作的程式码中我可以看到 Just ((f . g ) x)，也就是 Just (f (g x))。如果我们使用 fmap f (fmap g (Just x)) 的话我们可以从实作知道 fmap g (Just x) 会是 Just (g x)。fmap f (fmap g (Just x)) 跟 fmap f (Just (g x)) 相等。而从实作上这又会相等于 Just (f (g x))。</p><p>如果你不太理解这边的说明，别担心。只要确定你了解什么是函数合成就好。在多数的情况下你可以直觉地对应到这些型别表现得就像 containers 或函数一样。或是也可以换种方法，只要多尝试对型别中不同的值做操作你就可以看看型别是否有遵守定律。</p><p>我们来看一些经典的例子。这些型别建构子虽然是 Functor 的 instance，但实际上他们并不是 functor，因为他们并不遵守这些定律。我们来看看其中一个型别。</p><p>data CMaybe a = CNothing | CJust Int a deriving (Show)<br/>
<!-- -->C 这边代表的是计数器。他是一种看起来像是 Maybe a 的型别，只差在 Just 包含了两个 field 而不是一个。在 CJust 中的第一个 field 是 Int，他是扮演计数器用的。而第二个 field 则为型别 a，他是从型别参数来的，而他确切的型别当然会依据我们选定的 CMaybe a 而定。我们来对他作些操作来获得些操作上的直觉吧。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> CNothing  
CNothing  
ghci<span class="token operator">&gt;</span> CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span>  
CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span>  
ghci<span class="token operator">&gt;</span> :t CNothing  
CNothing :: CMaybe a  
ghci<span class="token operator">&gt;</span> :t CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span>  
CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span> :: CMaybe <span class="token punctuation">[</span>Char<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> CJust <span class="token number">100</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>  
CJust <span class="token number">100</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>  </code></pre></div><p>如果我们使用 CNothing，就代表不含有 field。如果我们用的是 CJust，那第一个 field 是整数，而第二个 field 可以为任何型别。我们来定义一个 Functor 的 instance，这样每次我们使用 fmap 的时候，函数会被套用在第二个 field，而第一个 field 会被加一。</p><p>instance Functor CMaybe where<br/>
<!-- -->fmap f CNothing = CNothing<br/>
<!-- -->fmap f (CJust counter x) = CJust (counter+1) (f x)<br/>
<!-- -->这种定义方式有点像是 Maybe 的定义方式，只差在当我们使用 fmap 的时候，如果碰到的不是空值，那我们不只会套用函数，还会把计数器加一。我们可以来看一些范例操作。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>++<span class="token string">&quot;ha&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>CJust <span class="token number">0</span> <span class="token string">&quot;ho&quot;</span><span class="token punctuation">)</span>  
CJust <span class="token number">1</span> <span class="token string">&quot;hoha&quot;</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>++<span class="token string">&quot;he&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>fmap <span class="token punctuation">(</span>++<span class="token string">&quot;ha&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>CJust <span class="token number">0</span> <span class="token string">&quot;ho&quot;</span><span class="token punctuation">))</span>  
CJust <span class="token number">2</span> <span class="token string">&quot;hohahe&quot;</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>++<span class="token string">&quot;blah&quot;</span><span class="token punctuation">)</span> CNothing  
CNothing
<span class="token comment">#这些会遵守 functor laws 吗？要知道有不遵守的情形，只要找到一个反例就好了。</span>

ghci<span class="token operator">&gt;</span> fmap <span class="token function">id</span> <span class="token punctuation">(</span>CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span><span class="token punctuation">)</span>  
CJust <span class="token number">1</span> <span class="token string">&quot;haha&quot;</span>  
ghci<span class="token operator">&gt;</span> <span class="token function">id</span> <span class="token punctuation">(</span>CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span><span class="token punctuation">)</span>  
CJust <span class="token number">0</span> <span class="token string">&quot;haha&quot;</span></code></pre></div><p>我们知道 functor law 的第一定律描述当我们用 id 来 map over 一个 functor 的时候，他的结果应该跟只对 functor 呼叫 id 的结果一样。但我们可以看到这个例子中，这对于 CMaybe 并不遵守。尽管他的确是 Functor typeclass 的一个 instace。但他并不遵守 functor law 因此不是一个 functor。如果有人使用我们的 CMaybe 型别，把他当作 functor 用，那他就会期待 functor laws 会被遵守。但 CMaybe 并没办法满足，便会造成错误的程式。当我们使用一个 functor 的时候，函数合成跟 map over 的先后顺序不应该有影响。但对于 CMaybe 他是有影响的，因为他纪录了被 map over 的次数。如果我们希望 CMaybe 遵守 functor law，我们必须要让 Int 栏位在做 fmap 的时候维持不变。</p><p>乍看之下 functor laws 看起来不是很必要，也容易让人搞不懂，但我们知道如果一个型别遵守 functor laws，那我们就能对他作些基本的假设。如果遵守了 functor laws，我们知道对他做 fmap 不会做多余的事情，只是用一个函数做映射而已。这让写出来的程式码足够抽象也容易扩展。因为我们可以用定律来推论型别的行为。</p><p>所有在标准函式库中的 Functor 的 instance 都遵守这些定律，但你可以自己检查一遍。下一次你定义一个型别为 Functor 的 instance 的时候，花点时间确认他确实遵守 functor laws。一旦你操作过足够多的 functors 时，你就会获得直觉，知道他们会有什么样的性质跟行为。而且 functor laws 也会觉得显而易见。但就算没有这些直觉，你仍然可以一行一行地来找看看有没有反例让这些定律失效。</p><p>我们可以把 functor 看作输出具有 context 的值。例如说 Just 3 就是输出 3，但他又带有一个可能没有值的 context。<!-- -->[1,2,3]<!-- --> 输出三个值，1,2 跟 3，同时也带有可能有多个值或没有值的 context。(+3) 则会带有一个依赖于参数的 context。</p><p>如果你把 functor 想做是输出值这件事，那你可以把 map over 一个 functor 这件事想成在 functor 输出的后面再多加一层转换。当我们做 fmap (+3) <!-- -->[1,2,3]<!-- --> 的时候，我们是把 (+3) 接到 <!-- -->[1,2,3]<!-- --> 后面，所以当我们检视任何一个 list 的输出的时候，(+3) 也会被套用在上面。另一个例子是对函数做 map over。当我们做 fmap (+3) (<em>3)，我们是把 (+3) 这个转换套用在 (</em>3) 后面。这样想的话会很自然就会把 fmap 跟函数合成关联起来（fmap (+3) (<em>3) 等价于 (+3) . (</em>3)，也等价于 \x -&gt; ((x<em>3)+3)），毕竟我们是接受一个函数 (</em>3) 然后套用 (+3) 转换。最后的结果仍然是一个函数，只是当我们喂给他一个数字的时候，他会先乘上三然后做转换加上三。这基本上就是函数合成在做的事。</p><h2 id="Applicative-functors" style="position:relative">Applicative functors<a href="#Applicative-functors" aria-label="Applicative functors permalink" class="anchor after"><svg aria-hidden="true" focusable="false" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a></h2><p>在这个章节中，我们会学到 applicative functors，也就是加强版的 functors，在 Haskell 中是用在 Control.Applicative 中的 Applicative 这个 typeclass 来定义的。</p><p>你还记得 Haskell 中函数预设就是 Curried 的，那代表接受多个参数的函数实际上是接受一个参数然后回传一个接受剩余参数的函数，以此类推。如果一个函数的型别是 a -&gt; b -&gt; c，我们通常会说这个函数接受两个参数并回传 c，但他实际上是接受 a 并回传一个 b -&gt; c 的函数。这也是为什么我们可以用 (f x) y 的方式呼叫 f x y。这个机制让我们可以 partially apply 一个函数，可以用比较少的参数呼叫他们。可以做成一个函数再喂给其他函数。</p><p>到目前为止，当我们要对 functor map over 一个函数的时候，我们用的函数都是只接受一个参数的。但如果我们要 map 一个接受两个参数的函数呢？我们来看几个具体的例子。如果我们有 Just 3 然后我们做 fmap (<!-- -->*<!-- -->) (Just 3)，那我们会获得什么样的结果？从 Maybe 对 Functor 的 instance 实作来看，我们知道如果他是 Just something，他会对在 Just 中的 something 做映射。因此当 fmap (<!-- -->*<!-- -->) (Just 3) 会得到 Just ((<!-- -->*<!-- -->) 3)，也可以写做 Just (* 3)。我们得到了一个包在 Just 中的函数。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> :t fmap <span class="token punctuation">(</span>++<span class="token punctuation">)</span> <span class="token punctuation">(</span>Just <span class="token string">&quot;hey&quot;</span><span class="token punctuation">)</span>  
fmap <span class="token punctuation">(</span>++<span class="token punctuation">)</span> <span class="token punctuation">(</span>Just <span class="token string">&quot;hey&quot;</span><span class="token punctuation">)</span> :: Maybe <span class="token punctuation">(</span><span class="token punctuation">[</span>Char<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>Char<span class="token punctuation">]</span><span class="token punctuation">)</span>  
ghci<span class="token operator">&gt;</span> :t fmap compare <span class="token punctuation">(</span>Just <span class="token string">&#x27;a&#x27;</span><span class="token punctuation">)</span>  
fmap compare <span class="token punctuation">(</span>Just <span class="token string">&#x27;a&#x27;</span><span class="token punctuation">)</span> :: Maybe <span class="token punctuation">(</span>Char -<span class="token operator">&gt;</span> Ordering<span class="token punctuation">)</span>  
ghci<span class="token operator">&gt;</span> :t fmap compare <span class="token string">&quot;A LIST OF CHARS&quot;</span>  
fmap compare <span class="token string">&quot;A LIST OF CHARS&quot;</span> :: <span class="token punctuation">[</span>Char -<span class="token operator">&gt;</span> Ordering<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> :t fmap <span class="token punctuation">(</span><span class="token punctuation">\</span>x y z -<span class="token operator">&gt;</span> x + y / z<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3,4</span>,5,6<span class="token punctuation">]</span>  
fmap <span class="token punctuation">(</span><span class="token punctuation">\</span>x y z -<span class="token operator">&gt;</span> x + y / z<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3,4</span>,5,6<span class="token punctuation">]</span> :: <span class="token punctuation">(</span>Fractional a<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>a -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> a<span class="token punctuation">]</span></code></pre></div><p>如果我们 map compare 到一个包含许多字元的 list 呢？他的型别是 (Ord a) =&gt; a -&gt; a -&gt; Ordering，我们会得到包含许多 Char -&gt; Ordering 型别函数的 list，因为 compare 被 partially apply 到 list 中的字元。他不是包含许多 (Ord a) =&gt; a -&gt; Ordering 的函数，因为第一个 a 碰到的型别是 Char，所以第二个 a 也必须是 Char。</p><p>我们看到如何用一个多参数的函数来 map functor，我们会得到一个包含了函数的 functor。那现在我们能对这个包含了函数的 functor 做什么呢？我们能用一个吃这些函数的函数来 map over 这个 functor，这些在 functor 中的函数都会被当作参数丢给我们的函数。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> a <span class="token operator">=</span> fmap <span class="token punctuation">(</span>*<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3,4<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> :t a  
a :: <span class="token punctuation">[</span>Integer -<span class="token operator">&gt;</span> Integer<span class="token punctuation">]</span>  
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span><span class="token punctuation">\</span>f -<span class="token operator">&gt;</span> f <span class="token number">9</span><span class="token punctuation">)</span> a  
<span class="token punctuation">[</span><span class="token number">9,18</span>,27,36<span class="token punctuation">]</span>  </code></pre></div><p>但如果我们的有一个 functor 里面是 Just (3 <em>) 还有另一个 functor 里面是 Just 5，但我们想要把第一个 Just (3 </em>) map over Just 5 呢？如果是普通的 functor，那就没救了。因为他们只允许 map 一个普通的函数。即使我们用 \f -&gt; f 9 来 map 一个装了很多函数的 functor，我们也是使用了普通的函数。我们是无法单纯用 fmap 来把包在一个 functor 的函数 map 另一个包在 functor 中的值。我们能用模式匹配 Just 来把函数从里面抽出来，然后再 map Just 5，但我们是希望有一个一般化的作法，对任何 functor 都有效。</p><p>我们来看看 Applicative 这个 typeclass。他位在 Control.Applicative 中，在其中定义了两个函数 pure 跟 &lt;*&gt;。他并没有提供预设的实作，如果我们想使用他必须要为他们 applicative functor 的实作。typeclass 定义如下：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Applicative</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>  
    <span class="token hvariable">pure</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>  
    <span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>  </code></pre></div><p>这简简单单的三行可以让我们学到不少。首先来看第一行。他开启了 Applicative 的定义，并加上 class contraint。描述了一个型别构造子要是 Applicative，他必须也是 Functor。这就是为什么我们说一个型别构造子属于 Applicative 的话，他也会是 Functor，因此我们能对他使用 fmap。</p><p>第一个定义的是 pure。他的型别宣告是 pure :: a -&gt; f a。f 代表 applicative functor 的 instance。由于 Haskell 有一个优秀的型别系统，其中函数又是将一些参数映射成结果，我们可以从型别宣告中读出许多讯息。pure 应该要接受一个值，然后回传一个包含那个值的 applicative functor。我们这边是用盒子来作比喻，即使有一些比喻不完全符合现实的情况。尽管这样，a -&gt; f a 仍有许多丰富的资讯，他确实告诉我们他会接受一个值并回传一个 applicative functor，里面装有结果。</p><p>对于 pure 比较好的说法是把一个普通值放到一个预设的 context 下，一个最小的 context 但仍然包含这个值。</p><p>&lt;<em>&gt; 也非常有趣。他的型别是 f (a -&gt; b) -&gt; f a -&gt; f b。这有让你联想到什么吗？没错！就是 fmap :: (a -&gt; b) -&gt; f a -&gt; f b。他有点像加强版的 fmap。然而 fmap 接受一个函数跟一个 functor，然后套用 functor 之中的函数。&lt;</em>&gt; 则是接受一个装有函数的 functor 跟另一个 functor，然后取出第一个 functor 中的函数将他对第二个 functor 中的值做 map。</p><p>我们来看看 Maybe 的 Applicative 实作：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>  
    <span class="token hvariable">pure</span> <span class="token operator">=</span> <span class="token constant">Just</span>  
    <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>  
    <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">something</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">something</span>  </code></pre></div><p>从 class 的定义我们可以看到 f 作为 applicative functor 会接受一个具体型别当作参数，所以我们是写成 instance Applicative Maybe where 而不是写成 instance Applicative (Maybe a) where。</p><p>首先看到 pure。他只不过是接受一个东西然后包成 applicative functor。我们写成 pure = Just 是因为 Just 不过就是一个普通函数。我们其实也可以写成 pure x = Just x。</p><p>接着我们定义了 &lt;<em>&gt;。我们无法从 Nothing 中抽出一个函数，因为 Nothing 并不包含一个函数。所以我们说如果我们要尝试从 Nothing 中取出一个函数，结果必定是 Nothing。如果你看看 Applicative 的定义，你会看到他有 Functor 的限制，他代表 &lt;</em>&gt; 的两个参数都会是 functors。如果第一个参数不是 Nothing，而是一个装了函数的 Just，而且我们希望将这个函数对第二个参数做 map。这个也考虑到第二个参数是 Nothing 的情况，因为 fmap 任何一个函数至 Nothing 会回传 Nothing。</p><p>对于 Maybe 而言，如果左边是 Just，那 &lt;*&gt; 会从其中抽出了一个函数来 map 右边的值。如果有任何一个参数是 Nothing。那结果便是 Nothing。</p><p>来试试看吧！</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> Just <span class="token punctuation">(</span>+3<span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">9</span>  
Just <span class="token number">12</span>  
ghci<span class="token operator">&gt;</span> pure <span class="token punctuation">(</span>+3<span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">10</span>  
Just <span class="token number">13</span>  
ghci<span class="token operator">&gt;</span> pure <span class="token punctuation">(</span>+3<span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">9</span>  
Just <span class="token number">12</span>  
ghci<span class="token operator">&gt;</span> Just <span class="token punctuation">(</span>++<span class="token string">&quot;hahah&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Nothing  
Nothing  
ghci<span class="token operator">&gt;</span> Nothing <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token string">&quot;woot&quot;</span>  
Nothing  </code></pre></div><p>我们看到 pure (+3) 跟 Just (+3) 在这个 case 下是一样的。如果你是在 applicative context 底下跟 Maybe 打交道的话请用 pure，要不然就用 Just。前四个输入展示了函数是如何被取出并做 map 的动作，但在这个 case 底下，他们同样也可以用 unwrap 函数来 map over functors。最后一行比较有趣，因为我们试着从 Nothing 取出函数并将他 map 到某个值。结果当然是 Nothing。</p><p>对于普通的 functors，你可以用一个函数 map over 一个 functors，但你可能没办法拿到结果。而 applicative functors 则让你可以用单一一个函数操作好几个 functors。看看下面一段程式码：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> pure <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">3</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">5</span>  
Just <span class="token number">8</span>  
ghci<span class="token operator">&gt;</span> pure <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">3</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Nothing  
Nothing  
ghci<span class="token operator">&gt;</span> pure <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Nothing <span class="token operator">&lt;</span>*<span class="token operator">&gt;</span> Just <span class="token number">5</span>  
Nothing  </code></pre></div><p>究竟我们写了些什么？我们来一步步看一下。&lt;<em>&gt; 是 left-associative，也就是说 pure (+) &lt;</em>&gt; Just 3 &lt;<em>&gt; Just 5 可以写成 (pure (+) &lt;</em>&gt; Just 3) &lt;<em>&gt; Just 5。首先 + 是摆在一个 functor 中，在这边刚好他是一个 Maybe。所以首先，我们有 pure (+)，他等价于 Just (+)。接下来由于 partial application 的关系，Just (+) &lt;</em>&gt; Just 3 等价于 Just (3+)。把一个 3 喂给 + 形成另一个只接受一个参数的函数，他的效果等于加上 3。最后 Just (3+) &lt;*&gt; Just 5 被运算，其结果是 Just 8。</p><p>这样很棒吧！用 applicative style 的方式来使用 applicative functors。像是 pure f &lt;<em>&gt; x &lt;</em>&gt; y &lt;<em>&gt; ... 就让我们可以拿一个接受多个参数的函数，而且这些参数不一定是被包在 functor 中。就这样来套用在多个在 functor context 的值。这个函数可以吃任意多的参数，毕竟 &lt;</em>&gt; 只是做 partial application 而已。</p><p>如果我们考虑到 pure f &lt;<em>&gt; x 等于 fmap f x 的话，这样的用法就更方便了。这是 applicative laws 的其中一条。我们稍后会更仔细地检视这条定律。现在我们先依直觉来使用他。就像我们先前所说的，pure 把一个值放进一个预设的 context 中。如果我们要把一个函数放在一个预设的 context，然后把他取出并套用在放在另一个 applicative functor 的值。我们会做的事就是把函数 map over 那个 applicative functor。但我们不会写成 pure f &lt;</em>&gt; x &lt;<em>&gt; y &lt;</em>&gt; ...，而是写成 fmap f x &lt;<em>&gt; y &lt;</em>&gt; ...。这也是为什么 Control.Applicative 会 export 一个函数 &lt;$&gt;，他基本上就是中缀版的 fmap。他是这么被定义的：</p><p>(&lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo stretchy="false">)</mo><mo>:</mo><mo>:</mo><mo stretchy="false">(</mo><mi>F</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>f</mi><mo stretchy="false">)</mo><mo>=</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>b</mi><mo stretchy="false">)</mo><mo>−</mo><mo>&gt;</mo><mi>f</mi><mi>a</mi><mo>−</mo><mo>&gt;</mo><mi>f</mi><mi>b</mi><mi>f</mi><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&gt;) :: (Functor f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b  
f &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em">F</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mord mathdefault">a</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; x = fmap f x<br/>
<!-- -->要记住型别变数跟参数的名字还有值绑定的名称不冲突。<code class="language-text">f</code> 在函数的型别宣告中是型别变数，说明 <code class="language-text">f</code> 应该要满足 <code class="language-text">Functor</code> typeclass 的条件。而在函数本体中的 <code class="language-text">f</code> 则表示一个函数，我们将他 map over x。我们同样用 <code class="language-text">f</code> 来表示他们并代表他们是相同的东西。
&lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mtext>的使用显示了</mtext><mi>a</mi><mi>p</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>y</mi><mi>l</mi><mi>e</mi><mtext>的好处。如果我们想要将</mtext><mi>f</mi><mtext>套用三个</mtext><mi>a</mi><mi>p</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext>。我们可以写成</mtext><mi>f</mi><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&gt; 的使用显示了 applicative style 的好处。如果我们想要将 f 套用三个 applicative functor。我们可以写成 f &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">显</span><span class="mord cjk_fallback">示</span><span class="mord cjk_fallback">了</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em">y</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">好</span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">想</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">将</span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mord cjk_fallback">套</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">三</span><span class="mord cjk_fallback">个</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">写</span><span class="mord cjk_fallback">成</span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; x &lt;<em>&gt; y &lt;</em>&gt; z。如果参数不是 applicative functor 而是普通值的话。我们则写成 f x y z。</p><p>我们再仔细看看他是如何运作的。我们有一个 Just &quot;johntra&quot; 跟 Just &quot;volta&quot; 这样的值，我们希望将他们结合成一个 String，并且包含在 Maybe 中。我们会这样做：</p><p>ghci&gt; (++) &lt;$&gt; Just &quot;johntra&quot; &lt;*&gt; Just &quot;volta&quot;<br/>
<!-- -->Just &quot;johntravolta&quot;<br/>
<!-- -->可以将上面的跟下面这行比较一下：</p><p>ghci&gt; (++) &quot;johntra&quot; &quot;volta&quot;<br/>
<!-- -->&quot;johntravolta&quot;<br/>
<!-- -->可以将一个普通的函数套用在 applicative functor 上真不错。只要稍微写一些 &lt;$&gt; 跟 &lt;*&gt; 就可以把函数变成 applicative style，可以操作 applicatives 并回传 applicatives。</p><p>总之当我们在做 (++) &lt;$&gt; Just &quot;johntra&quot; &lt;<em>&gt; Just &quot;volta&quot; 时，首先我们将 (++) map over 到 Just &quot;johntra&quot;，然后产生 Just (&quot;johntra&quot;++)，其中 (++) 的型别为 (++) :: <!-- -->[a]<!-- --> -&gt; <!-- -->[a]<!-- --> -&gt; <!-- -->[a]<!-- -->，Just (&quot;johntra&quot;++) 的型别为 Maybe (<!-- -->[Char]<!-- --> -&gt; <!-- -->[Char]<!-- -->)。注意到 (++) 是如何吃掉第一个参数，以及我们是怎么决定 a 是 Char 的。当我们做 Just (&quot;johntra&quot;++) &lt;</em>&gt; Just &quot;volta&quot;，他接受一个包在 Just 中的函数，然后 map over Just &quot;volta&quot;，产生了 Just &quot;johntravolta&quot;。如果两个值中有任意一个为 Nothing，那整个结果就会是 Nothing。</p><p>到目前为止我们只有用 Maybe 当作我们的案例，你可能也会想说 applicative functor 差不多就等于 Maybe。不过其实有许多其他 Applicative 的 instance。我们来看看有哪些。</p><p>List 也是 applicative functor。很惊讶吗？来看看我们是怎么定义 [] 为 Applicative 的 instance 的。</p><p>instance Applicative [] where<br/>
<!-- -->pure x = <!-- -->[x]<br/>
<!-- -->fs &lt;*&gt; xs = <!-- -->[f x | f &lt;- fs, x &lt;- xs]<br/>
<!-- -->早先我们说过 pure 是把一个值放进预设的 context 中。换种说法就是一个会产生那个值的最小 context。而对 list 而言最小 context 就是 []，但由于空的 list 并不包含一个值，所以我们没办法把他当作 pure。这也是为什么 pure 其实是接受一个值然后回传一个包含单元素的 list。同样的，Maybe 的最小 context 是 Nothing，但他其实表示的是没有值。所以 pure 其实是被实作成 Just 的。</p><p>ghci&gt; pure &quot;Hey&quot; :: <!-- -->[String][&quot;Hey&quot;]<br/>
<!-- -->ghci&gt; pure &quot;Hey&quot; :: Maybe String<br/>
<!-- -->Just &quot;Hey&quot;<br/>
<!-- -->至于 &lt;<em>&gt; 呢？如果我们假定 &lt;</em>&gt; 的型别是限制在 list 上的话，我们会得到 (&lt;<em>&gt;) :: <!-- -->[a -&gt; b]<!-- --> -&gt; <!-- -->[a]<!-- --> -&gt; <!-- -->[b]<!-- -->。他是用 list comprehension 来实作的。&lt;</em>&gt; 必须要从左边的参数取出函数，将他 map over 右边的参数。但左边的 list 有可能不包含任何函数，也可能包含一个函数，甚至是多个函数。而右边的 list 有可能包含多个值。这也是为什么我们用 list comprehension 的方式来从两个 list 取值。我们要对左右任意的组合都做套用的动作。而得到的结果就会是左右两者任意组合的结果。</p><p>ghci&gt; <!-- -->[(*0),(+100),(^2)]<!-- --> &lt;*&gt; <!-- -->[1,2,3][0,0,0,101,102,103,1,4,9]<br/>
<!-- -->左边的 list 包含三个函数，而右边的 list 有三个值。所以结果会是有九个元素的 list。在左边 list 中的每一个函数都被套用到右边的值。如果我们今天在 list 中的函数是接收两个参数的，我们也可以套用到两个 list 上。</p><p>ghci&gt; <!-- -->[(+),(*)]<!-- --> &lt;<em>&gt; <!-- -->[1,2]<!-- --> &lt;</em>&gt; <!-- -->[3,4][4,5,5,6,3,4,6,8]<br/>
<!-- -->由于 &lt;<em>&gt; 是 left-associative，也就是说 [(+),(</em>)] &lt;<em>&gt; <!-- -->[1,2]<!-- --> 会先运作，产生 [(1+),(2+),(1</em>),(2<em>)]。由于左边的每一个函数都套用至右边的每一个值。也就产生 [(1+),(2+),(1</em>),(2<em>)] &lt;</em>&gt; <!-- -->[3,4]<!-- -->，其便是最终结果。</p><p>list 的 applicative style 是相当有趣的：</p><p>ghci&gt; (++) &lt;$&gt; <!-- -->[&quot;ha&quot;,&quot;heh&quot;,&quot;hmm&quot;]<!-- --> &lt;*&gt; <!-- -->[&quot;?&quot;,&quot;!&quot;,&quot;.&quot;][&quot;ha?&quot;,&quot;ha!&quot;,&quot;ha.&quot;,&quot;heh?&quot;,&quot;heh!&quot;,&quot;heh.&quot;,&quot;hmm?&quot;,&quot;hmm!&quot;,&quot;hmm.&quot;]<!-- -->
看看我们是如何将一个接受两个字串参数的函数套用到两个 applicative functor 上的，只要用适当的 applicative 运算子就可以达成。</p><p>你可以将 list 看作是一个 non-deterministic 的计算。而对于像 100 或是 &quot;what&quot; 这样的值则是 deterministic 的计算，只会有一个结果。而 <!-- -->[1,2,3]<!-- --> 则可以看作是没有确定究竟是哪一种结果。所以他代表的是所有可能的结果。当你在做 (+) &lt;$&gt; <!-- -->[1,2,3]<!-- --> &lt;*&gt; <!-- -->[4,5,6]<!-- -->，你可以想做是把两个 non-deterministic 的计算做 +，只是他会产生另一个 non-deterministic 的计算，而且结果更加不确定。</p><p>Applicative style 对于 list 而言是一个取代 list comprehension 的好方式。在第二章中，我们想要看到 <!-- -->[2,5,10]<!-- --> 跟 <!-- -->[8,10,11]<!-- --> 相乘的结果，所以我们这样做：</p><p>ghci&gt; <!-- -->[ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]][16,20,22,40,50,55,80,100,110]<br/>
<!-- -->我们只是从两个 list 中取出元素，并将一个函数套用在任何元素的组合上。这也可以用 applicative style 的方式来写：</p><p>ghci&gt; (<em>) &lt;$&gt; <!-- -->[2,5,10]<!-- --> &lt;</em>&gt; <!-- -->[8,10,11][16,20,22,40,50,55,80,100,110]<br/>
<!-- -->这写法对我来说比较清楚。可以清楚表达我们是要对两个 non-deterministic 的计算做 *。如果我们想要所有相乘大于 50 可能的计算结果，我们会这样写：</p><p>ghci&gt; filter (&gt;50) <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>∗</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">(*) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; <!-- -->[2,5,10]<!-- --> &lt;<em>&gt; <!-- -->[8,10,11][55,80,100,110]<br/>很容易看到 pure f &lt;</em>&gt; xs 等价于 fmap f xs。而 pure f 就是 <!-- -->[f]<!-- -->，而且 <!-- -->[f]<!-- --> &lt;*&gt; xs 可将左边的每个函数套用至右边的每个值。但左边其实只有一个函数，所以他做起来就像是 mapping。</p><p>另一个我们已经看过的 Applicative 的 instance 是 IO，来看看他是怎么实作的：</p><p>instance Applicative IO where<br/>
<!-- -->pure = return<br/>
<!-- -->a &lt;*&gt; b = do<br/>
<!-- -->f &lt;- a<br/>
<!-- -->x &lt;- b<br/>
<!-- -->return (f x)  </p><p>由于 pure 是把一个值放进最小的 context 中，所以将 return 定义成 pure 是很合理的。因为 return 也是做同样的事情。他做了一个不做任何事情的 I/O action，他可以产生某些值来作为结果，但他实际上并没有做任何 I/O 的动作，例如说印出结果到终端或是档案。</p><p>如果 &lt;<em>&gt; 被限定在 IO 上操作的话，他的型别会是 (&lt;</em>&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b。他接受一个产生函数的 I/O action，还有另一个 I/O action，并从以上两者创造一个新的 I/O action，也就是把第二个参数喂给第一个参数。而得到回传的结果，然后放到新的 I/O action 中。我们用 do 的语法来实作他。你还记得的话 do 就是把好几个 I/O action 黏在一起，变成一个大的 I/O action。</p><p>而对于 Maybe 跟 [] 而言，我们可以把 &lt;*&gt; 想做是从左边的参数取出一个函数，然后套用到右边的参数上。至于 IO，这种取出的类比方式仍然适用，但我们必须多加一个 sequencing 的概念，因为我们是从两个 I/O action 中取值，也是在 sequencing，把他们黏成一个。我们从第一个 I/O action 中取值，但要取出 I/O action 的结果，他必须要先被执行过。</p><p>考虑下面这个范例：</p><p>myAction :: IO String<br/>
<!-- -->myAction = do<br/>
<!-- -->a &lt;- getLine<br/>
<!-- -->b &lt;- getLine<br/>
<!-- -->return $ a ++ b<br/>
<!-- -->这是一个提示使用者输入两行并产生将两行输入串接在一起结果的一个 I/O action。我们先把两个 getLine 黏在一起，然后用一个 return，这是因为我们想要这个黏成的 I/O action 包含 a ++ b 的结果。我们也可以用 applicative style 的方式来描述：</p><p>myAction :: IO String<br/>
<!-- -->myAction = (++) &lt;$&gt; getLine &lt;<em>&gt; getLine<br/>我们先前的作法是将两个 I/O action 的结果喂给函数。还记得 getLine 的型别是 getLine :: IO String。当我们对 applicative functor 使用 &lt;</em>&gt; 的时候，结果也会是 applicative functor。</p><p>如果我们再使用盒子的类比，我们可以把 getLine 想做是一个去真实世界中拿取字串的盒子。而 (++) &lt;$&gt; getLine &lt;*&gt; getLine 会创造一个比较大的盒子，这个大盒子会派两个盒子去终端拿取字串，并把结果串接起来放进自己的盒子中。</p><p>(++) &lt;$&gt; getLine &lt;*&gt; getLine 的型别是 IO String，他代表这个表达式式一个再普通不过的 I/O action，他里面也装着某种值。这也是为什么我们可以这样写：</p><p>main = do<br/>
<!-- -->a &lt;- (++) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>L</mi><mi>i</mi><mi>n</mi><mi>e</mi><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>L</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>p</mi><mi>u</mi><mi>t</mi><mi>S</mi><mi>t</mi><mi>r</mi><mi>L</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">&gt; getLine &lt;*&gt; getLine  
    putStrLn</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05764em">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">L</span><span class="mord mathdefault">n</span></span></span></span> &quot;The two lines concatenated turn out to be: &quot; ++ a<br/>
<!-- -->如果你发现你是在做 binding I/O action 的动作，而且在 binding 之后还呼叫一些函数，最后用 return 来将结果包起来。 那你可以考虑使用 applicative style，这样可以更简洁。</p><p>另一个 Applicative 的 instance 是 (-&gt;) r。虽然他们通常是用在 code golf 的情况，但他们还是十分有趣的例子。所以我们还是来看一下他们是怎么被实作的。</p><p>如果你忘记 <code class="language-text">(-&gt;) r</code> 的意思，回去翻翻前一章节我们介绍 <code class="language-text">(-&gt;) r</code> 作为一个 functor 的范例。
instance Applicative ((-&gt;) r) where<br/>
<!-- -->pure x = (<!-- -->_<!-- --> -&gt; x)<br/>
<!-- -->f &lt;*&gt; g = \x -&gt; f x (g x)<br/>
<!-- -->当我们用 pure 将一个值包成 applicative functor 的时候，他产生的结果永远都会是那个值。也就是最小的 context。那也是为什么对于 function 的 pure 实作来讲，他就是接受一个值，然后造一个函数永远回传那个值，不管他被喂了什么参数。如果你限定 pure 的型别至 (-&gt;) r 上，他就会是 pure :: a -&gt; (r -&gt; a)。</p><p>ghci&gt; (pure 3) &quot;blah&quot;<br/>
<!-- -->3<br/>
<!-- -->由于 currying 的关系，函数套用是 left-associative，所以我们忽略掉括弧。</p><p>ghci&gt; pure 3 &quot;blah&quot;<br/>
<!-- -->3<br/>
<!-- -->而 &lt;*&gt; 的实作是比较不容易了解的，我们最好看一下怎么用 applicative style 的方式来使用作为 applicative functor 的 function。</p><p>ghci&gt; :t (+) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo stretchy="false">(</mo><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mo>∗</mo><mn>100</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mo>+</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&gt; (+3) &lt;*&gt; (*100)  
(+) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">+</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">+</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; (+3) &lt;<em>&gt; (</em>100) :: (Num a) =&gt; a -&gt; a<br/>
<!-- -->ghci&gt; (+) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo stretchy="false">(</mo><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mo>∗</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&gt; (+3) &lt;*&gt; (*100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">+</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 5<br/>
<!-- -->508
将两个 applicative functor 喂给 &lt;<em>&gt; 可以产生一个新的 applicative functor，所以如果我们丢给他两个函数，我们能得到一个新的函数。所以是怎么一回事呢？当我们做 (+) &lt;$&gt; (+3) &lt;</em>&gt; (<em>100)，我们是在实作一个函数，他会将 (+3) 跟 (</em>100) 的结果再套用 +。要看一个实际的范例的话，可以看一下 (+) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo stretchy="false">(</mo><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mo>∗</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&gt; (+3) &lt;*&gt; (*100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">+</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> 5 首先 5 被丢给 (+3) 跟 (*100)，产生 8 跟 500。然后 + 被套用到 8 跟 500，得到 508。</p><p>ghci&gt; (\x y z -&gt; <!-- -->[x,y,z]<!-- -->) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo stretchy="false">(</mo><mo>+</mo><mn>3</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mo>∗</mo><mn>2</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">+</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">∗</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 5<br/>
<!-- -->[8.0,10.0,2.5]<!-- -->  </p><p>这边也一样。我们创建了一个函数，他会呼叫 \x y z -&gt; <!-- -->[x,y,z]<!-- -->，而丢的参数是 (+3), (*2) 跟 (/2)。5 被丢给以上三个函数，然后他们结果又接到 \x y z -&gt; <!-- -->[x, y, z]<!-- -->。</p><p>你可以将函数想做是装着最终结果的盒子，所以 k &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mi>f</mi><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mi>g</mi><mtext>会制造一个函数，他会将</mtext><mi>f</mi><mtext>跟</mtext><mi>g</mi><mtext>的结果丢给</mtext><mi>k</mi><mtext>。当我们做</mtext><mo stretchy="false">(</mo><mo>+</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&gt; f &lt;*&gt; g 会制造一个函数，他会将 f 跟 g 的结果丢给 k。当我们做 (+) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">造</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">函</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">将</span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mord cjk_fallback">跟</span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">果</span><span class="mord cjk_fallback">丢</span><span class="mord cjk_fallback">给</span><span class="mord mathdefault" style="margin-right:0.03148em">k</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">做</span><span class="mopen">(</span><span class="mord">+</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; Just 3 &lt;<em>&gt; Just 5，我们是用 + 套用在一些可能有或可能没有的值上，所以结果也会是可能有或没有。当我们做 (+) &lt;$&gt; (+10) &lt;</em>&gt; (+5)，我们是将 + 套用在 (+10) 跟 (+5) 的结果上，而结果也会是一个函数，当被喂给一个参数的时候会产生结果。</p><p>我们通常不会将函数当作 applicative 用，不过仍然值得当作练习。对于 (-&gt;) r 怎么定义成 Applicative 的并不是真的那么重要，所以如果你不是很懂的话也没关系。这只是让你获得一些操作上的直觉罢了。</p><p>一个我们之前还没碰过的 Applicative 的 instance 是 ZipList，他是包含在 Control.Applicative 中。</p><p>对于 list 要作为一个 applicative functor 可以有多种方式。我们已经介绍过其中一种。如果套用 &lt;<em>&gt;，左边是许多函数，而右边是许多值，那结果会是函数套用到值的所有组合。如果我们做 [(+3),(</em>2)] &lt;<em>&gt; <!-- -->[1,2]<!-- -->。那 (+3) 会先套用至 1 跟 2。接着 (</em>2) 套用至 1 跟 2。而得到 <!-- -->[4,5,2,4]<!-- -->。</p><p>然而 <!-- -->[(+3),(*2)]<!-- --> &lt;<em>&gt; <!-- -->[1,2]<!-- --> 也可以这样运作:把左边第一个函数套用至右边第一个值，接着左边第二个函数套用右边第二个值，以此类推。这样得到的会是 <!-- -->[4,4]<!-- -->。或是 [1 + 3, 2 </em> 2]。</p><p>由于一个型别不能对同一个 typeclass 定义两个 instance，所以才会定义了 ZipList a，他只有一个构造子 ZipList，他只包含一个栏位，他的型别是 list。</p><p>instance Applicative ZipList where<br/>
<!-- -->pure x = ZipList (repeat x)<br/>
<!-- -->ZipList fs &lt;<em>&gt; ZipList xs = ZipList (zipWith (\f x -&gt; f x) fs xs)<br/>&lt;</em>&gt; 做的就是我们之前说的。他将第一个函数套用至第一个值，第二个函数套用第二个值。这也是 zipWith (\f x -&gt; f x) fs xs 做的事。由于 zipWith 的特性，所以结果会跟 list 中比较短的那个一样长。</p><p>pure 也值得我们讨论一下。他接受一个值，把他重复地放进一个 list 中。pure &quot;haha&quot; 就会是 ZipList ([&quot;haha&quot;,&quot;haha&quot;,&quot;haha&quot;...。这可能会造成些混淆，毕竟我们说过 pure 是把一个值放进一个最小的 context 中。而你会想说无限长的 list 不可能会是一个最小的 context。但对于 zip list 来说这是很合理的，因为他必须在 list 的每个位置都有值。这也遵守了 pure f &lt;<em>&gt; xs 必须要等价于 fmap f xs 的特性。如果 pure 3 只是回传 ZipList <!-- -->[3]<!-- -->，那 pure (</em>2) &lt;*&gt; ZipList <!-- -->[1,5,10]<!-- --> 就只会算出 ZipList <!-- -->[2]<!-- -->，因为两个 zip list 算出结果的长度会是比较短的那个的长度。如果我们 zip 一个有限长的 list 以及一个无限长的 list，那结果的长会是有限长的 list 的长度。</p><p>那 zip list 是怎么用 applicative style 操作的呢？我们来看看，ZipList a 型别并没有定义成 Show 的 instance，所以我们必须用 getZipList 函数来从 zip list 取出一个普通的 list。</p><p>ghci&gt; getZipList <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>+</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">(+) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">+</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; ZipList <!-- -->[1,2,3]<!-- --> &lt;<em>&gt; ZipList <!-- -->[100,100,100][101,102,103]<br/>ghci&gt; getZipList <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>+</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">(+) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">+</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; ZipList <!-- -->[1,2,3]<!-- --> &lt;</em>&gt; ZipList <!-- -->[100,100..][101,102,103]<br/>
<!-- -->ghci&gt; getZipList <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">max &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; ZipList <!-- -->[1,2,3,4,5,3]<!-- --> &lt;<em>&gt; ZipList <!-- -->[5,3,1,2][5,3,3,4]<br/>ghci&gt; getZipList <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo separator="true">,</mo><mo separator="true">,</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">(,,) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; ZipList &quot;dog&quot; &lt;</em>&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot;<br/>
<!-- -->[(&#x27;d&#x27;,&#x27;c&#x27;,&#x27;r&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;g&#x27;,&#x27;t&#x27;,&#x27;t&#x27;)]<br/>
<code class="language-text">(,,)</code> 函数跟 <code class="language-text">\x y z -&gt; (x,y,z)</code> 是等价的，而 <code class="language-text">(,)</code> 跟 <code class="language-text">\x y -&gt; (x,y)</code> 是等价的。
除了 zipWith，标准函式库中也有 zipWith3, zipWith4 之类的函数，最多支援到 7。zipWith 接受一个接受两个参数的函数，并把两个 list zip 起来。zipWith3 则接受一个接受三个参数的函数，然后把三个 list zip 起来。以此类推。用 applicative style 的方式来操作 zip list 的话，我们就不需要对每个数量的 list 都定义一个独立的 zip 函数来 zip 他们。我们只需要用 applicative style 的方式来把任意数量的 list zip 起来就可以了。</p><p>Control.Applicative 定义了一个函数叫做 liftA2，他的型别是 liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c。他定义如下：</p><p>liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c<br/>
<!-- -->liftA2 f a b = f &lt;$&gt; a &lt;*&gt; b<br/>
<!-- -->并没有太难理解的东西，他不过就是对两个 applicatives 套用函数而已，而不用我们刚刚熟悉的 applicative style。我们提及他的理由只是要展示为什么 applicative functors 比起一般的普通 functor 要强。如果只是普通的 functor 的话，我们只能将一个函数 map over 这个 functor。但有了 applicative functor，我们可以对好多个 functor 套用一个函数。看看这个函数的型别，他会是 (a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)。当我们从这样的角度来看他的话，我们可以说 liftA2 接受一个普通的二元函数，并将他升级成一个函数可以运作在两个 functor 之上。</p><p>另外一个有趣的概念是，我们可以接受两个 applicative functor 并把他们结合成一个 applicative functor，这个新的将这两个 applicative functor 装在 list 中。举例来说，我们现在有 Just 3 跟 Just 4。我们假设后者是一个只包含单元素的 list。</p><p>ghci&gt; fmap (\x -&gt; <!-- -->[x]<!-- -->) (Just 4)<br/>
<!-- -->Just <!-- -->[4]<br/>
<!-- -->所以假设我们有 Just 3 跟 Just <!-- -->[4]<!-- -->。我们有怎么得到 Just <!-- -->[3,4]<!-- --> 呢？很简单。</p><p>ghci&gt; liftA2 (:) (Just 3) (Just <!-- -->[4]<!-- -->)<br/>
<!-- -->Just <!-- -->[3,4]<br/>
<!-- -->ghci&gt; (:) &lt;$&gt; Just 3 &lt;*&gt; Just <!-- -->[4]<br/>
<!-- -->Just <!-- -->[3,4]<br/>
<!-- -->还记得 : 是一个函数，他接受一个元素跟一个 list，并回传一个新的 list，其中那个元素已经接在前面。现在我们有了 Just <!-- -->[3,4]<!-- -->，我们能够将他跟 Just 2 绑在一起变成 Just <!-- -->[2,3,4]<!-- --> 吗？当然可以。我们可以将任意数量的 applicative 绑在一起变成一个 applicative，里面包含一个装有结果的 list。我们试着实作一个函数，他接受一串装有 applicative 的 list，然后回传一个 applicative 里面有一个装有结果的 list。我们称呼他为 sequenceA。</p><p>sequenceA :: (Applicative f) =&gt; <!-- -->[f a]<!-- --> -&gt; f <!-- -->[a]<br/>
<!-- -->sequenceA [] = pure []<br/>
<!-- -->sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs<br/>
<!-- -->居然用到了递回！首先我们来看一下他的型别。他将一串 applicative 的 list 转换成一个 applicative 装有一个 list。从这个资讯我们可以推测出边界条件。如果我们要将一个空的 list 变成一个装有 list 的 applicative。我们只要把这个空的 list 放进一个预设的 context。现在来看一下我们怎么用递回的。如果们有一个可以分成头跟尾的 list（x 是一个 applicative 而 xs 是一串 applicatve），我们可以对尾巴呼叫 sequenceA，便会得到一个装有 list 的 applicative。然后我们只要将在 x 中的值把他接到装有 list 的 applicative 前面就可以了。</p><p>所以如果我们做 sequenceA <!-- -->[Just 1, Just 2]<!-- -->，也就是 (:) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mi>J</mi><mi>u</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mi>s</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>A</mi><mo stretchy="false">[</mo><mi>J</mi><mi>u</mi><mi>s</mi><mi>t</mi><mn>2</mn><mo stretchy="false">]</mo><mtext>。那会等价于</mtext><mo stretchy="false">(</mo><mo>:</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&gt; Just 1 &lt;*&gt; sequenceA [Just 2]。那会等价于 (:) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em"></span><span class="mord mathdefault" style="margin-right:0.09618em">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">A</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.09618em">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mclose">]</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">那</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">价</span><span class="mord cjk_fallback">于</span><span class="mopen">(</span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; Just 1 &lt;<em>&gt; ((:) &lt;$&gt; Just 2 &lt;</em>&gt; sequenceA [])。我们知道 sequenceA [] 算出来会是 Just []，所以运算式就变成 (:) &lt;<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mi>J</mi><mi>u</mi><mi>s</mi><mi>t</mi><mn>1</mn><mo>&lt;</mo><mo>∗</mo><mo>&gt;</mo><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mo>:</mo><mo stretchy="false">)</mo><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&gt; Just 1 &lt;*&gt; ((:) &lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em"></span><span class="mord mathdefault" style="margin-right:0.09618em">J</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&lt;</span></span></span></span>&gt; Just 2 &lt;<em>&gt; Just [])，也就是 (:) &lt;$&gt; Just 1 &lt;</em>&gt; Just <!-- -->[2]<!-- -->，算出来就是 Just <!-- -->[1,2]<!-- -->。</p><p>另一种实作 sequenceA 的方式是用 fold。要记得几乎任何需要走遍整个 list 并 accumulate 成一个结果的都可以用 fold 来实作。</p><p>sequenceA :: (Applicative f) =&gt; <!-- -->[f a]<!-- --> -&gt; f <!-- -->[a]<br/>
<!-- -->sequenceA = foldr (liftA2 (:)) (pure [])<br/>
<!-- -->我们从右往左走，并且起始的 accumulator 是用 pure []。我们是用 liftA2 (:) 来结合 accumulator 跟 list 中最后的元素，而得到一个 applicative，里面装有一个单一元素的一个 list。然后我们再用 liftA2 (:) 来结合 accumulator 跟最后一个元素，直到我们只剩下 accumulator 为止，而得到一个 applicative，里面装有所有结果。</p><p>我们来试试看套用在不同 applicative 上。</p><p>ghci&gt; sequenceA <!-- -->[Just 3, Just 2, Just 1]<br/>
<!-- -->Just <!-- -->[3,2,1]<br/>
<!-- -->ghci&gt; sequenceA <!-- -->[Just 3, Nothing, Just 1]<br/>
<!-- -->Nothing<br/>
<!-- -->ghci&gt; sequenceA <!-- -->[(+3),(+2),(+1)]<!-- --> 3<br/>
<!-- -->[6,5,4]<br/>
<!-- -->ghci&gt; sequenceA [<!-- -->[1,2,3]<!-- -->,<!-- -->[4,5,6]<!-- -->]<br/>
<!-- -->[<!-- -->[1,4]<!-- -->,<!-- -->[1,5]<!-- -->,<!-- -->[1,6]<!-- -->,<!-- -->[2,4]<!-- -->,<!-- -->[2,5]<!-- -->,<!-- -->[2,6]<!-- -->,<!-- -->[3,4]<!-- -->,<!-- -->[3,5]<!-- -->,<!-- -->[3,6]<!-- -->]<br/>
<!-- -->ghci&gt; sequenceA [<!-- -->[1,2,3]<!-- -->,<!-- -->[4,5,6]<!-- -->,<!-- -->[3,4,4]<!-- -->,[]]<br/>
<!-- -->[]<br/>
<!-- -->很酷吧。当我们套用在 Maybe 上时，sequenceA 创造一个新的 Maybe，他包含了一个 list 装有所有结果。如果其中一个值是 Nothing，那整个结果就会是 Nothing。如果你有一串 Maybe 型别的值，但你只在乎当结果不包含任何 Nothing 的情况，这样的特性就很方便。</p><p>当套用在函数时，sequenceA 接受装有一堆函数的 list，并回传一个回传 list 的函数。在我们的范例中，我们写了一个函数，他只接受一个数值作为参数，他会把他套用至 list 中的每一个函数，并回传一个包含结果的 list。sequenceA <!-- -->[(+3),(+2),(+1)]<!-- --> 3 会将 3 喂给 (+3), (+2) 跟 (+1)，然后将所有结果装在一个 list 中。</p><p>而 (+) &lt;$&gt; (+3) &lt;<em>&gt; (</em>2) 会创见一个接受单一参数的一函数，将他同时喂给 (+3) 跟 (<em>2)，然后呼叫 + 来将两者加起来。同样的道理，sequenceA [(+3),(</em>2)] 是制造一个接受单一参数的函数，他会将他喂给所有包含在 list 中的函数。但他最后不是呼叫 +，而是呼叫 : 跟 pure [] 来把结果接成一个 list，得到最后的结果。</p><p>当我们有一串函数，我们想要将相同的输入都喂给他们并检视结果的时候，sequenceA 非常好用。例如说，我们手上有一个数值，但不知道他是否满足一串 predicate。一种实作的方式是像这样：</p><p>ghci&gt; map (\f -&gt; f 7) <!-- -->[(&gt;4),(&lt;10),odd][True,True,True]<br/>
<!-- -->ghci&gt; and $ map (\f -&gt; f 7) <!-- -->[(&gt;4),(&lt;10),odd]<br/>
<!-- -->True<br/>
<!-- -->记住 and 接受一串布林值，并只有在全部都是 True 的时候才回传 True。 另一种实作方式是用 sequenceA：</p><p>ghci&gt; sequenceA <!-- -->[(&gt;4),(&lt;10),odd]<!-- --> 7<br/>
<!-- -->[True,True,True]<br/>
<!-- -->ghci&gt; and $ sequenceA <!-- -->[(&gt;4),(&lt;10),odd]<!-- --> 7<br/>
<!-- -->True<br/>
<!-- -->sequenceA <!-- -->[(&gt;4),(&lt;10),odd]<!-- --> 接受一个函数，他接受一个数值并将他喂给所有的 predicate，包含 <!-- -->[(&gt;4),(&lt;10),odd]<!-- -->。然后回传一串布林值。他将一个型别为 (Num a) =&gt; <!-- -->[a -&gt; Bool]<!-- --> 的 list 变成一个型别为 (Num a) =&gt; a -&gt; <!-- -->[Bool]<!-- --> 的函数，很酷吧。</p><p>由于 list 要求里面元素的型别要一致，所以包含在 list 中的所有函数都是同样型别。你不能创造一个像是 <!-- -->[ord, (+3)]<!-- --> 这样的 list，因为 ord 接受一个字元并回传一个数值，然而 (+3) 接受一个数值并回传一个数值。</p><p>当跟 [] 一起使用的时候，sequenceA 接受一串 list，并回传另一串 list。他实际上是创建一个包含所有可能组合的 list。为了方便说明，我们比较一下使用 sequenceA 跟 list comprehension 的差异：</p><p>ghci&gt; sequenceA [<!-- -->[1,2,3]<!-- -->,<!-- -->[4,5,6]<!-- -->]<br/>
<!-- -->[<!-- -->[1,4]<!-- -->,<!-- -->[1,5]<!-- -->,<!-- -->[1,6]<!-- -->,<!-- -->[2,4]<!-- -->,<!-- -->[2,5]<!-- -->,<!-- -->[2,6]<!-- -->,<!-- -->[3,4]<!-- -->,<!-- -->[3,5]<!-- -->,<!-- -->[3,6]<!-- -->]<br/>
<!-- -->ghci&gt; [<!-- -->[x,y]<!-- --> | x &lt;- <!-- -->[1,2,3]<!-- -->, y &lt;- <!-- -->[4,5,6]<!-- -->]<br/>
<!-- -->[<!-- -->[1,4]<!-- -->,<!-- -->[1,5]<!-- -->,<!-- -->[1,6]<!-- -->,<!-- -->[2,4]<!-- -->,<!-- -->[2,5]<!-- -->,<!-- -->[2,6]<!-- -->,<!-- -->[3,4]<!-- -->,<!-- -->[3,5]<!-- -->,<!-- -->[3,6]<!-- -->]<br/>
<!-- -->ghci&gt; sequenceA [<!-- -->[1,2]<!-- -->,<!-- -->[3,4]<!-- -->]<br/>
<!-- -->[<!-- -->[1,3]<!-- -->,<!-- -->[1,4]<!-- -->,<!-- -->[2,3]<!-- -->,<!-- -->[2,4]<!-- -->]<br/>
<!-- -->ghci&gt; [<!-- -->[x,y]<!-- --> | x &lt;- <!-- -->[1,2]<!-- -->, y &lt;- <!-- -->[3,4]<!-- -->]<br/>
<!-- -->[<!-- -->[1,3]<!-- -->,<!-- -->[1,4]<!-- -->,<!-- -->[2,3]<!-- -->,<!-- -->[2,4]<!-- -->]<br/>
<!-- -->ghci&gt; sequenceA [<!-- -->[1,2]<!-- -->,<!-- -->[3,4]<!-- -->,<!-- -->[5,6]<!-- -->]<br/>
<!-- -->[<!-- -->[1,3,5]<!-- -->,<!-- -->[1,3,6]<!-- -->,<!-- -->[1,4,5]<!-- -->,<!-- -->[1,4,6]<!-- -->,<!-- -->[2,3,5]<!-- -->,<!-- -->[2,3,6]<!-- -->,<!-- -->[2,4,5]<!-- -->,<!-- -->[2,4,6]<!-- -->]<br/>
<!-- -->ghci&gt; [<!-- -->[x,y,z]<!-- --> | x &lt;- <!-- -->[1,2]<!-- -->, y &lt;- <!-- -->[3,4]<!-- -->, z &lt;- <!-- -->[5,6]<!-- -->]<br/>
<!-- -->[<!-- -->[1,3,5]<!-- -->,<!-- -->[1,3,6]<!-- -->,<!-- -->[1,4,5]<!-- -->,<!-- -->[1,4,6]<!-- -->,<!-- -->[2,3,5]<!-- -->,<!-- -->[2,3,6]<!-- -->,<!-- -->[2,4,5]<!-- -->,<!-- -->[2,4,6]<!-- -->]<br/>
<!-- -->这可能有点难以理解，但如果你多做点尝试，你会比较能看出来些眉目。假设我们在做 sequenceA [<!-- -->[1,2]<!-- -->,<!-- -->[3,4]<!-- -->]。要知道这是怎么回事，我们首先用 sequenceA 的定义 sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs 还有边界条件 sequenceA [] = pure [] 来看看。你不需要实际计算，但他可以帮助你理解 sequenceA 是怎么运作在一串 list 上，毕竟这有点复杂。</p><p>#<!-- --> 我们从 <code class="language-text">sequenceA [[1,2],[3,4]]</code> 开始
<!-- -->#<!-- --> 那可以被计算成 <code class="language-text">(:) &lt;$&gt; [1,2] &lt;*&gt; sequenceA [[3,4]]</code>
<!-- -->#<!-- --> 计算内层的 <code class="language-text">sequenceA</code>，会得到 <code class="language-text">(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; sequenceA [])</code>
<!-- -->#<!-- --> 我们碰到了边界条件，所以会是 <code class="language-text">(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; [[]])</code>
<!-- -->#<!-- --> 现在我们计算 <code class="language-text">(:) &lt;$&gt; [3,4] &lt;*&gt; [[]] </code> 的部份，我们会对左边 list 中的每一个值 (也就是 <code class="language-text">3</code> 跟 <code class="language-text">4</code>) 跟右边的每一个值 (只有 <code class="language-text">[]</code>)套用 <code class="language-text">:</code>，而得到 <code class="language-text">[3:[], 4:[]]</code>，也就是 <code class="language-text">[[3],[4]]</code>。所以我们有 <code class="language-text">(:) &lt;$&gt; [1,2] &lt;*&gt; [[3],[4]]</code>
<!-- -->#<!-- --> 而对于左边的每一个值(<code class="language-text">1</code> 跟 <code class="language-text">2</code>)以及右边可能的值（<code class="language-text">[3]</code> 跟 <code class="language-text">[4]</code>）我们套用 <code class="language-text">:</code> 而得到 <code class="language-text">[1:[3], 1:[4], 2:[3], 2:[4]]</code>，他等于 <code class="language-text">[[1,3],[1,4],[2,3],[2,4]]</code>
计算 (+) &lt;$&gt; <!-- -->[1,2]<!-- --> &lt;*&gt; <!-- -->[4,5,6]<!-- --> 会得到一个 non-deterministic 的结果 x + y，其中 x 代表 <!-- -->[1,2]<!-- --> 中的每一个值，而 y 代表 <!-- -->[4,5,6]<!-- --> 中的每一个值。我们用 list 来表示每一种可能的情形。同样的，当我们在做 sequence [<!-- -->[1,2]<!-- -->,<!-- -->[3,4]<!-- -->,<!-- -->[5,6]<!-- -->,<!-- -->[7,8]<!-- -->]，他的结果会是 non-deterministic 的 <!-- -->[x,y,z,w]<!-- -->，其中 x 代表 <!-- -->[1,2]<!-- --> 中的每一个值，而 y 代表 <!-- -->[3,4]<!-- --> 中的每一个值。以此类推。我们用 list 代表 non-deterministic 的计算，每一个元素都是一个可能的情形。这也是为什么会用到 list of list。</p><p>当使用在 I/O action 上的时候，sequenceA 跟 sequence 是等价的。他接受一串 I/O action 并回传一个 I/O action，这个 I/O action 会计算 list 中的每一个 I/O action，并把结果放在一个 list 中。要将型别为 <!-- -->[IO a]<!-- --> 的值转换成 IO <!-- -->[a]<!-- --> 的值，也就是会产生一串 list 的一个 I/O action，那这些 I/O action 必须要一个一个地被计算，毕竟对于这些 I/O action 你没办法不计算就得到结果。</p><p>ghci&gt; sequenceA <!-- -->[getLine, getLine, getLine]<br/>
<!-- -->heyh<br/>
<!-- -->ho<br/>
<!-- -->woo<br/>
<!-- -->[&quot;heyh&quot;,&quot;ho&quot;,&quot;woo&quot;]<br/>
<!-- -->就像普通的函数一样，applicative functors 也遵循一些定律。其中最重要的一个是我们之前提过的 pure f &lt;*&gt; x = fmap f x。你可以证明一些我们之前介绍过的 applicative functor 遵守这个定律当作练习。其他的 functors law 有：</p><p>#<!-- --> <code class="language-text">pure id &lt;*&gt; v = v</code>
<!-- -->#<!-- --> <code class="language-text">pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code>
<!-- -->#<!-- --> <code class="language-text">pure f &lt;*&gt; pure x = pure (f x)</code>
<!-- -->#<!-- --> <code class="language-text">u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code>
我们不会一项一项地细看，那样会花费很大的篇幅而且对读者来说很无聊，但如果你有兴趣，你可以针对某些 instance 看看他们会不会遵守。</p><p>结论就是 applicative functor 不只是有趣而且实用， 他允许我们结合不同种类的计算，像是 I/O 计算，non-deterministic 的计算，有可能失败的计算等等。而使用 &lt;$&gt; 跟 &lt;*&gt; 我们可以将普通的函数来运作在任意数量的 applicative functors 上。</p><p>关键字&quot;newtype&quot;</p><p>到目前为止，我们已经看过了如何用 data 关键字定义自己的 algebraic data type。我们也学习到了如何用 type 来定义 type synonyms。在这个章节中，我们会看一下如何使用 newtype 来从一个现有的型别中定义出新的型别，并说明我们为什么会想要那么做。</p><p>在之前的章节中，我们了解到其实 list 有很多种方式可以被视为一种 applicative functor。一中方式是定义 &lt;*&gt; 将左边的每一个值跟右边的每一个值组合，而得到各种组合的结果。</p><p>ghci&gt; <!-- -->[(+1),(<em>100),(</em>5)]<!-- --> &lt;<em>&gt; <!-- -->[1,2,3][2,3,4,100,200,300,5,10,15]<br/>第二种方式是将 &lt;</em>&gt; 定义成将左边的第一个函数套用至右边的第一个值，然后将左边第二个函数套用至右边第二个值。以此类推。最终，这表现得有点像将两个 list 用一个拉链拉起来一样。但由于 list 已经被定义成 Applicaitive 的 instance 了，所以我们要怎么要让 list 可以被定义成第二种方式呢？如果你还记得我们说过我们是有很好的理由定义了 ZipList a，其中他里面只包含一个值构造子跟只包含一个栏位。其实他的理由就是要让 ZipList 定义成用拉链的方式来表现 applicative 行为。我们只不过用 ZipList 这个构造子将他包起来，然后用 getZipList 来解开来。</p><p>ghci&gt; getZipList $ ZipList <!-- -->[(+1),(<em>100),(</em>5)]<!-- --> &lt;*&gt; ZipList <!-- -->[1,2,3][2,200,15]<br/>
<!-- -->所以这跟 newtype 这个关键字有什么关系呢？想想看我们是怎么宣告我们的 ZipList a 的，一种方式是像这样：</p><p>data ZipList a = ZipList <!-- -->[a]<br/>
<!-- -->也就是一个只有一个值构造子的型别而且那个构造子里面只有一个栏位。我们也可以用 record syntax 来定义一个解开的函数：</p><p>data ZipList a = ZipList { getZipList :: <!-- -->[a]<!-- --> }<br/>
<!-- -->这样听起来不错。这样我们就有两种方式来让一个型别来表现一个 typeclass，我们可以用 data 关键字来把一个型别包在另一个里面，然后再将他定义成第二种表现方式。</p><p>而在 Haskell 中 newtype 正是为了这种情形，我们想将一个型别包在另一个型别中。在实际的函式库中 ZipList a 是这样定义了：</p><p>newtype ZipList a = ZipList { getZipList :: <!-- -->[a]<!-- --> }<br/>
<!-- -->这边我们不用 data 关键字反而是用 newtype 关键字。这是为什么呢？第一个理由是 newtype 比较快速。如果你用 data 关键字来包一个型别的话，在你执行的时候会有一些包起来跟解开来的成本。但如果你用 newtype 的话，Haskell 会知道你只是要将一个现有的型别包成一个新的型别，你想要内部运作完全一样但只是要一个全新的型别而已。有了这个概念，Haskell 可以将包裹跟解开来的成本都去除掉。</p><p>那为什么我们不是一直使用 newtype 呢？当你用 newtype 来制作一个新的型别时，你只能定义单一一个值构造子，而且那个构造子只能有一个栏位。但使用 data 的话，你可以让那个型别有好几个值构造子，并且每个构造子可以有零个或多个栏位。</p><p>data Profession = Fighter | Archer | Accountant  </p><p>data Race = Human | Elf | Orc | Goblin  </p><p>data PlayerCharacter = PlayerCharacter Race Profession<br/>
<!-- -->当使用 newtype 的时候，你是被限制只能用一个值构造子跟单一栏位。</p><p>对于 newtype 我们也能使用 deriving 关键字。我们可以 derive 像是 Eq, Ord, Enum, Bounded, Show 跟 Read 的 instance。如果我们想要对新的型别做 derive，那原本的型别必须已经在那个 typeclass 中。这样很合理，毕竟 newtype 就是要将现有的型别包起来。如果我们按照下面的方式定义的话，我们就能对我们的型别做印出以及比较相等性的操作：</p><p>newtype CharList = CharList { getCharList :: <!-- -->[Char]<!-- --> } deriving (Eq, Show)<br/>
<!-- -->我们来跑跑看：</p><p>ghci&gt; CharList &quot;this will be shown!&quot;<br/>
<!-- -->CharList {getCharList = &quot;this will be shown!&quot;}<br/>
<!-- -->ghci&gt; CharList &quot;benny&quot; == CharList &quot;benny&quot;<br/>
<!-- -->True<br/>
<!-- -->ghci&gt; CharList &quot;benny&quot; == CharList &quot;oisters&quot;<br/>
<!-- -->False<br/>
<!-- -->对于这个 newtype，他的值构造子有下列型别：</p><p>CharList :: <!-- -->[Char]<!-- --> -&gt; CharList<br/>
<!-- -->他接受一个 <!-- -->[Char]<!-- --> 的值，例如 &quot;my sharona&quot; 并回传一个 CharList 的值。从上面我们使用 CharList 的值构造子的范例中，我们可以看到的确是这样。相反地，getCharList 具有下列的型别。</p><p>getCharList :: CharList -&gt; <!-- -->[Char]<br/>
<!-- -->他接受一个 CharList 的值并将他转成 <!-- -->[Char]<!-- -->。你可以将这个想成包装跟解开的动作，但你也可以将他想成从一个型别转成另一个型别。</p><p>Using newtype to make type class instances
有好几次我们想要让我们的型别属于某个 typeclass，但型别变数并没有符合我们想要的。要把 Maybe 定义成 Functor 的 instance 很容易，因为 Functor 这个 typeclass 被定义如下：</p><p>class Functor f where<br/>
<!-- -->fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br/>
<!-- -->我们先定义如下：</p><p>instance Functor Maybe where<br/>
<!-- -->然后我们实作 fmap。当所有的型别变数被填上时，由于 Maybe 取代了 Functor 中 f 的位置，所以如果我们看看 fmap 运作在 Maybe 上时是什么样，他会像这样：</p><p>fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b      </p><p>看起来不错吧？现在我们想要 tuple 成为 Functor 的一个 instance，所以当我们用 fmap 来 map over 一个 tuple 时，他会先套用到 tuple 中的第一个元素。这样当我们做 fmap (+3) (1,1) 会得到 (4,1)。不过要定义出这样的 instance 有些困难。对于 Maybe，我们只要写 instance Functor Maybe where，这是因为对于只吃一个参数的型别构造子我们很容易定义成 Functor 的 instance。但对于 (a,b) 这样的就没办法。要绕过这样的困境，我们可以用 newtype 来重新定义我们的 tuple，这样第二个型别参数就代表了 tuple 中的第一个元素部份。</p><p>newtype Pair b a = Pair { getPair :: (a,b) }<br/>
<!-- -->现在我们可以将他定义成 Functor 的 instance，所以函数被 map over tuple 中的第一个部份。</p><p>instance Functor (Pair c) where<br/>
<!-- -->fmap f (Pair (x,y)) = Pair (f x, y)<br/>
<!-- -->正如你看到的，我们可以对 newtype 定义的型别做模式匹配。我们用模式匹配来拿到底层的 tuple，然后我们将 f 来套用至 tuple 的第一个部份，然后我们用 Pair 这个值构造子来将 tuple 转换成 Pair b a。如果我们问 fmap 的型别究竟是什么，他会是：</p><p>fmap :: (a -&gt; b) -&gt; Pair c a -&gt; Pair c b<br/>
<!-- -->我们说过 instance Functor (Pair c) where 跟 Pair c 取代了 Functor 中 f 的位置：</p><p>class Functor f where<br/>
<!-- -->fmap :: (a -&gt; b) -&gt; f a -&gt; f b<br/>
<!-- -->如果我们将一个 tuple 转换成 Pair b a，我们可以用 fmap 来 map over 第一个部份。</p><p>ghci&gt; getPair <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>m</mi><mi>a</mi><mi>p</mi><mo stretchy="false">(</mo><mo>∗</mo><mn>100</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>P</mi><mi>a</mi><mi>i</mi><mi>r</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>200</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo><mi>g</mi><mi>h</mi><mi>c</mi><mi>i</mi><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>P</mi><mi>a</mi><mi>i</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">fmap (*100) (Pair (2,3))  
(200,3)  
ghci&gt; getPair</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathdefault" style="margin-right:0.10764em">f</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">∗</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord">3</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span></span></span></span> fmap reverse (Pair (&quot;london calling&quot;, 3))<br/>
<!-- -->(&quot;gnillac nodnol&quot;,3)<br/>
<!-- -->On newtype laziness
我们提到 newtype 一般来讲比 data 来得有效率。newtype 能做的唯一一件事就是将现有的型别包成新的型别。这样 Haskell 在内部就能将新的型别的值用旧的方式来操作。只是要记住他们还是不同的型别。这代表 newtype 并不只是有效率，他也具备 lazy 的特性。我们来说明一下这是什么意思。</p><p>就像我们之前说得，Haskell 预设是具备 lazy 的特性，这代表只有当我们要将函数的结果印出来的时候计算才会发生。或者说，只有当我们真的需要结果的时候计算才会发生。在 Haskell 中 undefined 代表会造成错误的计算。如果我们试着计算他，也就是将他印到终端中，Haskell 会丢出错误。</p><p>ghci&gt; undefined<br/>
<!-- -->*** Exception: Prelude.undefined<br/>
<!-- -->然而，如果我们做一个 list，其中包含一些 undefined 的值，但却要求一个不是 undefined 的 head，那一切都会顺利地被计算，因为 Haskell 并不需要 list 中其他元素来得到结果。我们仅仅需要看到第一个元素而已。</p><p>ghci&gt; head <!-- -->[3,4,5,undefined,2,undefined]<br/>
<!-- -->3<br/>
<!-- -->现在们考虑下面的型别：</p><p>data CoolBool = CoolBool { getCoolBool :: Bool }<br/>
<!-- -->这是一个用 data 关键字定义的 algebraic data type。他有一个值建构子并只有一个型别为 Bool 的栏位。我们写一个函数来对 CoolBool 做模式匹配，并回传一个 &quot;hello&quot; 的值。他并不会管 CoolBool 中装的究竟是 True 或 False。</p><p>helloMe :: CoolBool -&gt; String<br/>
<!-- -->helloMe (CoolBool _) = &quot;hello&quot;<br/>
<!-- -->这次我们不喂给这个函数一个普通的 CoolBool，而是丢给他一个 undefined。</p><p>ghci&gt; helloMe undefined<br/>
<!-- -->&quot;*** Exception: Prelude.undefined  &quot;
结果收到了一个 Exception。是什么造成这个 Exception 的呢？用 data 定义的型别可以有好几个值构造子（尽管 CoolBool 只有一个）所以当我们要看看喂给函数的值是否是 (CoolBool _) 的形式，Haskell 会需要做一些基本的计算来看看是哪个值构造子被用到。但当我们计算 undefined 的时候，就算是一点也会丢出 Exception。</p><p>我们不用 data 来定义 CoolBool 而用 newtype：</p><p>newtype CoolBool = CoolBool { getCoolBool :: Bool }<br/>
<!-- -->我们不用修改 helloMe 函数，因为对于模式匹配使用 newtype 或 data 都是一样。我们再来将 undefined 喂给 helloMe。</p><p>ghci&gt; helloMe undefined<br/>
<!-- -->&quot;hello&quot;
居然正常运作！为什么呢？正如我们说过得，当我们使用 newtype 的时候，Haskell 内部可以将新的型别用旧的型别来表示。他不必加入另一层 box 来包住旧有的型别。他只要注意他是不同的型别就好了。而且 Haskell 会知道 newtype 定义的型别一定只会有一个构造子，他不必计算喂给函数的值就能确定他是 (CoolBool _) 的形式，因为 newtype 只有一个可能的值跟单一栏位！</p><p>这样行为的差异可能没什么关系，但实际上他非常重要。因为他让我们认知到尽管从撰写程式的观点来看没什么差异，但他们的确是两种不同的机制。尽管 data 可以让你从无到有定义型别，newtype 是从一个现有的型别做出来的。对 newtype 做模式匹配并不是像从盒子中取出东西，他比较像是将一个型别转换成另一个型别。</p><p>type vs newtype vs data
到目前为止，你也许对于 type,data 跟 newtype 之间的差异还不是很了解，让我们快速复习一遍。</p><p>type 关键字是让我们定义 type synonyms。他代表我们只是要给一个现有的型别另一个名字，假设我们这样做：</p><p>type IntList = <!-- -->[Int]<br/>
<!-- -->这样做可以允许我们用 IntList 的名称来指称 <!-- -->[Int]<!-- -->。我们可以交换地使用他们。但我们并不会因此有一个 IntList 的值构造子。因为 <!-- -->[Int]<!-- --> 跟 IntList 只是两种指称同一个型别的方式。我们在指称的时候用哪一个并无所谓。</p><p>ghci&gt; (<!-- -->[1,2,3]<!-- --> :: IntList) ++ (<!-- -->[1,2,3]<!-- --> :: <!-- -->[Int]<!-- -->)<br/>
<!-- -->[1,2,3,1,2,3]<br/>
<!-- -->当我们想要让 type signature 更清楚一些，给予我们更了解函数的 context 的时候，我们会定义 type synonyms。举例来说，当我们用一个型别为 <!-- -->[(String,String)]<!-- --> 的 association list 来代表一个电话簿的时候，我们可以定义一个 PhoneBook 的 type synonym，这样 type signature 会比较容易读。</p><p>newtype 关键字将现有的型别包成一个新的型别，大部分是为了要让他们可以是特定 typeclass 的 instance 而这样做。当我们使用 newtype 来包裹一个现有的型别时，这个型别跟原有的型别是分开的。如果我们将下面的型别用 newtype 定义：</p><p>newtype CharList = CharList { getCharList :: <!-- -->[Char]<!-- --> }<br/>
<!-- -->我们不能用 ++ 来将 CharList 跟 <!-- -->[Char]<!-- --> 接在一起。我们也不能用 ++ 来将两个 CharList 接在一起，因为 ++ 只能套用在 list 上，而 CharList 并不是 list，尽管你会说他包含一个 list。但我们可以将两个 CharList 转成 list，将他们 ++ 然后再转回 CharList。</p><p>当我们在 newtype 宣告中使用 record syntax 的时候，我们会得到将新的型别转成旧的型别的函数，也就是我们 newtype 的值构造子，以及一个函数将他的栏位取出。新的型别并不会被自动定义成原有型别所属的 typeclass 的一个 instance，所以我们必须自己来 derive 他们。</p><p>实际上你可以将 newtype 想成是只能定义一个构造子跟一个栏位的 data 宣告。如果你碰到这种情形，可以考虑使用 newtype。</p><p>使用 data 关键字是为了定义自己的型别。他们可以在 algebraic data type 中放任意数量的构造子跟栏位。可以定义的东西从 list, Maybe 到 tree。</p><p>如果你只是希望你的 type signature 看起来比较干净，你可以只需要 type synonym。如果你想要将现有的型别包起来并定义成一个 type class 的 instance，你可以尝试使用 newtype。如果你想要定义完全新的型别，那你应该使用 data 关键字。</p><p>Monoids
Haskell 中 typeclass 是用来表示一个型别之间共有的行为，是一种 interface。我们介绍过 Eq，他定义型别是否可以比较相等性，以及 Ord，他表示可以被排序的型别。还介绍了更有趣的像是 Functor 跟 Applicative。</p><p>当我们定义一个型别时，我们会想说他应该要支援的行为。也就是表现的行为是什么，并且要让他属于哪些 typeclass。如果希望他可以比较相等与否，那我们就应该定义他成为 Eq 的一个 instance。如果我们想要看看型别是否是一种 functor，我们可以定义他是 Functor 的一个 instance。以此类推。</p><p>考虑 <em> 是一个将两个数值相乘的一个函数。如果我们将一个数值乘上 1，那就会得到自身的数值。我们实际上是做 1 </em> x 或 x <em> 1 并没有差别。结果永远会是 x。同样的，++ 是一个接受两个参数并回传新的值的一个函数。只是他不是相乘而是将两个 list 接在一起。而类似 </em>，他也有一个特定的值，当他跟其他值使用 ++ 时会得到同样的值。那个值就是空的 list []。</p><p>ghci&gt; 4 <em> 1<br/>4<br/>ghci&gt; 1 </em> 9<br/>
<!-- -->9<br/>
<!-- -->ghci&gt; <!-- -->[1,2,3]<!-- --> ++ <!-- -->[][1,2,3]<br/>
<!-- -->ghci&gt; [] ++ <!-- -->[0.5, 2.5][0.5,2.5]<br/>
<!-- -->看起来 * 之于 1 跟 ++ 之于 [] 有类似的性质：</p><p>#<!-- --> 函数同样接受两个参数
<!-- -->#<!-- --> 参数跟回传值是同样的型别
<!-- -->#<!-- --> 同样存在某些值当套用二元函数时并不会改变其他值
关于这两种操作还有另一个比较难察觉的性质就是，当我们对这个二元函数对三个以上的值操作并化简，函数套用的顺序并不会影响到结果。不论是 (3 <em> 4) </em> 5 或是 3 <em> (4 </em> 5)，两种方式都会得到 60。而 ++ 也是相同的。</p><p>ghci&gt; (3 <em> 2) </em> (8 <em> 5)<br/>240<br/>ghci&gt; 3 </em> (2 <em> (8 </em> 5))<br/>
<!-- -->240<br/>
<!-- -->ghci&gt; &quot;la&quot; ++ (&quot;di&quot; ++ &quot;da&quot;)<br/>
<!-- -->&quot;ladida&quot;<br/>
<!-- -->ghci&gt; (&quot;la&quot; ++ &quot;di&quot;) ++ &quot;da&quot;<br/>
<!-- -->&quot;ladida&quot;<br/>
<!-- -->我们称呼这样的性质为结合律(associativity)。* 遵守结合律，++ 也是。但 - 就不遵守。(5 - 3) - 4 跟 5 - (3 - 4) 得到的结果是不同的。</p><p>注意到这些性质并具体地写下来，就可以得到 monoid。一个 monoid 是你有一个遵守结合律的二元函数还有一个可以相对于那个函数作为 identity 的值。当某个值相对于一个函数是一个 identity，他表示当我们将这个值丢给函数时，结果永远会是另外一边的那个值本身。1 是相对于 * 的 identity，而 [] 是相对于 ++ 的 identity。在 Haskell 中还有许多其他的 monoid，这也是为什么我们定义了 Monoid 这个 typeclass。他描述了表现成 monoid 的那些型别。我们来看看这个 typeclass 是怎么被定义的：</p><p>class Monoid m where<br/>
<!-- -->mempty :: m<br/>
<!-- -->mappend :: m -&gt; m -&gt; m<br/>
<!-- -->mconcat :: <!-- -->[m]<!-- --> -&gt; m<br/>
<!-- -->mconcat = foldr mappend mempty  </p><p>Monoid typeclass 被定义在 import Data.Monoid 中。我们来花些时间好好了解他。</p><p>首先我们看到只有具体型别才能定义成 Monoid 的 instance。由于在 typeclass 定义中的 m 并不接受任何型别参数。这跟 Functor 以及 Applicative 不同，他们要求他们的 instance 必须是一个接受单一型别参数的型别构造子。</p><p>第一个函数是 mempty，由于他不接受任何参数，所以他并不是一个函数，而是一个 polymorphic 的常数。有点像是 Bounded 中的 minBound 一样。mempty 表示一个特定 monoid 的 identity。</p><p>再来我们看到 mappend，你可能已经猜到，他是一个接受两个相同型别的值的二元函数，并回传同样的型别。不过要注意的是他的名字不太符合他真正的意思，他的名字隐含了我们要将两个东西接在一起。尽管在 list 的情况下 ++ 的确将两个 list 接起来，但 * 则否。他只不过将两个数值做相乘。当我们再看到其他 Monoid 的 instance 时，我们会看到他们大部分都没有接起来的做，所以不要用接起来的概念来想像 mappend，只要想像他们是接受两个 monoid 的值并回传另外一个就好了。</p><p>在 typeclass 定义中的最后一个函数是 mconcat。他接受一串 monoid 值，并将他们用 mappend 简化成单一的值。他有一个预设的实作，就是从 mempty 作为起始值，然后用 mappend 来 fold。由于对于大部分的 instance 预设的实作就没什么问题，我们不会想要实作自己的 mconcat。当我们定义一个型别属于 Monoid 的时候，多半实作 mempty 跟 mappend 就可以了。而 mconcat 就是因为对于一些 instance，有可能有比较有效率的方式来实作 mconcat。不过大多数情况都不需要。</p><p>在我们继续接下去看几个 Monoid 的例子前，我们来看一下 monoid law。我们提过必须有一个值作为 identity 以及一个遵守结合律的二元函数当作前提。我们是可以定义一个 Monoid 的 instance 却不遵守这些定律的，但这样写出来的 instance 就没有用了，因为我们在使用 Monoid 的时候都是依靠这些定律才可以称作实质上的 monoid。所以我们必须确保他们遵守：</p><p>#<!-- --> <code class="language-text">mempty `mappend` x = x</code>
<!-- -->#<!-- --> <code class="language-text">x `mappend` mempty = x</code>
<!-- -->#<!-- --> <code class="language-text">(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code>
前两个描述了 mempty 相对于 mappend 必须要表现成 identity。而第三个定律说了 mappend 必须要遵守结合律。也就是说我们做 mappend 顺序并不重要。Haskell 不会自己检查这些定律是否有被遵守。所以你必须自己小心地检查他们。</p><p>Lists are monoids
没错，list 是一种 monoid。正如我们先前看到的，++ 跟空的 list [] 共同形成了一个 monoid。他的 instance 很简单：</p><p>instance Monoid <!-- -->[a]<!-- --> where<br/>
<!-- -->mempty = []<br/>
<!-- -->mappend = (++)<br/>
<!-- -->list 是 Monoid typeclass 的一个 instance，这跟他们装的元素的型别无关。注意到我们写 instance Monoid <!-- -->[a]<!-- --> 而非 instance Monoid []，这是因为 Monoid 要求 instance 必须是具体型别。</p><p>我们试着跑跑看，得到我们预期中的结果：</p><p>ghci&gt; <!-- -->[1,2,3]<!-- --> <code class="language-text">mappend</code> <!-- -->[4,5,6][1,2,3,4,5,6]<br/>
<!-- -->ghci&gt; (&quot;one&quot; <code class="language-text">mappend</code> &quot;two&quot;) <code class="language-text">mappend</code> &quot;tree&quot;<br/>
<!-- -->&quot;onetwotree&quot;<br/>
<!-- -->ghci&gt; &quot;one&quot; <code class="language-text">mappend</code> (&quot;two&quot; <code class="language-text">mappend</code> &quot;tree&quot;)<br/>
<!-- -->&quot;onetwotree&quot;<br/>
<!-- -->ghci&gt; &quot;one&quot; <code class="language-text">mappend</code> &quot;two&quot; <code class="language-text">mappend</code> &quot;tree&quot;<br/>
<!-- -->&quot;onetwotree&quot;<br/>
<!-- -->ghci&gt; &quot;pang&quot; <code class="language-text">mappend</code> mempty<br/>
<!-- -->&quot;pang&quot;<br/>
<!-- -->ghci&gt; mconcat <!-- -->[[1,2],[3,6],[9]][1,2,3,6,9]<br/>
<!-- -->ghci&gt; mempty :: <!-- -->[a][]<!-- -->  </p><p>注意到最后一行我们明白地标记出型别。这是因为如果只些 mempty 的话，GHCi 不会知道他是哪一个 instance 的 mempty，所以我们必须清楚说出他是 list instance 的 mempty。我们可以使用一般化的型别 <!-- -->[a]<!-- -->，因为空的 list 可以看作是属于任何型别。</p><p>由于 mconcat 有一个预设的实作，我们将某个型别定义成 Monoid 的型别时就可以自动地得到预设的实作。但对于 list 而言，mconcat 其实就是 concat。他接受一个装有 list 的 list，并把他用 ++ 来扁平化他。</p><p>list 的 instance 也遵守 monoid law。当我们有好几个 list 并且用 mappend 来把他们串起来，先后顺序并不是很重要，因为他们都是接在最后面。而且空的 list 也表现得如 identity 一样。注意到 monoid 并不要求 a <code class="language-text">mappend</code> b 等于 b <code class="language-text">mappend</code> a。在 list 的情况下，他们明显不相等。</p><p>ghci&gt; &quot;one&quot; <code class="language-text">mappend</code> &quot;two&quot;<br/>
<!-- -->&quot;onetwo&quot;<br/>
<!-- -->ghci&gt; &quot;two&quot; <code class="language-text">mappend</code> &quot;one&quot;<br/>
<!-- -->&quot;twoone&quot;<br/>
<!-- -->这样并没有关系。3 <em> 5 跟 5 </em> 3 会相等只不过是乘法的性质而已，但没有保证所有 monoid 都要遵守。</p><p>Product and Sum
我们已经描述过将数值表现成一种 monoid 的方式。只要将 * 当作二元函数而 1 当作 identity 就好了。而且这不是唯一一种方式，另一种方式是将 + 作为二元函数而 0 作为 identity。</p><p>ghci&gt; 0 + 4<br/>
<!-- -->4<br/>
<!-- -->ghci&gt; 5 + 0<br/>
<!-- -->5<br/>
<!-- -->ghci&gt; (1 + 3) + 5<br/>
<!-- -->9<br/>
<!-- -->ghci&gt; 1 + (3 + 5)<br/>
<!-- -->9<br/>
<!-- -->他也遵守 monoid law，因为将 0 加上其他数值，都会是另外一者。而且加法也遵守结合律。所以现在我们有两种方式来将数值表现成 monoid，那要选哪一个呢？其实我们不必要强迫定下来，还记得当同一种型别有好几种表现成某个 typeclass 的方式时，我们可以用 newtype 来包裹现有的型别，然后再定义新的 instance。这样就行了。</p><p>Data.Monoid 这个模组汇出了两种型别，Product 跟 Sum。Product 定义如下：</p><p>newtype Product a =  Product { getProduct :: a }<br/>
<!-- -->deriving (Eq, Ord, Read, Show, Bounded)<br/>
<!-- -->简单易懂，就是一个单一型别参数的 newtype，并 derive 一些性质。他的 Monoid 的 instance 长得像这样：</p><p>instance Num a =&gt; Monoid (Product a) where<br/>
<!-- -->mempty = Product 1<br/>
<!-- -->Product x <code class="language-text">mappend</code> Product y = Product (x * y)<br/>
<!-- -->mempty 只不过是将 1 包在 Product 中。mappend 则对 Product 的构造子做模式匹配，将两个取出的数值相乘后再将结果放回去。就如你看到的，typeclass 定义前面有 Num a 的条件限制。所以他代表 Product a 对于所有属于 Num 的 a 是一个 Monoid。要将 Product a 作为一个 monoid 使用，我们需要用 newtype 来做包裹跟解开的动作。</p><p>ghci&gt; getProduct $ Product 3 <code class="language-text">mappend</code> Product 9<br/>
<!-- -->27<br/>
<!-- -->ghci&gt; getProduct $ Product 3 <code class="language-text">mappend</code> mempty<br/>
<!-- -->3<br/>
<!-- -->ghci&gt; getProduct <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi><mn>3</mn><mi mathvariant="normal">‘</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">‘</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi><mn>4</mn><mi mathvariant="normal">‘</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">‘</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi><mn>224</mn><mi>g</mi><mi>h</mi><mi>c</mi><mi>i</mi><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>d</mi><mi>u</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Product 3 `mappend` Product 4 `mappend` Product 2  
24  
ghci&gt; getProduct . mconcat . map Product</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord">3</span><span class="mord">‘</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">‘</span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord">4</span><span class="mord">‘</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">‘</span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mord">2</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.13889em">P</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span> <!-- -->[3,4,2]<br/>
<!-- -->24<br/>
<!-- -->这当作 Monoid 的一个演练还不错，但并不会有人觉得这会比 3 <em> 9 跟 3 </em> 1 这种方式来做乘法要好。但我们稍后会说明尽管像这种显而易见的定义还是有他方便的地方。</p><p>Sum 跟 Product 定义的方式类似，我们也可以用类似的方式操作：</p><p>ghci&gt; getSum $ Sum 2 <code class="language-text">mappend</code> Sum 9<br/>
<!-- -->11<br/>
<!-- -->ghci&gt; getSum <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>t</mi><mi>y</mi><mi mathvariant="normal">‘</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">‘</mi><mi>S</mi><mi>u</mi><mi>m</mi><mn>33</mn><mi>g</mi><mi>h</mi><mi>c</mi><mi>i</mi><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>S</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">mempty `mappend` Sum 3  
3  
ghci&gt; getSum . mconcat . map Sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em">y</span><span class="mord">‘</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">‘</span><span class="mord mathdefault" style="margin-right:0.05764em">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">3</span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05764em">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.05764em">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> <!-- -->[1,2,3]<br/>
<!-- -->6<br/>
<!-- -->Any and ALL
另一种可以有两种表示成 monoid 方式的型别是 Bool。第一种方式是将 || 当作二元函数，而 False 作为 identity。这样的意思是只要有任何一个参数是 True 他就回传 True，否则回传 False。所以如果我们使用 False 作为 identity，他会在跟 False 做 OR 时回传 False，跟 True 做 OR 时回传 True。Any 这个 newtype 是 Monoid 的一个 instance，并定义如下：</p><p>newtype Any = Any { getAny :: Bool }<br/>
<!-- -->deriving (Eq, Ord, Read, Show, Bounded)<br/>
<!-- -->他的 instance 长得像这样：</p><p>instance Monoid Any where<br/>
<!-- -->mempty = Any False<br/>
<!-- -->Any x <code class="language-text">mappend</code> Any y = Any (x || y)<br/>
<!-- -->他叫做 Any 的理由是 x <code class="language-text">mappend</code> y 当有任何一个是 True 时就会是 True。就算是更多个用 mappend 串起来的 Any，他也会在任何一个是 True 回传 True。</p><p>ghci&gt; getAny $ Any True <code class="language-text">mappend</code> Any False<br/>
<!-- -->True<br/>
<!-- -->ghci&gt; getAny $ mempty <code class="language-text">mappend</code> Any True<br/>
<!-- -->True<br/>
<!-- -->ghci&gt; getAny . mconcat . map Any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo stretchy="false">]</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mi>g</mi><mi>h</mi><mi>c</mi><mi>i</mi><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>A</mi><mi>n</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">[False, False, False, True]  
True  
ghci&gt; getAny</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.13889em">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.13889em">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.13889em">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em"></span><span class="mord mathdefault" style="margin-right:0.13889em">T</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mclose">]</span><span class="mord mathdefault" style="margin-right:0.13889em">T</span><span class="mord mathdefault" style="margin-right:0.02778em">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">A</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em">y</span></span></span></span> mempty <code class="language-text">mappend</code> mempty<br/>
<!-- -->False<br/>
<!-- -->另一种 Bool 表现成 Monoid 的方式是用 &amp;&amp; 作为二元函数，而 True 作为 identity。只有当所有都是 True 的时候才会回传 True。下面是他的 newtype 定义：</p><p>newtype All = All { getAll :: Bool }<br/>
<!-- -->deriving (Eq, Ord, Read, Show, Bounded)<br/>
<!-- -->而这是他的 instance：</p><p>instance Monoid All where<br/>
<!-- -->mempty = All True<br/>
<!-- -->All x <code class="language-text">mappend</code> All y = All (x &amp;&amp; y)<br/>
<!-- -->当我们用 mappend 来串起 All 型别的值时，结果只有当所有 mappend 的值是 True 时才会是 True：</p><p>ghci&gt; getAll $ mempty <code class="language-text">mappend</code> All True<br/>
<!-- -->True<br/>
<!-- -->ghci&gt; getAll <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>e</mi><mi>m</mi><mi>p</mi><mi>t</mi><mi>y</mi><mi mathvariant="normal">‘</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>d</mi><mi mathvariant="normal">‘</mi><mi>A</mi><mi>l</mi><mi>l</mi><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mi>g</mi><mi>h</mi><mi>c</mi><mi>i</mi><mo>&gt;</mo><mi>g</mi><mi>e</mi><mi>t</mi><mi>A</mi><mi>l</mi><mi>l</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>c</mi><mi>o</mi><mi>n</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>A</mi><mi>l</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">mempty `mappend` All False  
False  
ghci&gt; getAll . mconcat . map All</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em">y</span><span class="mord">‘</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">p</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord">‘</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault" style="margin-right:0.13889em">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.13889em">F</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em"></span><span class="mord mathdefault" style="margin-right:0.03588em">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span><span class="mord mathdefault" style="margin-right:0.01968em">l</span></span></span></span> <!-- -->[True, True, True]<br/>
<!-- -->True<br/>
<!-- -->ghci&gt; getAll . mconcat . map All $ <!-- -->[True, True, False]<br/>
<!-- -->False<br/>
<!-- -->就如乘法跟加法一样，我们通常宁愿用二元函数来操作他们也不会用 newtype 来将他们包起来。不会将他们包成 Any 或 All 然后用 mappend，mempty 或 mconcat 来操作。通常使用 or 跟 and，他们接受一串 Bool，并只有当任意一个或是所有都是 True 的时候才回传 True。</p><p>The Ordering monoid
还记得 Ordering 型别吗?他是比较运算之后得到的结果，包含三个值：LT，EQ 跟 GT，分别代表小于，等于跟大于：</p><p>ghci&gt; 1 <code class="language-text">compare</code> 2<br/>
<!-- -->LT<br/>
<!-- -->ghci&gt; 2 <code class="language-text">compare</code> 2<br/>
<!-- -->EQ<br/>
<!-- -->ghci&gt; 3 <code class="language-text">compare</code> 2<br/>
<!-- -->GT<br/>
<!-- -->针对 list，数值跟布林值而言，要找出 monoid 的行为只要去检视已经定义的函数，然后看看有没有展现出 monoid 的特性就可以了，但对于 Ordering，我们就必须要更仔细一点才能看出来是否是一个 monoid，但其实他的 Monoid instance 还蛮直觉的：</p><p>instance Monoid Ordering where<br/>
<!-- -->mempty = EQ<br/>
<!-- -->LT <code class="language-text">mappend</code> <em> = LT<br/>EQ <code class="language-text">mappend</code> y = y<br/>GT <code class="language-text">mappend</code> </em> = GT  </p><p>这个 instance 定义如下：当我们用 mappend 两个 Ordering 型别的值时，左边的会被保留下来。除非左边的值是 EQ，那我们就会保留右边的当作结果。而 identity 就是 EQ。乍看之下有点随便，但实际上他是我们比较两个英文字时所用的方法。我们先比较两个字母是否相等，如果他们不一样，那我们就知道那一个字在字典中会在前面。而如果两个字母相等，那我们就继续比较下一个字母，以此类推。</p><p>举例来说，如果我们字典顺序地比较 &quot;ox&quot; 跟 &quot;on&quot; 的话。我们会先比较两个字的首个字母，看看他们是否相等，然后继续比较第二个字母。我们看到 &#x27;x&#x27; 是比 &#x27;n&#x27; 要来得大，所以我们就知道如何比较两个字了。而要了解为何 EQ 是 identity，我们可以注意到如果我们在两个字中间的同样位置塞入同样的字母，那他们之间的字典顺序并不会改变。&quot;oix&quot; 仍然比 &quot;oin&quot; 要大。</p><p>很重要的一件事是在 Ordering 的 Monoid 定义里 x <code class="language-text">mappend</code> y 并不等于 y <code class="language-text">mappend</code> x。因为除非第一个参数是 EQ，不然结果就会是第一个参数。所以 LT <code class="language-text">mappend</code> GT 等于 LT，然而 GT <code class="language-text">mappend</code> LT 等于 GT。</p><p>ghci&gt; LT <code class="language-text">mappend</code> GT<br/>
<!-- -->LT<br/>
<!-- -->ghci&gt; GT <code class="language-text">mappend</code> LT<br/>
<!-- -->GT<br/>
<!-- -->ghci&gt; mempty <code class="language-text">mappend</code> LT<br/>
<!-- -->LT<br/>
<!-- -->ghci&gt; mempty <code class="language-text">mappend</code> GT<br/>
<!-- -->GT<br/>
<!-- -->所以这个 monoid 在什么情况下会有用呢？假设你要写一个比较两个字串长度的函数，并回传 Ordering。而且当字串一样长的时候，我们不直接回传 EQ，反而继续用字典顺序比较他们。一种实作的方式如下：</p><p>lengthCompare :: String -&gt; String -&gt; Ordering<br/>
<!-- -->lengthCompare x y = let a = length x <code class="language-text">compare</code> length y<br/>
<!-- -->b = x <code class="language-text">compare</code> y<br/>
<!-- -->in  if a == EQ then b else a<br/>
<!-- -->我们称呼比较长度的结果为 a，而比较字典顺序的结果为 b，而当长度一样时，我们就回传字典顺序。</p><p>如果善用我们 Ordering 是一种 monoid 这项知识，我们可以把我们的函数写得更简单些：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token import_statement"><span class="token keyword">import</span> Data.Monoid</span>

<span class="token hvariable">lengthCompare</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>  
<span class="token hvariable">lengthCompare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span> `<span class="token builtin">compare</span>` <span class="token builtin">length</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span>  
                    <span class="token punctuation">(</span><span class="token hvariable">x</span> `<span class="token builtin">compare</span>` <span class="token hvariable">y</span><span class="token punctuation">)</span>  </code></pre></div><p>我们可以试着跑跑看：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> lengthCompare <span class="token string">&quot;zen&quot;</span> <span class="token string">&quot;ants&quot;</span>  
LT  
ghci<span class="token operator">&gt;</span> lengthCompare <span class="token string">&quot;zen&quot;</span> <span class="token string">&quot;ant&quot;</span>  
GT  </code></pre></div><p>要记住当我们使用 mappend。他在左边不等于 EQ 的情况下都会回传左边的值。相反地则回传右边的值。这也是为什么我们将我们认为比较重要的顺序放在左边的参数。如果我们要继续延展这个函数，要让他们比较母音的顺序，并把这顺序列为第二重要，那我们可以这样修改他：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token import_statement"><span class="token keyword">import</span> Data.Monoid</span>  

<span class="token hvariable">lengthCompare</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>  
<span class="token hvariable">lengthCompare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span> `<span class="token builtin">compare</span>` <span class="token builtin">length</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span>  
                    <span class="token punctuation">(</span><span class="token hvariable">vowels</span> <span class="token hvariable">x</span> `<span class="token builtin">compare</span>` <span class="token hvariable">vowels</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span>  
                    <span class="token punctuation">(</span><span class="token hvariable">x</span> `<span class="token builtin">compare</span>` <span class="token hvariable">y</span><span class="token punctuation">)</span>  
    <span class="token keyword">where</span> <span class="token hvariable">vowels</span> <span class="token operator">=</span> <span class="token builtin">length</span><span class="token operator"> . </span><span class="token builtin">filter</span> <span class="token punctuation">(</span>`<span class="token builtin">elem</span>` <span class="token string">&quot;aeiou&quot;</span><span class="token punctuation">)</span>  </code></pre></div><p>我们写了一个辅助函数，他接受一个字串并回传他有多少母音。他是先用 filter 来把字母滤到剩下 &quot;aeiou&quot;，然后再用 length 计算长度。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> lengthCompare <span class="token string">&quot;zen&quot;</span> <span class="token string">&quot;anna&quot;</span>  
LT  
ghci<span class="token operator">&gt;</span> lengthCompare <span class="token string">&quot;zen&quot;</span> <span class="token string">&quot;ana&quot;</span>  
LT  
ghci<span class="token operator">&gt;</span> lengthCompare <span class="token string">&quot;zen&quot;</span> <span class="token string">&quot;ann&quot;</span>
GT  </code></pre></div><p>在第一个例子中我们看到长度不同所以回传 LT，明显地 &quot;zen&quot; 要短于 &quot;anna&quot;。在第二个例子中，长度是一样的，但第二个字串有比较多的母音，所以结果仍然是 LT。在第三个范例中，两个长度都相等，他们也有相同个数的母音，经由字典顺序比较后得到 &quot;zen&quot; 比较大。</p><p>Ordering 的 monoid 允许我们用不同方式比较事物，并将这些顺序也定义了依重要度不同的一个顺序。</p><p>Maybe the monoid
我们来看一下 Maybe a 是怎样有多种方式来表现成 Monoid 的，并且说明哪些是比较有用的。一种将 Maybe a 当作 monoid 的方式就是他的 a 也是一个 monoid，而我们将 mappend 实作成使用包在 Just 里面的值对应的 mappend。并且用 Nothing 当作 identity。所以如果我 mappend 两个参数中有一个是 Nothing。那结果就会是另一边的值。他的 instance 定义如下：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>  
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>  
    <span class="token constant">Nothing</span> <span class="token operator">`mappend`</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">m</span>  
    <span class="token hvariable">m</span> <span class="token operator">`mappend`</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token hvariable">m</span>  
    <span class="token constant">Just</span> <span class="token hvariable">m1</span> <span class="token operator">`mappend`</span> <span class="token constant">Just</span> <span class="token hvariable">m2</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">m1</span> <span class="token operator">`mappend`</span> <span class="token hvariable">m2</span><span class="token punctuation">)</span></code></pre></div><p>留意到 class constraint。他说明 Maybe a 只有在 a 是 Monoid 的情况下才会是一个 Monoid。如果我们 mappend 某个东西跟 Nothing。那结果就会是某个东西。如果我们 mappend 两个 Just，那 Just 包住的结果就会 mappended 在一起并放回 Just。我们能这么做是因为 class constraint 保证了在 Just 中的值是 Monoid。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> Nothing <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> Just <span class="token string">&quot;andy&quot;</span>  
Just <span class="token string">&quot;andy&quot;</span>  
ghci<span class="token operator">&gt;</span> Just LT <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> Nothing  
Just LT  
ghci<span class="token operator">&gt;</span> Just <span class="token punctuation">(</span>Sum <span class="token number">3</span><span class="token punctuation">)</span> <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> Just <span class="token punctuation">(</span>Sum <span class="token number">4</span><span class="token punctuation">)</span>  
Just <span class="token punctuation">(</span>Sum <span class="token punctuation">{</span>getSum <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></div><p>这当你在处理有可能失败的 monoid 的时候比较有用。有了这个 instance，我们就不必一一去检查他们是否失败，是否是 Nothing 或是 Just，我们可以直接将他们当作普通的 monoid。</p><p>但如果在 Maybe 中的型别不是 Monoid 呢？注意到在先前的 instance 定义中，唯一有依赖于 monoid 限制的情况就是在 mappend 两个 Just 的时候。但如果我们不知道包在 Just 里面的值究竟是不是 monoid，我们根本无法用 mappend 操作他们，所以该怎么办呢？一种方式就是直接丢掉第二个值而留下第一个值。这就是 First a 存在的目的，而这是他的定义：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">newtype</span> <span class="token constant">First</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">First</span> <span class="token punctuation">{</span> <span class="token hvariable">getFirst</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token punctuation">}</span>  
    <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span></code></pre></div><p>我们接受一个 Maybe a 并把他包成 newtype，Monoid 的定义如下：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">First</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>  
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">First</span> <span class="token constant">Nothing</span>  
    <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  
    <span class="token constant">First</span> <span class="token constant">Nothing</span> <span class="token operator">`mappend`</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span></code></pre></div><p>正如我们说过得，mempty 就是包在 First 中的 Nothing。如果 mappend 的第一个参数是 Just，我们就直接忽略第二个参数。如果第一个参数是 Nothing，那我们就将第二个参数当作结果。并不管他究竟是 Just 或是 Nothing：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> getFirst $ First <span class="token punctuation">(</span>Just <span class="token string">&#x27;a&#x27;</span><span class="token punctuation">)</span> <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> First <span class="token punctuation">(</span>Just <span class="token string">&#x27;b&#x27;</span><span class="token punctuation">)</span>  
Just <span class="token string">&#x27;a&#x27;</span>  
ghci<span class="token operator">&gt;</span> getFirst $ First Nothing <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> First <span class="token punctuation">(</span>Just <span class="token string">&#x27;b&#x27;</span><span class="token punctuation">)</span>  
Just <span class="token string">&#x27;b&#x27;</span>  
ghci<span class="token operator">&gt;</span> getFirst $ First <span class="token punctuation">(</span>Just <span class="token string">&#x27;a&#x27;</span><span class="token punctuation">)</span> <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> First Nothing  
Just <span class="token string">&#x27;a&#x27;</span></code></pre></div><p>First 在我们有一大串 Maybe 而且想知道他们之中就竟有没有 Just 的时候很有用。可以利用 mconcat：</p><p>ghci&gt; getFirst . mconcat . map First $ <!-- -->[Nothing, Just 9, Just 10]<br/>
<!-- -->Just 9<br/>
<!-- -->如果我们希望定义一个 Maybe a 的 monoid，让他当 mappend 的两个参数都是 Just 的时候将第二个参数当作结果。Data.Monoid 中有一个现成的 Last a，他很像是 First a，只差在 mappend 跟 mconcat 会保留最后一个非 Nothing 的值。</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> getLast <span class="token builtin class-name">.</span> mconcat <span class="token builtin class-name">.</span> map Last $ <span class="token punctuation">[</span>Nothing, Just <span class="token number">9</span>, Just <span class="token number">10</span><span class="token punctuation">]</span>  
Just <span class="token number">10</span>  
ghci<span class="token operator">&gt;</span> getLast $ Last <span class="token punctuation">(</span>Just <span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span> <span class="token variable"><span class="token variable">`</span>mappend<span class="token variable">`</span></span> Last <span class="token punctuation">(</span>Just <span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>  
Just <span class="token string">&quot;two&quot;</span> 
Using monoids to <span class="token function">fold</span> data structures</code></pre></div><p>另一种有趣的 monoid 使用方式就是让他来帮助我们 fold 一些资料结构。到目前为止我们只有 fold list。但 list 并不是唯一一种可以 fold 的资料结构。我们几乎可以 fold 任何一种资料结构。像是 tree 也是一种常见的可以 fold 的资料结构。</p><p>由于有太多种资料结构可以 fold 了，所以我们定义了 Foldable 这个 typeclass。就像 Functor 是定义可以 map over 的结构。Foldable 是定义可以 fold 的结构。在 Data.Foldable 中有定义了一些有用的函数，但他们名称跟 Prelude 中的名称冲突。所以最好是用 qualified 的方式 import 他们：</p><p><code class="language-text">import qualified Foldable as F</code></p><p>为了少打一些字，我们将他们 import qualified 成 F。所以这个 typeclass 中定义了哪些函数呢？有 foldr，foldl，foldr1 跟 foldl1。你会说我们已经知道这些函数了，他们有什么不一样的地方吗？我们来比较一下 Foldable 中的 foldr 跟 Prelude 中的 foldr 的型别异同：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> :t foldr  
foldr :: <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> b  
ghci<span class="token operator">&gt;</span> :t F.foldr  
F.foldr :: <span class="token punctuation">(</span>F.Foldable t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>a -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> b<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> b -<span class="token operator">&gt;</span> t a -<span class="token operator">&gt;</span> b
<span class="token comment">#尽管 foldr 接受一个 list 并将他 fold 起来，Data.Foldable 中的 foldr 接受任何可以 fold 的型别。并不只是 list。 而两个 foldr 对于 list 的结果是相同的：</span>

ghci<span class="token operator">&gt;</span> foldr <span class="token punctuation">(</span>*<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>  
<span class="token number">6</span>  
ghci<span class="token operator">&gt;</span> F.foldr <span class="token punctuation">(</span>*<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">1,2</span>,3<span class="token punctuation">]</span>  
<span class="token number">6</span>  
<span class="token comment">#那有哪些资料结构支援 fold 呢？首先我们有 Maybe：</span>

ghci<span class="token operator">&gt;</span> F.foldl <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token number">2</span> <span class="token punctuation">(</span>Just <span class="token number">9</span><span class="token punctuation">)</span>  
<span class="token number">11</span>  
ghci<span class="token operator">&gt;</span> F.foldr <span class="token punctuation">(</span><span class="token operator">||</span><span class="token punctuation">)</span> False <span class="token punctuation">(</span>Just True<span class="token punctuation">)</span>  
True </code></pre></div><p>但 fold 一个 Maybe 并没什么新意。毕竟当他是 Just 的时候表现得像是只有单一元素的 list，而当他是 Nothing 的时候就像是空的 list 一样。所以我们来看一些比较复杂的资料结构。</p><p>还记得 Making Our Own Types and Typeclass 章节中的树状的资料结构吗？我们是这样定义的：</p><p><code class="language-text">data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)</code></p><p>我们说一棵树要不就是一棵空的树要不然就是一个包含值的节点，并且还指向另外两棵树。定义他之后，我们将他定义成 Functor 的 instance，因此可以 fmap 他。现在我们要将他定义成 Foldable 的 instance，这样我们就可以 fold 他。要定义成 Foldable 的一种方式就是实作 foldr。但另一种比较简单的方式就是实作 foldMap，他也属于 Foldable typeclass。foldMap 的型别如下：</p><p>foldMap :: (Monoid m, Foldable t) =&gt; (a -&gt; m) -&gt; t a -&gt; m<br/>
<!-- -->第一个参数是一个函数，这个函数接受 foldable 资料结构中包含的元素的型别，并回传一个 monoid。他第二个参数是一个 foldable 的结构，并包含型别 a 的元素。他将第一个函数来 map over 这个 foldable 的结构，因此得到一个包含 monoid 的 foldable 结构。然后用 mappend 来简化这些 monoid，最后得到单一的一个 monoid。这个函数听起来不太容易理解，但我们下面会看到他其实很容易实作。而且好消息是只要实作了这个函数就可以让我们的函数成为 Foldable。所以我们只要实作某个型别的 foldMap，我们就可以得到那个型别的 foldr 跟 foldl。</p><p>这就是我们如何定义 Tree 成为 Foldable 的：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token keyword">instance</span> <span class="token constant">F.Foldable</span> <span class="token constant">Tree</span> <span class="token keyword">where</span>  
    <span class="token hvariable">foldMap</span> <span class="token hvariable">f</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token hvariable">mempty</span>  
    <span class="token hvariable">foldMap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">F.foldMap</span> <span class="token hvariable">f</span> <span class="token hvariable">l</span> <span class="token operator">`mappend`</span>  
                                <span class="token hvariable">f</span> <span class="token hvariable">x</span>           <span class="token operator">`mappend`</span>  
                                <span class="token hvariable">F.foldMap</span> <span class="token hvariable">f</span> <span class="token hvariable">r</span>  </code></pre></div><p>我们是这样思考的：如果我们写一个函数，他接受树中的一个元素并回传一个 monoid，那我们要怎么简化整棵树到只有单一一个 monoid？当我们在对树做 fmap 的时候，我们将那函数套用至节点上，并递回地套用至左子树以及右子树。这边我们不只是 map 一个函数而已，我们还要求要把结果用 mappend 简化成只有单一一个 monoid 值。首先我们考虑树为空的情形，一棵没有值也没有子树的情形。由于没有值我们也没办法将他套用上面转换成 monoid 的函数，所以当树为空的时候，结果应该要是 mempty。</p><p>在非空节点的情形下比较有趣，他包含一个值跟两棵子树。在这种情况下，我们递回地做 foldMap，用 f 来套用到左子树跟右子树上。要记住我们的 foldMap 只会得到单一的 monoid 值。我们也会套用 f 到节点中的值。这样我们就得到三个 monoid 值，有两个来自简化子树的结果，还有一个是套用 f 到节点中的值的结果。而我们需要将这三个值整合成单一个值。要达成这个目的我们使用 mappend，而且自然地会想到照左子树，节点值以及右子树的顺序来简化。</p><p>注意到我们并不一定要提供一个将普通值转成 monoid 的函数。我们只是把他当作是 foldMap 的参数，我们要决定的只是如何套用那个函数，来把得到的 monoid 们简化成单一结果。</p><p>现在我们有树的 Foldable instance，而 foldr 跟 foldl 也有预设的实作了。考虑下面这棵树：</p><div class="gatsby-highlight" data-language="haskell"><pre class="language-haskell"><code class="language-haskell"><span class="token hvariable">testTree</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token number">5</span>  
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span>  
             <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>  
             <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">6</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>  
            <span class="token punctuation">)</span>  
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">9</span>  
             <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>  
             <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">10</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>  
            <span class="token punctuation">)</span>  </code></pre></div><p>他的 root 是 5，而他左边下来分别是 3，再来是 1 跟 6。而右边下来是 9，再来是 8 跟 10。有了 Foldable 的定义，我们就能像对 list 做 fold 一样对树做 fold：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> F.foldl <span class="token punctuation">(</span>+<span class="token punctuation">)</span> <span class="token number">0</span> testTree  
<span class="token number">42</span>  
ghci<span class="token operator">&gt;</span> F.foldl <span class="token punctuation">(</span>*<span class="token punctuation">)</span> <span class="token number">1</span> testTree  
<span class="token number">64800</span>  </code></pre></div><p>foldMap 不只是定义 Foldable 新的 instance 有用。他也对简化我们的结构至单一 monoid 值有用。举例来说，如果我们想要知道我们的树中有没有 3，我们可以这样做：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> getAny $ F.foldMap <span class="token punctuation">(</span><span class="token punctuation">\</span>x -<span class="token operator">&gt;</span> Any $ x <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> testTree  
True 
<span class="token comment">#这边 \x -&gt; Any $ x == 3 是一个接受一个数值并回传一个 monoid 的函数，也就是一个包在 Any 中的 Bool。foldMap 将这个函数套用至树的每一个节点，并把结果用 mappend 简化成单一 monoid。如果我们这样做：</span>

ghci<span class="token operator">&gt;</span> getAny $ F.foldMap <span class="token punctuation">(</span><span class="token punctuation">\</span>x -<span class="token operator">&gt;</span> Any $ x <span class="token operator">&gt;</span> <span class="token number">15</span><span class="token punctuation">)</span> testTree  
False</code></pre></div><p>经过套用 lambda 之后我们所有的节点都会是 Any False。但 mappend 必须要至少吃到一个 True 才能让最后的结果变成 True。这也是为什么结果会是 False，因为我们树中所有的值都大于 15。</p><p>我们也能将 foldMap 配合 \x -&gt; <!-- -->[x]<!-- --> 使用来将我们的树转成 list。经过套用那个函数后，所有节点都变成包含单一元素的 list。最后用 mappend 将这些单一元素的 list 转成一个装有全部元素的 list：</p><div class="gatsby-highlight" data-language="shell"><pre class="language-shell"><code class="language-shell">ghci<span class="token operator">&gt;</span> F.foldMap <span class="token punctuation">(</span><span class="token punctuation">\</span>x -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span> testTree  
<span class="token punctuation">[</span><span class="token number">1,3</span>,6,5,8,9,10<span class="token punctuation">]</span></code></pre></div><p>这个小技巧并不限于树而已，他可以被套用在任何 Foldable 上。</p></div></main><footer class="default-footer"><span>© <!-- -->2020<!-- -->, Built with <a href="https://www.gatsbyjs.org">Gatsby</a></span><div>本博客仍在勘误阶段，请务必结合网络资料再参考本博客内容。作者保留对本博客的版权。</div></footer></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/haskell/functors&ApplicativeFunctors/";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-d7582d95c9caea4cf506.js"],"app":["/app-14d25a46968a3c2b56f1.js"],"component---src-pages-404-js":["/component---src-pages-404-js-c8574fd6b23f8c753fd5.js"],"component---src-pages-index-js":["/component---src-pages-index-js-a14c9b6680105873db99.js"],"component---src-templates-arcive-js":["/component---src-templates-arcive-js-f7204a8e0ce011b74585.js"],"component---src-templates-graphics-js":["/component---src-templates-graphics-js-2002f9bd1124926889ef.js"],"component---src-templates-haskell-js":["/component---src-templates-haskell-js-30289d0cce2065e4a20c.js"],"component---src-templates-math-js":["/component---src-templates-math-js-240b0bb383a92a3235ec.js"],"component---src-templates-network-js":["/component---src-templates-network-js-9bf616f602c34197a5a9.js"],"component---src-templates-tags-js":["/component---src-templates-tags-js-f44d3b4e90e0254dd68e.js"]};/*]]>*/</script><script src="/blog/polyfill-d7582d95c9caea4cf506.js" nomodule=""></script><script src="/blog/component---src-templates-haskell-js-30289d0cce2065e4a20c.js" async=""></script><script src="/blog/18d2a1d1bd11dfeb160d0f057d2a379edc7a722f-715d20d2b55ae16f8940.js" async=""></script><script src="/blog/530275e58203fbd3f547d44d34265e339f2a60ee-702422cc019cc7fbae4b.js" async=""></script><script src="/blog/commons-c87939d66181bb0ac368.js" async=""></script><script src="/blog/styles-c2fe8482057191dca484.js" async=""></script><script src="/blog/app-14d25a46968a3c2b56f1.js" async=""></script><script src="/blog/framework-760826a8d97e681b6d2c.js" async=""></script><script src="/blog/webpack-runtime-68ebc8805482afd56a55.js" async=""></script></body></html>