<!DOCTYPE html><html lang="cn"><head><meta charSet="UTF-8"/><title>Graphics Programming(五) —— 光照 | Graphics</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Graphics Programming(五) —— 光照 | Graphics"/><meta name="description" content="Personal Blog"/><meta property="og:description" content="Personal Blog"/><meta property="og:type" content="website"/><meta property="twitter:card" content="summary_large_image"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="9"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/26ec16ccb915de94.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/26ec16ccb915de94.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-6965b024cefed38b.js" defer=""></script><script src="/blog/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/blog/_next/static/chunks/main-aa6243415bc34dcf.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-ae897f29056b30d9.js" defer=""></script><script src="/blog/_next/static/chunks/29107295-2a9ca7f07685bf37.js" defer=""></script><script src="/blog/_next/static/chunks/117b9d7f-1415b8d5c023097d.js" defer=""></script><script src="/blog/_next/static/chunks/664-d254d21a6fe56bff.js" defer=""></script><script src="/blog/_next/static/chunks/475-f757a87f3cd5d391.js" defer=""></script><script src="/blog/_next/static/chunks/675-d64d4792f164bc88.js" defer=""></script><script src="/blog/_next/static/chunks/295-669440b57b4b1b5e.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bcollection%5D/%5B...slug%5D-7308aaad3bf994ab.js" defer=""></script><script src="/blog/_next/static/0afKTWA4-aQ1T3YyCw1HF/_buildManifest.js" defer=""></script><script src="/blog/_next/static/0afKTWA4-aQ1T3YyCw1HF/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header data-theme="dark" class="style_nav-root__jrAJR" style="height:80px"><section class="style_nav-section__sS_tB"><a class="style_nav-logo__jRYAT" href="/blog"><h3>Allen Lee@Blog</h3></a><nav aria-label="Main" data-orientation="horizontal" dir="ltr" class="style_nav-menus__4aQM9"><div style="position:relative"><ul data-orientation="horizontal" dir="ltr"><li><button class="style_btn__AkQj7 style_subtle__i70rQ style_nav-trigger__ekUye" id="radix-:Rj6:-trigger-radix-:Rjj6:" data-state="closed" aria-expanded="false" aria-controls="radix-:Rj6:-content-radix-:Rjj6:" data-radix-collection-item="">Overview <svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 15 15" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor"></path></svg></button></li></ul></div></nav></section></header><main data-theme="light" style="background-color:var(--colorNeutralBackground1);overflow-x:hidden;overflow-y:auto;width:100vw;height:calc(100vh - 80px)" id="main"><div class="collection_slug_Root__xztwf style_mainStyle__8eIxs"><div class="style_graphicsPost__36P1T"><h1><a href="#" title="undefined" class="style_titleStyle__6CuPY">Graphics Programming(五) —— 光照</a></h1><p>计算机图形学第一定律:</p>
<p></p>
<div style="width:100%;text-align:center;margin:0.5rem auto"><span class="style_aphorism__ue0s6">如果它看起来是对的, 那么它就是对的</span></div>
<p>
光照基础</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">光源</div>: 发出光线<div class="style_Tab__IjTlz style_hidden__yfyDi">表示: 一个点, 用 l 表示其方向<br/>
拥有五个关键因素: 位置, 方向, 颜色, 强度及<span class="style_Quote__dLoMM" id="#9">衰减</span><br/>
unity分为<div role="expansion" class="style_Expansion__lekPG">平行光, 点光源, 聚光灯</div>
和面光源(只在烘焙时起作用)<div class="style_Tab__IjTlz style_hidden__yfyDi">平行光: 只有方向属性, 到场景中所有点的方向相同, 光强不会因距离而衰减<br/>
点光源: 有位置属性(方向靠算), 照亮空间为四周呈球形, 光强因距离远近而衰减<br/>
聚光灯: 有位置属性(方向靠算), 照亮空间为锥形, 光强因距离远近而衰减</div><br/></div><br/><div role="expansion" class="style_Expansion__lekPG">吸收和散射</div>: 光线与物体相交时, 一部分吸收一部分散射<div class="style_Tab__IjTlz style_hidden__yfyDi">散射(scattering): 改变光线方向, 但不改变其性质.<div class="style_Tab__IjTlz">若散射到物体内部, 称为折射(refraction)或透射(transmission)<br/>
若散射到物体外表面, 称为反射(reflection)</div>吸收(absorption): 吸收改变性质, 但不改变方向.<br/>
计量: 出射度(exitance) = β辐射度, β值由材质的漫反射和高光反射来部分决定</div><br/><div role="expansion" class="style_Expansion__lekPG">着色</div>:<div class="style_Tab__IjTlz style_hidden__yfyDi">严格的讲(物理): 物体反射特定颜色的光, 该光被接收而感受到颜色<br/>
定义(图形学): 着色(shading)指根据材质信息,
光源信息来计算沿某个观察方向出射度的<span class="style_Quote__dLoMM" id="#1">一个等式</span><br/>
分为各向同性和各向异性光<div class="style_Tab__IjTlz">各向同性(isotropic): 参数不变时, 旋转物体反射光不产生变化<br/>
各向异性(anisotropic): 参数不变时 ,旋转物体反射光产生变化</div></div><br/></div>
<p></p>
<p>光照模型</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">光照计算位置</div><div class="style_Tab__IjTlz style_hidden__yfyDi">逐顶点(per-vertex lighting): 在顶点着色器中计算<div class="style_Tab__IjTlz">得到法线数据, 然后进行插值计算. 称为Gouraud着色<br/>每个顶点计算光照, 会在渲染图元内部进行线性插值, 使得图片&quot;棱角分明&quot;,
且容易出错</div>逐像素(per-pixel lighting): 在片元着色器中计算
<div class="style_Tab__IjTlz">得到法线数据, 然后进行插值计算. 称为Phong着色</div></div><br/><div role="expansion" class="style_Expansion__lekPG">渲染路径</div><div class="style_Tab__IjTlz style_hidden__yfyDi">渲染路径(Rendering Path): 决定光照如何运用到shader中<br/>不同渲染路径, shader可以访问的内置变量及函数也不同<table><thead><tr><td align="center" colSpan="2" style="font-size:20px">LightMode的渲染路径选项</td></tr></thead><tbody><tr><td>Always</td><td>该Pass总会被渲染, 但不计算任何光照</td></tr><tr><td>ForwardBase</td><td>前向渲染. (计算环境光, 关键平行光, 逐顶点/SH光源和Lightmaps)</td></tr><tr><td>ForwardAdd</td><td>前向渲染. (计算额外的逐像素光源, 每个Pass对应一个光源)</td></tr><tr><td>Deferred</td><td>延迟渲染. (会渲染G-buffer)</td></tr><tr><td>ShadowCaster</td><td>把物体的深度信息渲染到阴影映射纹理(shadowmap)或深度纹理中</td></tr></tbody></table><div role="expansion" class="style_Expansion__lekPG">前向渲染(Forward)</div><div class="style_Tab__IjTlz style_hidden__yfyDi">该路径指明: 对每个逐像素光源来说, 其中受影响的每个图元,
必需经过&quot;深度缓冲区&quot;和&quot;颜色缓冲区&quot;<br/>有三种处理光照的方式: 逐顶点处理, 逐像素处理, 球谐函数(Spherical
Harmonics,SH)处理<br/>对于场景中所有光源, unity会按<span class="style_Quote__dLoMM" id="#5">一定规则</span>:
指定一定数目的逐像素光源; 最多4个逐顶点; 剩下的按SH处理<br/>其Pass被分为<span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R2ip8vl6:" data-state="closed">Base和Add</span>两种<br/>当场景包含大量实时光源时, 前向渲染速度会急速下降</div><br/><div role="expansion" class="style_Expansion__lekPG">延迟渲染</div><div class="style_Tab__IjTlz style_hidden__yfyDi">除&quot;深度缓冲区&quot;和颜色缓冲区外, 延迟渲染将访问
<span class="style_Quote__dLoMM" id="#6">G-buffer</span>, 包含两个Pass<br/>第一个Pass不进行光照计算, 仅仅决定片元的可见性(可见信息存储于G-buffer),
每个物体只执行一次<br/>第二个利用G-buffer计算光照,<!-- --> <!-- -->
<span class="style_Quote__dLoMM" id="#7">且仅能使用Standard光照模型</span><br/>其不依赖于场景复杂度, 只和使用的屏幕空间大小有关<br/>延迟渲染不能使用抗锯齿和处理半透明</div><br/><span class="style_Quote__dLoMM" id="#8">选用何种路径?</span><br/>附录: <span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R1h8vl6:" data-state="closed">常用内置光照变量</span></div><br/><span class="style_Quote__dLoMM" id="#4">标准光照模型</span>:<div class="style_Tab__IjTlz">标准光照模型只关心光照(direct light). 即直接从光源发射照射到物体后,
经过一次反射直接进入摄像机<br/>基本方法: 计算<div role="expansion" class="style_Expansion__lekPG">自发光, 高光反射, 漫反射和环境光</div>的
<span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rpevl6:" data-state="closed">贡献度</span>, 最后得出SCORE<div class="style_Tab__IjTlz style_hidden__yfyDi">环境光(ambient): 用以模拟<span class="style_Quote__dLoMM" id="#2">间接光照</span>对物体的影响<br/><span class="style_Quote__dLoMM" id="#3">自发光(emissive)</span>:
直接由光源不经过任何反射进入摄像机<br/><div role="expansion" class="style_Expansion__lekPG">漫反射(diffuse)</div>:
用于对被物体表面随机散射到各方向的辐射度进行建模<div class="style_Tab__IjTlz style_hidden__yfyDi">视角的位置是不重要的,
因为反射是完全随机的(近乎于每个方向都是一样的分布); 但入射光线十分重要<br/>符合兰伯特定理(Lambert&#x27;s law):
反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比<br/>也有<span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:R36j1evl6:" data-state="closed">半兰伯特模型</span>: 只是为了增强视觉效果,
没有物理依据</div><br/><div role="expansion" class="style_Expansion__lekPG">高光反射(specular)</div>:
计算沿着完全镜面反射方向反射的光线<div class="style_Tab__IjTlz style_hidden__yfyDi">一种经验模型<br/>计算时需要知道: 表面法线, 视角方向, 光源方向, 反射方向等单位矢量<br/>有两种模型: Phong模型和Blinn模型</div><br/></div><br/></div>BRDF光照模型(Bidirectional Reflectance Distribution Function)<div class="style_Tab__IjTlz">BRDF是对真实环境理想化和简化后的模型, 并不能真正的反映物体和光线的交互,
被称为经验模型.<br/>当给定模型表面上一点时, BRDF给出其外观的完整描述</div></div><div id="Comment" class="style_Comment__GsBhh"></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"matter":{"title":"Graphics Programming(五) —— 光照","tags":["graphics"],"index":5},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/illumination.mdx","type":"mdx","slug":["illumination"],"collection":"graphics","url":"/graphics/illumination"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(五) —— 光照\",\n  \"tags\": [\"graphics\"],\n  \"index\": 5\n};\nconst QuoteList = [\"这个等式也被称为光照模型(Lighting Model)\", \"间接光照(indirect light): 进入摄像机的光照之前经过了不止一次的反射\", \"如果没有使用全局光照技术(global illumination), 自发光并不会作为一个光源照射物体, 只是使得自身亮度提高\", \"亦称位Blinn-Phong模型. 是一种各向同性的模型, 无法实现菲涅尔反射(Fresnel reflection)\", \"场景中最亮的平行光一定是按逐像素处理(且在Base中处理)\u003cbr/\u003e渲染模式设置为\\\"Not Important\\\"的按逐顶点或SH\u003cbr/\u003e渲染模式设置为\\\"Important\\\"的按逐像素处理\u003cbr/\u003e若以上规则小于Quality Setting中的Pixel Light Count, 则更多光源按逐像素\", \"G-buffer(Geometry-buffer)存储了表面法线, 位置, 用于光照计算的材质属性等\", \"其它光照参考: https://docs.unity3d.com/Manual/RenderTech-DefferedShadering.html\", \"参考: https://docs.unity3d.com/Manual/RenderingPath.html\", \"unity为简化计算会使用_LightTexture0(cookie后, 为_LightTextureB0)计算衰减, 但不够精确. 因此通常使用数学计算和衰减纹理来共同计算\", \"可以将Fallback设置为VertexLit或Diffuse等不透明物体的shader. 虽然可以接收和投射阴影, 但效果和不透明物体一样\"];\nconst ImgList = [\"Blinn-Phong光照模型\", \"halfLambert\", \"前向渲染的两种Pass\", \"常用内置光照变量\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    p: \"p\",\n    ...props.components\n  }, {Aphorism, Expansion, Model, Quote, Tab, Table} = _components;\n  if (!Aphorism) _missingMdxReference(\"Aphorism\", true);\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Model) _missingMdxReference(\"Model\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  if (!Table) _missingMdxReference(\"Table\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"计算机图形学第一定律:\"\n    }), \"\\n\", _jsx(_components.p, {}), \"\\n\", _jsx(Aphorism, {\n      children: \"如果它看起来是对的, 那么它就是对的\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"\\n光照基础\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"光源\"\n      }), \": 发出光线\", _jsxs(Tab, {\n        expan: true,\n        children: [\"表示: 一个点, 用 l 表示其方向\", _jsx(\"br\", {}), \"\\n拥有五个关键因素: 位置, 方向, 颜色, 强度及\", _jsx(Quote, {\n          id: \"#9\",\n          children: \"衰减\"\n        }), _jsx(\"br\", {}), \"\\nunity分为\", _jsx(Expansion, {\n          children: \"平行光, 点光源, 聚光灯\"\n        }), \"\\n和面光源(只在烘焙时起作用)\", _jsxs(Tab, {\n          expan: true,\n          children: [\"平行光: 只有方向属性, 到场景中所有点的方向相同, 光强不会因距离而衰减\", _jsx(\"br\", {}), \"\\n点光源: 有位置属性(方向靠算), 照亮空间为四周呈球形, 光强因距离远近而衰减\", _jsx(\"br\", {}), \"\\n聚光灯: 有位置属性(方向靠算), 照亮空间为锥形, 光强因距离远近而衰减\"]\n        })]\n      }), _jsx(Expansion, {\n        children: \"吸收和散射\"\n      }), \": 光线与物体相交时, 一部分吸收一部分散射\", _jsxs(Tab, {\n        expan: true,\n        children: [\"散射(scattering): 改变光线方向, 但不改变其性质.\", _jsxs(Tab, {\n          children: [\"若散射到物体内部, 称为折射(refraction)或透射(transmission)\", _jsx(\"br\", {}), \"\\n若散射到物体外表面, 称为反射(reflection)\"]\n        }), \"吸收(absorption): 吸收改变性质, 但不改变方向.\", _jsx(\"br\", {}), \"\\n计量: 出射度(exitance) = β辐射度, β值由材质的漫反射和高光反射来部分决定\"]\n      }), _jsx(Expansion, {\n        children: \"着色\"\n      }), \":\", _jsxs(Tab, {\n        expan: true,\n        children: [\"严格的讲(物理): 物体反射特定颜色的光, 该光被接收而感受到颜色\", _jsx(\"br\", {}), \"\\n定义(图形学): 着色(shading)指根据材质信息,\\n光源信息来计算沿某个观察方向出射度的\", _jsx(Quote, {\n          id: \"#1\",\n          children: \"一个等式\"\n        }), _jsx(\"br\", {}), \"\\n分为各向同性和各向异性光\", _jsxs(Tab, {\n          children: [\"各向同性(isotropic): 参数不变时, 旋转物体反射光不产生变化\", _jsx(\"br\", {}), \"\\n各向异性(anisotropic): 参数不变时 ,旋转物体反射光产生变化\"]\n        })]\n      })]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"光照模型\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"光照计算位置\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"逐顶点(per-vertex lighting): 在顶点着色器中计算\", _jsxs(Tab, {\n          children: [\"得到法线数据, 然后进行插值计算. 称为Gouraud着色\", _jsx(\"br\", {}), \"每个顶点计算光照, 会在渲染图元内部进行线性插值, 使得图片\\\"棱角分明\\\",\\n且容易出错\"]\n        }), \"逐像素(per-pixel lighting): 在片元着色器中计算\\n\", _jsx(Tab, {\n          children: \"得到法线数据, 然后进行插值计算. 称为Phong着色\"\n        })]\n      }), _jsx(Expansion, {\n        children: \"渲染路径\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"渲染路径(Rendering Path): 决定光照如何运用到shader中\", _jsx(\"br\", {}), \"不同渲染路径, shader可以访问的内置变量及函数也不同\", _jsx(Table, {\n          title: \"LightMode的渲染路径选项\",\n          children: [{\n            cells: [\"Always\", \"该Pass总会被渲染, 但不计算任何光照\"]\n          }, {\n            cells: [\"ForwardBase\", \"前向渲染. (计算环境光, 关键平行光, 逐顶点/SH光源和Lightmaps)\"]\n          }, {\n            cells: [\"ForwardAdd\", \"前向渲染. (计算额外的逐像素光源, 每个Pass对应一个光源)\"]\n          }, {\n            cells: [\"Deferred\", \"延迟渲染. (会渲染G-buffer)\"]\n          }, {\n            cells: [\"ShadowCaster\", \"把物体的深度信息渲染到阴影映射纹理(shadowmap)或深度纹理中\"]\n          }]\n        }), _jsx(Expansion, {\n          children: \"前向渲染(Forward)\"\n        }), _jsxs(Tab, {\n          expan: true,\n          children: [\"该路径指明: 对每个逐像素光源来说, 其中受影响的每个图元,\\n必需经过\\\"深度缓冲区\\\"和\\\"颜色缓冲区\\\"\", _jsx(\"br\", {}), \"有三种处理光照的方式: 逐顶点处理, 逐像素处理, 球谐函数(Spherical\\nHarmonics,SH)处理\", _jsx(\"br\", {}), \"对于场景中所有光源, unity会按\", _jsx(Quote, {\n            id: \"#5\",\n            children: \"一定规则\"\n          }), \":\\n指定一定数目的逐像素光源; 最多4个逐顶点; 剩下的按SH处理\", _jsx(\"br\", {}), \"其Pass被分为\", _jsx(Model, {\n            about: \"@3\",\n            children: \"Base和Add\"\n          }), \"两种\", _jsx(\"br\", {}), \"当场景包含大量实时光源时, 前向渲染速度会急速下降\"]\n        }), _jsx(Expansion, {\n          children: \"延迟渲染\"\n        }), _jsxs(Tab, {\n          expan: true,\n          children: [\"除\\\"深度缓冲区\\\"和颜色缓冲区外, 延迟渲染将访问\\n\", _jsx(Quote, {\n            id: \"#6\",\n            children: \"G-buffer\"\n          }), \", 包含两个Pass\", _jsx(\"br\", {}), \"第一个Pass不进行光照计算, 仅仅决定片元的可见性(可见信息存储于G-buffer),\\n每个物体只执行一次\", _jsx(\"br\", {}), \"第二个利用G-buffer计算光照,\", \" \", \"\\n\", _jsx(Quote, {\n            id: \"#7\",\n            children: \"且仅能使用Standard光照模型\"\n          }), _jsx(\"br\", {}), \"其不依赖于场景复杂度, 只和使用的屏幕空间大小有关\", _jsx(\"br\", {}), \"延迟渲染不能使用抗锯齿和处理半透明\"]\n        }), _jsx(Quote, {\n          id: \"#8\",\n          children: \"选用何种路径?\"\n        }), _jsx(\"br\", {}), \"附录: \", _jsx(Model, {\n          about: \"@4\",\n          children: \"常用内置光照变量\"\n        })]\n      }), _jsx(Quote, {\n        className: \"Quote\",\n        id: \"#4\",\n        children: \"标准光照模型\"\n      }), \":\", _jsxs(Tab, {\n        children: [\"标准光照模型只关心光照(direct light). 即直接从光源发射照射到物体后,\\n经过一次反射直接进入摄像机\", _jsx(\"br\", {}), \"基本方法: 计算\", _jsx(Expansion, {\n          children: \"自发光, 高光反射, 漫反射和环境光\"\n        }), \"的\\n\", _jsx(Model, {\n          about: \"@1\",\n          children: \"贡献度\"\n        }), \", 最后得出SCORE\", _jsxs(Tab, {\n          expan: true,\n          children: [\"环境光(ambient): 用以模拟\", _jsx(Quote, {\n            id: \"#2\",\n            children: \"间接光照\"\n          }), \"对物体的影响\", _jsx(\"br\", {}), _jsx(Quote, {\n            id: \"#3\",\n            children: \"自发光(emissive)\"\n          }), \":\\n直接由光源不经过任何反射进入摄像机\", _jsx(\"br\", {}), _jsx(Expansion, {\n            children: \"漫反射(diffuse)\"\n          }), \":\\n用于对被物体表面随机散射到各方向的辐射度进行建模\", _jsxs(Tab, {\n            expan: true,\n            children: [\"视角的位置是不重要的,\\n因为反射是完全随机的(近乎于每个方向都是一样的分布); 但入射光线十分重要\", _jsx(\"br\", {}), \"符合兰伯特定理(Lambert's law):\\n反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比\", _jsx(\"br\", {}), \"也有\", _jsx(Model, {\n              about: \"@2\",\n              children: \"半兰伯特模型\"\n            }), \": 只是为了增强视觉效果,\\n没有物理依据\"]\n          }), _jsx(Expansion, {\n            children: \"高光反射(specular)\"\n          }), \":\\n计算沿着完全镜面反射方向反射的光线\", _jsxs(Tab, {\n            expan: true,\n            children: [\"一种经验模型\", _jsx(\"br\", {}), \"计算时需要知道: 表面法线, 视角方向, 光源方向, 反射方向等单位矢量\", _jsx(\"br\", {}), \"有两种模型: Phong模型和Blinn模型\"]\n          })]\n        })]\n      }), \"BRDF光照模型(Bidirectional Reflectance Distribution Function)\", _jsxs(Tab, {\n        children: [\"BRDF是对真实环境理想化和简化后的模型, 并不能真正的反映物体和光线的交互,\\n被称为经验模型.\", _jsx(\"br\", {}), \"当给定模型表面上一点时, BRDF给出其外观的完整描述\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  ImgList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"}]},"__N_SSG":true},"page":"/[collection]/[...slug]","query":{"collection":"graphics","slug":["illumination"]},"buildId":"0afKTWA4-aQ1T3YyCw1HF","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>