{"pageProps":{"post":{"matter":{"title":"Graphics Programming(一) —— 渲染流水线","tags":["graphics","index"],"index":1},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/index.mdx","type":"mdx","slug":["index"],"collection":"graphics","url":"/graphics/index"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(一) —— 渲染流水线\",\n  \"tags\": [\"graphics\", \"index\"],\n  \"index\": 1\n};\nconst QuoteList = ['\"数据总线\"是用于在多个设备间传输数据的通道. \"端口\"是用于在两个设备间传输数据的通道, 总线和端口将功能模块粘结在一起', \"视锥裁剪(Frustum Culling)在视锥(viewing frustum)中运行并非易事, 因此放在规范立方体(Canonical view volume, CVV 一个单位立方体)中经行\", \"Object space --> World space 转换: 通常称为world matrix来转换\", \"World space --> View space 转换: GPU运算\", \"View space --> Project space 转换: 1. 用透视变换将顶点变换到CVV中; 2. 在CVV中经行视锥裁剪; 3. 将坐标映射到屏幕坐标系\", '意味着无法获取例如\"是否是同一网格\"之类的信息, 但同时GPU可以并行处理', \"齐次裁剪坐标也就是CVV坐标. 需要注意的是其深度值Z, 在OpenGL和Unity中, 范围是[-1, 1]; 而Direct中, 范围是[0, 1]\", \"关于c++视锥裁剪算法请参考: OGRE(Object-Oriented Graphics Rendering Engine)的源码\", \"这一阶段也被称为扫描变换(Scan Conversion)\", \"由于后置测试中被舍弃的片元会浪费前面的性能, 因此GPU通常会判断片元着色器和提前测试(Early-Z)是否冲突来决定是否使用提前测试. 如果冲突将禁用提前测试开启后置测试\", \"在OpenGL中是glDrawElements, DirectX中是DrawIndexedPrimitive\", \"现代渲染管线也称为可编程管线. 在较旧的GPU上称为固定函数流水线(Fixed-Function Pipeline), 这是一种配置管线(只提供开关功能)\", \"此部分内容会在第四部分(编写shader的数学基础)中完整叙述\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    a: \"a\",\n    h2: \"h2\",\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    path: \"path\",\n    svg: \"svg\",\n    ...props.components\n  }, {Anchor, Expansion, Quote, Tab, Table} = _components;\n  if (!Anchor) _missingMdxReference(\"Anchor\", true);\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  if (!Table) _missingMdxReference(\"Table\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsxs(_components.h2, {\n      id: \"现代渲染管线分为三个主要阶段\",\n      children: [_jsx(Quote, {\n        id: \"#12\",\n        children: \"现代渲染管线\"\n      }), \"分为三个主要阶段:\", _jsx(_components.a, {\n        className: \"anchor after\",\n        \"aria-hidden\": true,\n        \"aria-label\": \"permalink\",\n        tabIndex: \"-1\",\n        href: \"#现代渲染管线分为三个主要阶段\",\n        children: _jsx(_components.svg, {\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          viewBox: \"0 0 16 16\",\n          focusable: \"false\",\n          children: _jsx(_components.path, {\n            d: \"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\",\n            fillRule: \"evenodd\"\n          })\n        })\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.a, {\n        href: \"#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%98%B6%E6%AE%B5:\",\n        children: \"应用程序阶段\"\n      }), \" --> \", _jsx(_components.a, {\n        href: \"#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5:\",\n        children: \"几何阶段\"\n      }), \" --> \", _jsx(_components.a, {\n        href: \"#%E5%85%89%E6%A0%85%E9%98%B6%E6%AE%B5:\",\n        children: \"光栅阶段\"\n      })]\n    }), \"\\n\", _jsx(\"br\", {}), \"\\n\", _jsx(Anchor, {\n      children: \"应用程序阶段:\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"主要和 CPU,内存打交道. 该阶段末端, 渲染所需的数据(渲染图元 rendering primitives)通过\", _jsx(Quote, {\n        id: \"#1\",\n        children: \"数据总线\"\n      }), \"传送到 GPU\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"将渲染图元读取到显存中: 从硬盘 HDD --> 内存 RAM --> 显存 VRAM\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"确定网格怎样被渲染\"\n          }), \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"在Unity中, 通常是使用MeshRender来将信息传递给GPU.\", _jsx(\"br\", {}), \"\\n特别的, 在3D模型中:\", _jsxs(Tab, {\n              children: [\"skin mesh render: 带蒙皮的骨骼\", _jsx(\"br\", {}), \"\\nmesh filter/ mesh render: 将哪个mesh信息传递给GPU/ 没有骨骼的模型\"]\n            })]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: _jsx(Quote, {\n              id: \"#11\",\n              children: \"调用Draw Call\"\n            })\n          }), \"\\n\", \": CPU 通知 GPU 渲染\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"CPU向一个队列\\\"命令缓冲区\\\"push命令, 而GPU从其中pull命令.\", _jsx(\"br\", {}), \"\\n这样实现了CPU和GPU的并行工作\", _jsx(\"br\", {}), \"\\n通常性能的优化都会减少Draw Call的个数\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(Anchor, {\n      children: \"几何阶段:\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"主要和 GPU 打交道. 该阶段末端, 得到经过变换和投影之后的顶点坐标, 颜色及纹理坐标\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"顶点着色器\"\n          }), \"\\n\", \": 实现顶点空间变换, 顶点着色, 光照等(可编程)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"它的输入来自于CPU. 每个顶点都会调用一次顶点着色器.\", _jsx(\"br\", {}), \"\\n顶点着色器本身本可以创建和销毁任何顶点, 而且\\n\", _jsx(Quote, {\n              id: \"#6\",\n              children: \"顶点顶点之间是相互独立的\"\n            }), \".\", _jsx(\"br\", {}), \"\\n它最基本且必须完成的工作是: 将顶点坐标从 模型空间 转换到 \", _jsx(Quote, {\n              id: \"#7\",\n              children: \"\\n齐次裁剪坐标系\\n\"\n            }), \" 下\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"曲面细分着色器\"\n          }), \"\\n\", \": 用于细分图元(可选着色器, 可编程)\\n\", \"\\n\", _jsx(Tab, {\n            expan: true,\n            children: \"很遗憾, 此部分并没有学到.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"几何着色器\"\n          }), \"\\n\", \":\\n执行逐图元的着色(Per-Primitive)或产生更多图元(可选着色器, 可编程)\\n\", \"\\n\", _jsx(Tab, {\n            expan: true,\n            children: \"很遗憾, 此部分并没有学到.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"裁剪\"\n          }), \"\\n\", \":\", \"\\n\", _jsx(Quote, {\n            id: \"#2\",\n            children: \"视锥裁剪\"\n          }), \"\\n\", \"(可配置)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"确认视锥(即选择投影类型)并裁剪\", _jsx(\"br\", {}), \"\\n裁剪并不一定是通过GPU来运算. 也可以\", _jsx(Quote, {\n              id: \"#8\",\n              children: \"通过CPU运算\"\n            }), \"\\n后直接跳过该步骤.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"屏幕映射\"\n          }), \"\\n\", \": 将CVV 转换为Clip and Project space\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"屏幕映射(Screen Mapping)并不会处理深度值Z.\", _jsx(\"br\", {}), \"\\n值得注意的是, OpenGL的坐标系将\\\"屏幕的左下角\\\"当作原点(0,0);\\n而DirectX的坐标系将\\\"屏幕的左上角\\\"当作原点(0,0)\"]\n          }), \"\\n\", \"附录: \", \"\\n\", _jsxs(Expansion, {\n            children: [\"\\n\", _jsx(Quote, {\n              id: \"#13\",\n              children: \"坐标空间\"\n            }), \"\\n\"]\n          }), \"\\n\", \": 依照先后顺序\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"Object space物体坐标系\\n\", _jsx(Quote, {\n              id: \"#3\",\n              children: \"-->\"\n            }), \"\\nWorld space世界坐标系\\n\", _jsx(Quote, {\n              id: \"#4\",\n              children: \"-->\"\n            }), \"\\nView space观察坐标系\\n\", _jsx(Quote, {\n              id: \"#5\",\n              children: \"-->\"\n            }), \"\\nProject space屏幕坐标系\", _jsx(Table, {\n              children: [{\n                cells: [\"Object space\", \"模型建立时得到的坐标. 与其它物体没有任何参照关系\"],\n                component: [\"th\"]\n              }, {\n                cells: [\"World space\", \"以一个固定的坐标原点经行参照确定物体位置\"],\n                component: [\"th\"]\n              }, {\n                cells: [\"View space\", \"以Camera为原点, 组成的正交坐标系\"],\n                component: [\"th\"]\n              }, {\n                cells: [\"Project space\", \"屏幕坐标系\"],\n                component: [\"th\"]\n              }]\n            })]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    }), \"\\n\", _jsx(Anchor, {\n      children: \"光栅阶段:\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"基于几何阶段输出的数据, 雾化, 透明及为pixel正确配色. 经行单个像素的操作, 每个pixel的信息存储在颜色缓冲器(color buffer 或frame buffer)中\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"三角形设置\"\n          }), \"\\n\", \": 计算光栅化一个三角网格所需的信息\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"上一阶段输出的是\\\"三角网格的顶点\\\"即每条边的两个端点.\\n如果需要得到三角网格对pixel的覆盖情况, 需要计算每条边的像素坐标.\", _jsx(\"br\", {}), \"三角形设置(Triangle Setup)通过计算三角形边界的表示形式来确定每条边的坐标\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"三角形遍历\"\n          }), \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [_jsx(Quote, {\n              id: \"#9\",\n              children: \"三角形遍历\"\n            }), \"(Triangle\\nTraversal)确定每个三角网格所覆盖的pixel, 并使用顶点信息对覆盖区域进行差值\", _jsx(\"br\", {}), \"遍历完成后的输出就称之为片元(fragment), 包含了深度值Z, 法线, 纹理等信息,\\n可以说是\\\"收集完全但未计算的像素信息\\\"\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"片元着色器\"\n          }), \"\\n\", \": 实现逐片元的着色(Per-Fragment)(可编程)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"这一阶段包含许多的渲染技术. 最重要的就是纹理采样(将贴图,\\n法线等颜色信息给片元)\", _jsx(\"br\", {}), \"但它仅能影响单个片元, 无法将结果发送给它周围的pixel.(法线信息除外)\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"逐片元操作\"\n          }), \"\\n\", \": 片元的可见性, 深度缓冲, 颜色混合等(可配置)\", \"\\n\", _jsxs(Tab, {\n            expan: true,\n            children: [\"在OpenGL中称为逐片元操作(Per-Fragment Operations),\\n在DirectX中称为输出合并阶段(Output-Merger)\", _jsx(\"br\", {}), \"需要经过\", _jsx(Expansion, {\n              children: _jsx(Quote, {\n                id: \"#10\",\n                children: \"两个测试\"\n              })\n            }), \", 来决定片元的可见性问题\", _jsxs(Tab, {\n              expan: true,\n              children: [\"模板测试 --> 深度测试\", _jsx(Table, {\n                children: [{\n                  cells: [\"模板测试\", \"通常用于限制渲染的区域. 也可以用来渲染阴影, 轮廓渲染等\"],\n                  component: [\"th\"]\n                }, {\n                  cells: [\"深度测试\", \"通常用于视野深度计算\"],\n                  component: [\"th\"]\n                }]\n              })]\n            }), \"之后需要经行混合(Blend)操作,\\n决定此次操作和前一次操作的关系(实现不透明(全覆盖)或半透明(局部覆盖))\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(Expansion, {\n            children: \"屏幕图像\"\n          }), \"\\n\", _jsx(Tab, {\n            expan: true,\n            children: \"使用通常所说的双缓冲技术(Double Buffering). 前置缓冲(front\\nbuffer)和后置缓冲(frame buffer|back buffer)交替显示\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[{"depth":2,"value":"现代渲染管线分为三个主要阶段:","id":"现代渲染管线分为三个主要阶段"}]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"},{"name":"practice","length":1}]},"__N_SSG":true}