<!DOCTYPE html><html lang="cn"><head><meta charSet="UTF-8"/><title>Graphics Programming(七) —— 透明效果 | Graphics</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta property="og:title" content="Graphics Programming(七) —— 透明效果 | Graphics"/><meta name="description" content="Personal Blog"/><meta property="og:description" content="Personal Blog"/><meta property="og:type" content="website"/><meta property="twitter:card" content="summary_large_image"/><link rel="icon" type="image/x-icon" href="/favicon.ico"/><meta name="next-head-count" content="9"/><link data-next-font="" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/5f7c6aaf759aa20d.css" data-n-g=""/><link rel="preload" href="/blog/_next/static/css/b8491e953adc923d.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/b8491e953adc923d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/blog/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/blog/_next/static/chunks/webpack-6965b024cefed38b.js" defer=""></script><script src="/blog/_next/static/chunks/framework-49c6cecf1f6d5795.js" defer=""></script><script src="/blog/_next/static/chunks/main-aa6243415bc34dcf.js" defer=""></script><script src="/blog/_next/static/chunks/pages/_app-ae897f29056b30d9.js" defer=""></script><script src="/blog/_next/static/chunks/29107295-2a9ca7f07685bf37.js" defer=""></script><script src="/blog/_next/static/chunks/117b9d7f-1415b8d5c023097d.js" defer=""></script><script src="/blog/_next/static/chunks/664-d254d21a6fe56bff.js" defer=""></script><script src="/blog/_next/static/chunks/475-14dfd807b1d12a64.js" defer=""></script><script src="/blog/_next/static/chunks/675-d64d4792f164bc88.js" defer=""></script><script src="/blog/_next/static/chunks/873-2d6d31d807f2bee5.js" defer=""></script><script src="/blog/_next/static/chunks/pages/%5Bcollection%5D/%5B...slug%5D-6e128b057fe80065.js" defer=""></script><script src="/blog/_next/static/ZyG-RamwQyeDcqANUfJ9_/_buildManifest.js" defer=""></script><script src="/blog/_next/static/ZyG-RamwQyeDcqANUfJ9_/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header data-theme="dark" class="style_nav-root__jrAJR" style="height:80px"><section class="style_nav-section__sS_tB"><a class="style_nav-logo__jRYAT" href="/blog"><h3>Allen Lee@Collections</h3></a><nav aria-label="Main" data-orientation="horizontal" dir="ltr" class="style_nav-menus__4aQM9"><div style="position:relative"><ul data-orientation="horizontal" dir="ltr"><li><button class="style_btn__AkQj7 style_subtle__i70rQ style_nav-trigger__ekUye" id="radix-:Rj6:-trigger-radix-:Rjj6:" data-state="closed" aria-expanded="false" aria-controls="radix-:Rj6:-content-radix-:Rjj6:" data-radix-collection-item="">Overview <svg stroke="currentColor" fill="none" stroke-width="0" viewBox="0 0 15 15" aria-hidden="true" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M4.18179 6.18181C4.35753 6.00608 4.64245 6.00608 4.81819 6.18181L7.49999 8.86362L10.1818 6.18181C10.3575 6.00608 10.6424 6.00608 10.8182 6.18181C10.9939 6.35755 10.9939 6.64247 10.8182 6.81821L7.81819 9.81821C7.73379 9.9026 7.61934 9.95001 7.49999 9.95001C7.38064 9.95001 7.26618 9.9026 7.18179 9.81821L4.18179 6.81821C4.00605 6.64247 4.00605 6.35755 4.18179 6.18181Z" fill="currentColor"></path></svg></button></li></ul></div></nav></section></header><main data-theme="light" style="background-color:var(--colorNeutralBackground1);overflow-x:hidden;overflow-y:auto;width:100vw;height:calc(100vh - 80px)" id="main"><div class="collection_slug_Root__xztwf style_mainStyle__8eIxs"><div class="style_graphicsPost__36P1T"><h1><a href="#" title="undefined" class="style_titleStyle__6CuPY">Graphics Programming(七) —— 透明效果</a></h1><div style="width:100%;text-align:center;margin:0.5rem auto"><span class="style_aphorism__ue0s6">无论怎样安排渲染顺序总是会有机会出错</span></div>
<p>前置知识</p>
<div class="style_Tab__IjTlz">对于<div role="expansion" class="style_Expansion__lekPG">不透明(opaque)物体</div>, 深度缓冲(depth buffer|z-buffer)技术解决了遮盖效果<div class="style_Tab__IjTlz style_hidden__yfyDi">当开启深度测试后, 将根据片元的深度值和已经在深度缓冲中的深度值比较来决定片元是否被遮挡<br/>当开启深度写入后, 深度值低的片元将更新颜色缓冲中的像素值, 并将其深度值更新存储于深度缓冲中</div><br/>对于透明物体, 有时必须关闭深度写入(ZWrite)</div>
<p></p>
<p>基本原理</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">透明度测试</div><div class="style_Tab__IjTlz style_hidden__yfyDi">透明度测试(Alpha Test): 当片元透明度低于阈值时, 舍弃该片元<br/>只有完全透明或者完全不透明之分<br/>同时不需要关闭深度写入</div><br/><div role="expansion" class="style_Expansion__lekPG">透明度混合</div><div class="style_Tab__IjTlz style_hidden__yfyDi">透明度混合(Alpha Blending): 使用当前片元的透明度来混合颜色缓冲器中的颜色, 获取新颜色<br/>可以得到真正的半透明效果<br/>&quot;混合时&quot;<span class="style_Quote__dLoMM" id="#1">关闭深度写入</span>, 且必须严格控制物体的渲染顺序</div><br/><div role="expansion" class="style_Expansion__lekPG">双面渲染</div><div class="style_Tab__IjTlz style_hidden__yfyDi">默认情况渲染引擎会自动剔除物体背面的贴图, 导致透明物体看不到内部和背面<br/>需要通过 Cull 命令修改是否剔除(Cull Off|Back|Front)<br/>对于透明度混合来讲, 双面渲染需要严格对待.</div><br/></div>
<p></p>
<p>渲染</p>
<div class="style_Tab__IjTlz"><div role="expansion" class="style_Expansion__lekPG">渲染顺序</div><div class="style_Tab__IjTlz style_hidden__yfyDi">一般来说有几个要求:<div class="style_Tab__IjTlz"><ol>
<li>先渲染所有不透明物体, 并开启深度测试和深度写入</li>
</ol><br/><ol start="2">
<li>后把半透明物体按距离远近进行排序, 然后依顺序渲染半透明物体, 并开启深度测试关闭深度写入</li>
</ol><br/><ol start="3">
<li>模型应该尽量是凸面体</li>
</ol></div>如果仍有错误渲染, 应拆分模型或者模糊透明通道</div><br/><div role="expansion" class="style_Expansion__lekPG">渲染队列</div><div class="style_Tab__IjTlz style_hidden__yfyDi">为使得程序员能自主的控渲染, unity使用渲染队列(render queue)标签来辅助渲染<br/>位于SubShader的Tag标签的&quot;Queue&quot;值<table><tbody><tr><th>名称</th><th>索引号</th><th>描述</th></tr><tr><td>Background</td><td>1000</td><td>该队列会在其它任何队列前进行渲染(通常用于绘制背景)</td></tr><tr><td>Geometry</td><td>2000</td><td>默认的队列.(不透明物体使用)</td></tr><tr><td>AlphaTest</td><td>2450</td><td>需要透明度测试的队列.</td></tr><tr><td>Transparent</td><td>3000</td><td>按照从后往前的顺序渲染的队列.(使用了透明度混合的物体使用)</td></tr><tr><td>Overlay</td><td>4000</td><td>用于实现叠加效果.(最后渲染的物体使用)</td></tr></tbody></table></div><br/><div role="expansion" class="style_Expansion__lekPG">颜色混合</div><div class="style_Tab__IjTlz style_hidden__yfyDi">使用alpha混合颜色缓冲器中的颜色时, 如何混合由 Blend 指令控制<br/>位于Pass代码块中<br/><span class="style_ModelTrigger__Z_WW1" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-:Rlphl6:" data-state="closed">常见的混合效果</span><table><tbody><tr><td>Blend Off</td><td>关闭颜色混合</td></tr><tr><td>Blend Src混合因子 Dst混合因子</td><td>开启混合并设置混合因子</td></tr><tr><td>Blend SrcRGB混合因子 DstRGB混合因子, SrcA混合因子 DstA混合因子</td><td>与上面相似, 只是使用不同的因子混合透明通道</td></tr><tr><td>BlendOp Operation</td><td><span>更改颜色混合的运算(Add/Sub/RevSub/<span class="style_Quote__dLoMM" id="#2">Min/Max</span>)</span></td></tr></tbody></table><br/>计算公式: 缓存颜色RGB/A = 混合因子 * 源颜色RGB/A + 混合因子 * 缓存中颜色RGB/A<table><thead><tr><td align="center" colSpan="2" style="font-size:20px">混合因子</td></tr></thead><tbody><tr><th>参数</th><th>描述</th></tr><tr><td>One</td><td>因子为1</td></tr><tr><td>Zero</td><td>因子为0</td></tr><tr><td>SrcColor</td><td>因子为源颜色值</td></tr><tr><td>SrcAlpha</td><td>因子为源alpha值</td></tr><tr><td>DstColor</td><td>因子为目标颜色值</td></tr><tr><td>DstAlpha</td><td>因子为目标alpha值</td></tr><tr><td>OneMinusSrcColor</td><td>因子为(1-源颜色)</td></tr><tr><td>OneMinusSrcAlpha</td><td>因子为(1-源alpha)</td></tr><tr><td>OneMinusDstColor</td><td>因子为(1-目标颜色)</td></tr><tr><td>OneMinusDstAlpha</td><td>因子为(1-目标alpha)</td></tr></tbody></table></div><br/></div><div id="Comment" class="style_Comment__GsBhh"></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"matter":{"title":"Graphics Programming(七) —— 透明效果","tags":["graphics"],"index":7},"absPath":"/home/runner/work/blog/blog/renderer/mdx/graphics/transparency.mdx","type":"mdx","slug":["transparency"],"collection":"graphics","url":"/graphics/transparency"},"compiled":{"content":"\"use strict\";\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst frontmatter = {\n  \"title\": \"Graphics Programming(七) —— 透明效果\",\n  \"tags\": [\"graphics\"],\n  \"index\": 7\n};\nconst QuoteList = [\"Pass中的 ZWrite Off 用于关闭深度写入\", \"Min和Max是分量比较, 并分量代入的\"];\nconst ImgList = [\"常见的混合类型\", \"滤波模式\"];\nfunction _createMdxContent(props) {\n  const _components = {\n    li: \"li\",\n    ol: \"ol\",\n    p: \"p\",\n    ...props.components\n  }, {Aphorism, Expansion, Model, Quote, Tab, Table} = _components;\n  if (!Aphorism) _missingMdxReference(\"Aphorism\", true);\n  if (!Expansion) _missingMdxReference(\"Expansion\", true);\n  if (!Model) _missingMdxReference(\"Model\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!Tab) _missingMdxReference(\"Tab\", true);\n  if (!Table) _missingMdxReference(\"Table\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(Aphorism, {\n      children: \"无论怎样安排渲染顺序总是会有机会出错\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"前置知识\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [\"对于\", _jsx(Expansion, {\n        children: \"不透明(opaque)物体\"\n      }), \", 深度缓冲(depth buffer|z-buffer)技术解决了遮盖效果\", _jsxs(Tab, {\n        expan: true,\n        children: [\"当开启深度测试后, 将根据片元的深度值和已经在深度缓冲中的深度值比较来决定片元是否被遮挡\", _jsx(\"br\", {}), \"当开启深度写入后, 深度值低的片元将更新颜色缓冲中的像素值, 并将其深度值更新存储于深度缓冲中\"]\n      }), \"对于透明物体, 有时必须关闭深度写入(ZWrite)\"]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"基本原理\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"透明度测试\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"透明度测试(Alpha Test): 当片元透明度低于阈值时, 舍弃该片元\", _jsx(\"br\", {}), \"只有完全透明或者完全不透明之分\", _jsx(\"br\", {}), \"同时不需要关闭深度写入\"]\n      }), _jsx(Expansion, {\n        children: \"透明度混合\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"透明度混合(Alpha Blending): 使用当前片元的透明度来混合颜色缓冲器中的颜色, 获取新颜色\", _jsx(\"br\", {}), \"可以得到真正的半透明效果\", _jsx(\"br\", {}), \"\\\"混合时\\\"\", _jsx(Quote, {\n          id: \"#1\",\n          children: \"关闭深度写入\"\n        }), \", 且必须严格控制物体的渲染顺序\"]\n      }), _jsx(Expansion, {\n        children: \"双面渲染\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"默认情况渲染引擎会自动剔除物体背面的贴图, 导致透明物体看不到内部和背面\", _jsx(\"br\", {}), \"需要通过 Cull 命令修改是否剔除(Cull Off|Back|Front)\", _jsx(\"br\", {}), \"对于透明度混合来讲, 双面渲染需要严格对待.\"]\n      })]\n    }), \"\\n\", _jsx(\"p\", {}), \"\\n\", _jsx(_components.p, {\n      children: \"渲染\"\n    }), \"\\n\", _jsxs(Tab, {\n      children: [_jsx(Expansion, {\n        children: \"渲染顺序\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"一般来说有几个要求:\", _jsxs(Tab, {\n          children: [_jsxs(_components.ol, {\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"先渲染所有不透明物体, 并开启深度测试和深度写入\"\n            }), \"\\n\"]\n          }), _jsx(\"br\", {}), _jsxs(_components.ol, {\n            start: \"2\",\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"后把半透明物体按距离远近进行排序, 然后依顺序渲染半透明物体, 并开启深度测试关闭深度写入\"\n            }), \"\\n\"]\n          }), _jsx(\"br\", {}), _jsxs(_components.ol, {\n            start: \"3\",\n            children: [\"\\n\", _jsx(_components.li, {\n              children: \"模型应该尽量是凸面体\"\n            }), \"\\n\"]\n          })]\n        }), \"如果仍有错误渲染, 应拆分模型或者模糊透明通道\"]\n      }), _jsx(Expansion, {\n        children: \"渲染队列\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"为使得程序员能自主的控渲染, unity使用渲染队列(render queue)标签来辅助渲染\", _jsx(\"br\", {}), \"位于SubShader的Tag标签的\\\"Queue\\\"值\", _jsx(Table, {\n          children: [{\n            cells: [\"名称\", \"索引号\", \"描述\"],\n            component: ['th', 'th', 'th']\n          }, {\n            cells: [\"Background\", \"1000\", \"该队列会在其它任何队列前进行渲染(通常用于绘制背景)\"]\n          }, {\n            cells: [\"Geometry\", \"2000\", \"默认的队列.(不透明物体使用)\"]\n          }, {\n            cells: [\"AlphaTest\", \"2450\", \"需要透明度测试的队列.\"]\n          }, {\n            cells: [\"Transparent\", \"3000\", \"按照从后往前的顺序渲染的队列.(使用了透明度混合的物体使用)\"]\n          }, {\n            cells: [\"Overlay\", \"4000\", \"用于实现叠加效果.(最后渲染的物体使用)\"]\n          }]\n        })]\n      }), _jsx(Expansion, {\n        children: \"颜色混合\"\n      }), _jsxs(Tab, {\n        expan: true,\n        children: [\"使用alpha混合颜色缓冲器中的颜色时, 如何混合由 Blend 指令控制\", _jsx(\"br\", {}), \"位于Pass代码块中\", _jsx(\"br\", {}), _jsx(Model, {\n          about: \"@1\",\n          children: \"常见的混合效果\"\n        }), _jsx(Table, {\n          children: [{\n            cells: [\"Blend Off\", \"关闭颜色混合\"]\n          }, {\n            cells: [\"Blend Src混合因子 Dst混合因子\", \"开启混合并设置混合因子\"]\n          }, {\n            cells: [\"Blend SrcRGB混合因子 DstRGB混合因子, SrcA混合因子 DstA混合因子\", \"与上面相似, 只是使用不同的因子混合透明通道\"]\n          }, {\n            cells: [\"BlendOp Operation\", _jsxs(\"span\", {\n              children: [\"更改颜色混合的运算(Add/Sub/RevSub/\", _jsx(Quote, {\n                id: \"#2\",\n                children: \"Min/Max\"\n              }), \")\"]\n            })]\n          }]\n        }), _jsx(\"br\", {}), \"计算公式: 缓存颜色RGB/A = 混合因子 * 源颜色RGB/A + 混合因子 * 缓存中颜色RGB/A\", _jsx(Table, {\n          title: \"混合因子\",\n          children: [{\n            cells: [\"参数\", \"描述\"],\n            component: ['th', 'th']\n          }, {\n            cells: [\"One\", \"因子为1\"]\n          }, {\n            cells: [\"Zero\", \"因子为0\"]\n          }, {\n            cells: [\"SrcColor\", \"因子为源颜色值\"]\n          }, {\n            cells: [\"SrcAlpha\", \"因子为源alpha值\"]\n          }, {\n            cells: [\"DstColor\", \"因子为目标颜色值\"]\n          }, {\n            cells: [\"DstAlpha\", \"因子为目标alpha值\"]\n          }, {\n            cells: [\"OneMinusSrcColor\", \"因子为(1-源颜色)\"]\n          }, {\n            cells: [\"OneMinusSrcAlpha\", \"因子为(1-源alpha)\"]\n          }, {\n            cells: [\"OneMinusDstColor\", \"因子为(1-目标颜色)\"]\n          }, {\n            cells: [\"OneMinusDstAlpha\", \"因子为(1-目标alpha)\"]\n          }]\n        })]\n      })]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = props.components || ({});\n  return MDXLayout ? _jsx(MDXLayout, {\n    ...props,\n    children: _jsx(_createMdxContent, {\n      ...props\n    })\n  }) : _createMdxContent(props);\n}\nreturn {\n  frontmatter,\n  QuoteList,\n  ImgList,\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","toc":[]},"overview":[{"length":22,"name":"archive"},{"length":15,"name":"graphics"},{"length":1,"name":"math"},{"length":8,"name":"network"},{"length":2,"name":"sstory"},{"name":"practice","length":2}]},"__N_SSG":true},"page":"/[collection]/[...slug]","query":{"collection":"graphics","slug":["transparency"]},"buildId":"ZyG-RamwQyeDcqANUfJ9_","assetPrefix":"/blog","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>